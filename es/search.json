[{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement riannone@.com. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CODE_OF_CONDUCT.html","id":"1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CODE_OF_CONDUCT.html","id":"2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CODE_OF_CONDUCT.html","id":"3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CODE_OF_CONDUCT.html","id":"4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.0, available https://www.contributor-covenant.org/version/2/0/code_of_conduct.html. Community Impact Guidelines inspired Mozilla’s code conduct enforcement ladder. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Information and Guidelines for Contributing to pointblank","title":"Information and Guidelines for Contributing to pointblank","text":"many ways contribute ongoing development pointblank package. contributions can rather easy (e.g., fixing typos, improving documentation, filing issues feature requests problems, etc.) whereas contributions can require time patience (like answering questions submitting pull requests code changes). Just know help provided capacity much appreciated. :)","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CONTRIBUTING.html","id":"filing-issues","dir":"","previous_headings":"","what":"Filing Issues","title":"Information and Guidelines for Contributing to pointblank","text":"believe found bug, create minimal reprex posting pointblank issue tracker. Try include anything unnecessary, just minimal amount code constitutes reproducible bug. try verify bug running code reprex provided. quality reprex reduce amount back--forth communication trying understand execute code systems.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CONTRIBUTING.html","id":"answering-questions","dir":"","previous_headings":"","what":"Answering questions","title":"Information and Guidelines for Contributing to pointblank","text":"great way help simply answering questions. ’s amazing little conversation lead better insights problem. Don’t quite know answer? ’s okay . ’re together. might answer user questions? forums Q&pointblank include RStudio community, Twitter (good search term pointblank #rstats), Stack Overflow. Good etiquette key interactions: good person ask questions.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CONTRIBUTING.html","id":"making-pull-requests","dir":"","previous_headings":"Answering questions","what":"Making Pull Requests","title":"Information and Guidelines for Contributing to pointblank","text":"consider making pull request (PR), please file issue first explain problem detail. PR enhancement, detail change make things better package users. Bugfix PRs also requre explanation bug proposed fix remove bug. great way illustrate bug include reprex. upfront work prior preparing PR can time-consuming opens line communication package authors community, perhaps leading better enhancement effective fixes! consensus PR based issue helpful, adhering following process make things proceed quickly: Create separate Git branch PR. Look GitHub Actions build status badges making changes; badges available package README. pointblank package follows tidyverse style guide please adopt style guidelines submitted code best possible. internal documentation uses roxygen2; contribution requires new revised documentation ensure roxygen comments added/modified (modify .Rd files man folder). use testthat code coverage; contributions test cases included helpful easier accept. Add bullet top NEWS.md current development version header describing user-facing changes made; include GitHub username, links relevant issue(s)/PR(s).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2017-2021 Richard Iannone Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/PULL_REQUEST_TEMPLATE.html","id":null,"dir":"","previous_headings":"","what":"Summary","title":"Summary","text":"Thank contributing pointblank! make process easier everyone, please explain context purpose contribution. Also, list changes made existing code documentation.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/PULL_REQUEST_TEMPLATE.html","id":"related-github-issues-and-prs","dir":"","previous_headings":"","what":"Related GitHub Issues and PRs","title":"Summary","text":"Ref: #","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/PULL_REQUEST_TEMPLATE.html","id":"checklist","dir":"","previous_headings":"","what":"Checklist","title":"Summary","text":"understand agree Code Conduct. listed major changes NEWS. added testthat unit tests tests/testthat new functionality.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/articles/INFO-1.html","id":"starting-with-a-simple-example","dir":"Articles","previous_headings":"","what":"Starting with a Simple Example","title":"Intro to Information Management","text":"workflow somewhat similar concept usage Data Quality Reporting Workflow (VALID-). Instead agent, use informant get informant create_informant() function. point informant target table can data frame, tibble, database table (tbl_dbi object), Spark DataFrame (tbl_spark object). small_table dataset included pointblank package. ’s small, uninteresting dataset ’s useful simple examples. looks like: Let’s use small_table object see results introducing informant. Printing informant show us automatically-generated information small_table dataset, adding Columns section.  Alternatively can get report get_informant_report() access additional output options, like producing narrower version output.  Either way, get initial reporting basic. done next add information following set info_*() functions: info_tabular(): Add information focuses aspects data table whole info_columns(): Add information focuses aspects data table’s columns info_section(): Add information focuses key aspect data table Let’s try adding information functions look resulting report.  can seen, report bit filled information. TABLE COLUMNS sections prescribed order new section named INFORMATION follows (one subsection called EXAMPLES DOCUMENTATION). Let’s explore three different info_*() functions work.","code":"small_table ## # A tibble: 13 × 8 ##    date_time           date           a b             c      d e     f     ##    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   ## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   ## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Example No. 1\"   ) informant get_informant_report(informant, size = \"small\") informant <-   create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Example No. 2\"   ) %>%   info_tabular(     description = \"This table is included in the **pointblank** pkg.\"   ) %>%   info_columns(     columns = \"date_time\",     info = \"This column is full of timestamps.\"   ) %>%   info_section(     section_name = \"further information\",      `examples and documentation` = \"Examples for how to use the `info_*()` functions     (and many more) are available at the      [**pointblank** site](https://rich-iannone.github.io/pointblank/).\"   )  informant"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/INFO-1.html","id":"the-table-section-and-info_tabular","dir":"Articles","previous_headings":"","what":"The TABLE Section and info_tabular()","title":"Intro to Information Management","text":"info_tabular() function adds information TABLE section. use named arguments define subsection names content. previous example info_tabular(description = \"table included **pointblank** pkg.\") used make DESCRIPTION subsection (section titles automatically capitalized), info text Markdown text \"table included **pointblank** pkg.\". can define many subsections TABLE section need, either info_tabular() call across multiple calls. want use complicated subsection names single word, can enclose text back ticks. example, put emoji subsection name? excerpt complete report, showing just report header TABLE section.  TABLE section great place put information table needs front center. Examples useful topics section might include: high-level summary table, stating purpose importance row table represents main users table within organization description table generated information frequency updates","code":"informant %>%    info_tabular(`🔄 updates` = \"This table is not regularly updated.\")"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/INFO-1.html","id":"the-columns-section-and-info_columns","dir":"Articles","previous_headings":"","what":"The COLUMNS Section and info_columns()","title":"Intro to Information Management","text":"section follows TABLE section COLUMNS. section provides opportunity describe table column much detail necessary. , individual columns serve subsections (automatically generated upon using create_informant()) can subsections within column well. interesting thing information provided via info_columns() information additive. can make multiple calls info_columns() disperse common pieces info text multiple columns append text existing. Let’s take look practice far interesting palmerpenguins::penguins dataset. , fill information column adapting documentation palmerpenguins package.  able provide subsections name ℹ️ , furthermore, use tidyselect functions like ends_with() append info text common subsection exists across multiple columns. useful stating units common across three columns: bill_length_mm, bill_depth_mm, flipper_length_mm. following tidyselect functions available pointblank make process easier: starts_with(): Match columns start prefix. ends_with(): Match columns end suffix. contains(): Match columns contain literal string. matches(): Perform matching regular expression. everything(): Select columns.","code":"informant_pp <-    create_informant(     read_fn = ~ palmerpenguins::penguins,     tbl_name = \"penguins\",     label = \"The `penguins` dataset from the **palmerpenguins** 📦.\"   ) %>%    info_columns(     columns = \"species\",     `ℹ️` = \"A factor denoting penguin species (*Adélie*, *Chinstrap*, and *Gentoo*).\"   ) %>%   info_columns(     columns = \"island\",     `ℹ️` = \"A factor denoting island in Palmer Archipelago, Antarctica     (*Biscoe*, *Dream*, or *Torgersen*).\"   ) %>%   info_columns(     columns = \"bill_length_mm\",     `ℹ️` = \"A number denoting bill length\"   ) %>%   info_columns(     columns = \"bill_depth_mm\",     `ℹ️` = \"A number denoting bill depth\"   ) %>%   info_columns(     columns = \"flipper_length_mm\",     `ℹ️` = \"An integer denoting flipper length\"   ) %>%   info_columns(     columns = ends_with(\"mm\"),     `ℹ️` = \"(in units of millimeters).\"   ) %>%   info_columns(     columns = \"body_mass_g\",     `ℹ️` = \"An integer denoting body mass (grams).\"   ) %>%   info_columns(     columns = \"sex\",     `ℹ️` = \"A factor denoting penguin sex (`\\\"female\\\"`, `\\\"male\\\"`).\"   ) %>%   info_columns(     columns = \"year\",     `ℹ️` = \"The study year (e.g., `2007`, `2008`, `2009`).\"   )  informant_pp"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/INFO-1.html","id":"extra-sections-and-info_section","dir":"Articles","previous_headings":"","what":"Extra Sections and info_section()","title":"Intro to Information Management","text":"information can’t don’t want put TABLE COLUMNS sections, can place extra sections (subsections) info_section() function. sections go aforementioned sections order creation. Let’s put together extra sections describe palmerpenguins::penguins dataset. excerpt complete report, showing just SOURCE section footer.  types information go well separate sections? ideas : info related source data table (e.g., references, background, etc.) definitions/explanations terms used persons responsible data table, perhaps contact information details table produced important issues table notes upcoming changes links information artifacts pertain table information report (meta!); might include things like update history, persons responsible, instructions contribute, etc. Really, sky limit ! can incorporate great deal useful information use process generate reports important tables within organization. ’s can done. go next phase (Advanced Information Management article). go way now, total transformation. think ’re ready?","code":"informant_pp <-    informant_pp %>%   info_section(     section_name = \"source\",     \"References\" = c( \"- Adélie penguins: Palmer Station Antarctica LTER and K. Gorman. 2020. Structural  size measurements and isotopic signatures of foraging among adult male and female  Adélie penguins (Pygoscelis adeliae) nesting along the Palmer Archipelago near Palmer Station, 2007-2009 ver 5. Environmental Data Initiative <https://doi.org/10.6073/pasta/98b16d7d563f265cb52372c8ca99e60f>\",  \"- Gentoo penguins: Palmer Station Antarctica LTER and K. Gorman. 2020. Structural size measurements and isotopic signatures of foraging among adult male and female Gentoo penguin (Pygoscelis papua) nesting along the Palmer Archipelago near Palmer Station, 2007-2009 ver 5. Environmental Data Initiative <https://doi.org/10.6073/pasta/7fca67fb28d56ee2ffa3d9370ebda689>\",  \"- Chinstrap penguins: Palmer Station Antarctica LTER and K. Gorman. 2020. Structural size measurements and isotopic signatures of foraging among adult male and female Chinstrap penguin (Pygoscelis antarcticus) nesting along the Palmer Archipelago near Palmer Station, 2007-2009 ver 6. Environmental Data Initiative <https://doi.org/10.6073/pasta/c14dfcfada8ea13a17536e73eb6fbe9e> \"     ),     \"Note\" = \" Originally published in: Gorman KB, Williams TD, Fraser WR (2014) Ecological Sexual Dimorphism and Environmental Variability within a Community of Antarctic Penguins (Genus Pygoscelis). PLoS ONE 9(3): e90081. doi:10.1371/journal.pone.0090081 \" )  informant_pp"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/INFO-2.html","id":"getting-snippets-of-useful-text-with-the-info_snippet-function","dir":"Articles","previous_headings":"","what":"Getting Snippets of Useful Text With the info_snippet() Function","title":"Advanced Information Management","text":"great source information table can table . Suppose want show categorical values particular column. Maybe ’d like display range values important numeric column. Perhaps show KPI values can calculated using data table? can done info_snippet() function. give snippet name give function call. Let’s small_table dataset available pointblank. table looks like: wanted mean value data column d rounded one decimal place, one way expression: Inside info_snippet() call, used creating informant object, expression look like : small_table dataset associated informant target table, , ’s represented leading . functional sequence given fn. ’s important note ’s leading ~, making expression RHS formula (don’t want execute anything , time). Lastly, snippet given name \"mean_d\". know snippet produce value 2304.7 can ? put value info text use snippet_name key. works similarly glue package text interpolation, ’s continuation example: Within text, ’s use curly braces name snippet. ’s 2304.7 value inserted. methodology inserting computed values snippets can performed wherever info text provided (either info_tabular(), info_columns(), info_section() functions). Let’s take look report printing informant object  Hmm. \"... {mean_d} ...\" text report replaced mean value column d. gives? Well, ’s one finalizing step needs done always done wrap Information Management workflow use incorporate() function. Let’s write whole thing finish call incorporate().  time, sweet success. value appears overall formatting looks great! useful thing, long remember use incorporate() function make happen (next section).","code":"small_table ## # A tibble: 13 × 8 ##    date_time           date           a b             c      d e     f     ##    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   ## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   ## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high small_table %>% .$d %>% mean() %>% round(1) ## [1] 2304.7 informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Example No. 2\"   ) %>%   info_snippet(     snippet_name = \"mean_d\",     fn = ~ . %>% .$d %>% mean() %>% round(1)   ) informant <-    informant %>%   info_columns(     columns = vars(d),     info = \"This column contains fairly large numbers (much larger than     those numbers in column `a`. The mean value is {mean_d}, which is     far greater than any number in that other column.\"   ) informant informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Example No. 2\"   ) %>%   info_snippet(     snippet_name = \"mean_d\",     fn = ~ . %>% .$d %>% mean() %>% round(1)   ) %>%     info_columns(     columns = vars(d),     info = \"This column contains fairly large numbers (much larger than     those numbers in column `a`. The mean value is {mean_d}, which is     far greater than any number in that other column.\"   ) %>%   incorporate()  informant"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/INFO-2.html","id":"ensuring-that-snippets-and-other-table-metadata-element-are-up-to-date","dir":"Articles","previous_headings":"","what":"Ensuring That Snippets (and Other Table Metadata Element) Are Up-to-Date","title":"Advanced Information Management","text":"Tables can change time. Whether data source public dataset, organization’s data table, continually-updated Excel file (😱), ready change. previous example, used incorporate() function finalize report. Without , snippet didn’t work. two major things incorporate() Information Management workflow. Evaluation text snippets info_snippet() calls, , insertion snippets info text within \"{<snippet_name>}\". Updating table row column counts header report. really incorporating aspects table report incorporate() might might also think regenerating, refreshing, renewing table. gives pointblank license access table way interrogate() VALID-validation workflow. first use incorporate(), text snippets put places; subsequent uses incorporate() replace appropriate text necessary. Every use incorporate() update row column counts header. ’s short demo header changing, ’s pretty instructive. Let’s use small_table object target_table. dim() can totally sure table dimensions. Let’s allow informant access target_table read_fn argument. case, expression ~ target_table (simply gets table global workspace). using incorporate() printing informant_tt object, let’s just examine header. excerpt complete report, showing just header.  number rows columns reported header checks : 13 rows 8 columns. Now, let’s manually enlarge target_table print new row column counts. ’ve got informant object, let’s see incorporate() keeps pace change. excerpt complete report, showing just header.  Great! Using incorporate() accurately updated reporting row column counts header. ’s also much worth noting use read_fn important . target_table given tbl argument create_informant(), table bound informant initial state (13 rows 8 columns) updates table wouldn’t reflected reporting upon using incorporate(). table-reading function meant obtaining table every time table needed. short, unless uses info_snippet() table isn’t expected change, ’s recommended use incorporate() final call workflow.","code":"target_table <- small_table  dim(target_table) ## [1] 13  8 informant_tt <-    create_informant(     read_fn = ~ target_table,     tbl_name = \"target_table\",     label = \"Example No. 3\"   ) %>%   incorporate()  informant_tt target_table <-    dplyr::bind_rows(small_table, small_table) %>%   dplyr::mutate(g = a + c)  dim(target_table) ## [1] 26  9 informant_tt %>% incorporate()"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/INFO-2.html","id":"helpful-pointblank-functions-that-work-exceedingly-well-with-info_snippet","dir":"Articles","previous_headings":"","what":"Helpful pointblank Functions that Work Exceedingly Well with info_snippet()","title":"Advanced Information Management","text":"functions available pointblank make much easier get commonly-used text snippets. begin snip_ prefix : snip_list(): Gets list column categories snip_lowest(): Gets lowest value column snip_highest(): Gets highest value column functions can used directly fn value don’t specify table since assumed target table ’ll snipping data . Let’s look action.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/articles/INFO-2.html","id":"the-snip_list-function","dir":"Articles","previous_headings":"","what":"The snip_list() Function","title":"Advanced Information Management","text":"describing aspect target table, may want extract values column include piece info text. ’d want values nicely formatted list (commas) ’d probably prefer constrained certain size (potentially generate massive amounts text). can efficiently done snip_list(). Let’s experiment combination snip_list() info_snippet(), extending palmerpenguins example Intro Information Management article. excerpt complete report, showing just header part COLUMNS section.  seemed work quite well. need determining strings hardcoding info text, snip_list() work . also works numeric values. Let’s use snip_list() provide text snippet based values year column (integer column): excerpt complete report, showing just bottom COLUMNS section footer.  , issues formatting display values. got info text \"study year (\"2007\", \"2008\", \"2009\" ).\" efforts saved us determine , plus, data updated new year values, reflected info text upon using incorporate(). Refreshed info text really provides huge benefits, especially data changes lot (e.g., database tables).","code":"informant_pp <-    create_informant(     read_fn = ~ palmerpenguins::penguins,     tbl_name = \"penguins\",     label = \"The `penguins` dataset from the **palmerpenguins** 📦.\"   ) %>%    info_columns(     columns = \"species\",     `ℹ️` = \"A factor denoting penguin species ({species_snippet}).\"   ) %>%   info_columns(     columns = \"island\",     `ℹ️` = \"A factor denoting island in Palmer Archipelago, Antarctica     ({island_snippet}).\"   ) %>%   info_snippet(     snippet_name = \"species_snippet\",     fn = snip_list(column = \"species\")   ) %>%   info_snippet(     snippet_name = \"island_snippet\",     fn = snip_list(column = \"island\")   ) %>%   incorporate()  informant_pp informant_pp <-   informant_pp %>%   info_columns(     columns = \"year\",     `ℹ️` = \"The study year ({year_snippet}).\"   ) %>%   info_snippet(     snippet_name = \"year_snippet\",     fn = snip_list(column = \"year\")   ) %>%   incorporate()  informant_pp"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/INFO-2.html","id":"the-snip_lowest-and-snip_highest-functions","dir":"Articles","previous_headings":"","what":"The snip_lowest() and snip_highest() Functions","title":"Advanced Information Management","text":"can get lowest highest values column inject formatted values info_text. Let’s measured values penguins dataset snip_lowest() snip_highest().  can see report output can creatively use lowest highest values obtained snip_lowest() snip_highest() specify range simply show maximum value. ordering info_columns() calls example affects overall layout text (text appending behavior), placement info_snippet() calls matter. , , must use incorporate() update text snippets render appropriate locations (inside {<snippet_name>}).","code":"informant_pp <-   informant_pp %>%   info_columns(     columns = \"bill_length_mm\",     `ℹ️` = \"A number denoting bill length\"   ) %>%   info_columns(     columns = \"bill_depth_mm\",     `ℹ️` = \"A number denoting bill depth (in the range of     {min_depth} to {max_depth} millimeters).\"   ) %>%   info_columns(     columns = \"flipper_length_mm\",     `ℹ️` = \"An integer denoting flipper length\"   ) %>%   info_columns(     columns = matches(\"length\"),     `ℹ️` = \"(in units of millimeters).\"   ) %>%   info_columns(     columns = \"flipper_length_mm\",     `ℹ️` = \"Largest observed is {largest_flipper_length} mm.\"   ) %>%   info_snippet(     snippet_name = \"min_depth\",     fn = snip_lowest(column = \"bill_depth_mm\")   ) %>%   info_snippet(     snippet_name = \"max_depth\",     fn = snip_highest(column = \"bill_depth_mm\")   ) %>%   info_snippet(     snippet_name = \"largest_flipper_length\",     fn = snip_highest(column = \"flipper_length_mm\")   ) %>%   incorporate()  informant_pp"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/INFO-2.html","id":"text-tricks","dir":"Articles","previous_headings":"","what":"Text Tricks","title":"Advanced Information Management","text":"info text can jazzed Markdown, extra tricks make authoring text bit pleasurable. know text tricks ’ll able express information many interesting ways.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/articles/INFO-2.html","id":"links-and-dates","dir":"Articles","previous_headings":"","what":"Links and Dates","title":"Advanced Information Management","text":"links text, pointblank try identify style nicely. amounts using pleasing, light-blue color underlines appear hover. doesn’t take much style links require something. , Markdown links written < link url > [ link text ]( link url ) get transformation treatment. Sometimes want dates stand text. Try enclosing date expressed ISO-8601 standard parentheses, like : (2004-12-01). happen date set monospaced variation reporting font, , underlined striking shade purple. ’s might use features otherwise adding information palmerpenguins reporting: excerpt complete report, showing just TABLE section header.","code":"informant_pp <-   informant_pp %>%   info_tabular(     `R dataset` = \"The goal of `palmerpenguins` is to provide a great dataset     for data exploration & visualization, as an alternative to `iris`. The     latest CRAN release was published on (2020-07-25).\",     `data collection` = \"Data were collected and made available by Dr. Kristen     Gorman and the [Palmer Station, Antarctica LTER](https://pal.lternet.edu),     a member of the [Long Term Ecological Research Network](https://lternet.edu).\",     citation = \"Horst AM, Hill AP, Gorman KB (2020). palmerpenguins: Palmer      Archipelago (Antarctica) penguin data. R package version 0.1.0.     <https://allisonhorst.github.io/palmerpenguins/>.      doi: 10.5281/zenodo.3960218.\"   ) %>%   incorporate()  informant_pp"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/INFO-2.html","id":"labels","dir":"Articles","previous_headings":"","what":"Labels","title":"Advanced Information Management","text":"can take portions text present labels. help call important attributes short form may eliminate need oft-repeated statements. might apply labels signify priority, category, information find useful. two options, Use double parentheses around text capture rectangular label: ((label text)) Use triple parentheses capture text rounded-rectangular label: (((label text))) excerpt complete report, showing just COLUMNS ADDITIONAL NOTES sections.","code":"informant_pp <-   informant_pp %>%   info_columns(     columns = vars(body_mass_g),      `ℹ️` = \"An integer denoting body mass.\"   ) %>%   info_columns(     columns = c(ends_with(\"mm\"), ends_with(\"g\")),     `ℹ️` = \"((measured))\"       ) %>%   info_section(     section_name = \"additional notes\",     `data types` = \"(((factor))) (((numeric))) (((integer)))\"   ) %>%   incorporate()  informant_pp"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/INFO-2.html","id":"get-stylin","dir":"Articles","previous_headings":"","what":"Get Stylin’","title":"Advanced Information Management","text":"want use CSS styles spans info text, ’s possible following construction: [[ info text ]]<< CSS style rules >> ’s important ensure CSS rule concluded ; character syntax. Styling word factor inside piece info text might look like : [[factor]]<<color: red; font-weight: 300;>> value. result looks something like :  many CSS style rules can used. ’s sample useful ones: color: <color value>; (text color) background-color: <color value>; (text’s background color) text-decoration: (overline | line-| underline); text-transform: (uppercase | lowercase | capitalize); letter-spacing: <+/- length value>; word-spacing: <+/- length value>; font-style: (normal | italic | oblique); font-weight: (normal | bold | 100-900); font-variant: (normal | bold | 100-900); border: <color value> <length value> (solid | dashed | dotted); Continuing palmerpenguins reporting, ’ll add info text take opportunity add CSS style rules using [[ ]]<< >> syntax. excerpt complete report, showing just bottom COLUMNS section, ADDITIONAL NOTES section, footer.  info_columns() info_section() function calls, able style single word (underline) even style labels (changing border background colors). syntax somewhat forgiving, allowing put line breaks ]] << style rules lines markup don’t overly long. , think text tricks? got admit can spice proceedings. inevitably added development pointblank proceeds. ’s now. Don’t think ’ve enough?","code":"informant_pp <-   informant_pp %>%   info_columns(     columns = vars(sex),      `ℹ️` = \"A [[factor]]<<text-decoration: underline;>>      denoting penguin sex (female or male).\"   ) %>%   info_section(     section_name = \"additional notes\",     keywords = \"     [[((penguins))]]<<border-color: platinum; background-color: #F0F8FF;>>      [[((Antarctica))]]<<border-color: #800080; background-color: #F2F2F2;>>      [[((measurements))]]<<border-color: #FFB3B3; background-color: #FFFEF4;>>     \"   ) %>%   incorporate()  informant_pp"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-I.html","id":"the-elements-of-this-workflow-an-agent-validation-functions-and-interrogate","dir":"Articles","previous_headings":"","what":"The Elements of this Workflow: an agent, validation functions, and interrogate()","title":"Introduction to the **Data Quality Reporting** Workflow (**VALID-I**)","text":"agent need workflow created create_agent() function. agent can handle one target table given time two different arguments can used specify table. first tbl, input table directly supplied agent. Alternatively, function can used read input data table read_fn argument one two ways: (1) using function (e.g., function() { <table reading code> }) , (2) R formula expression (e.g., ~ <table reading code>). agent needs directives table, , provide validation functions. check existence type column (col_exists() group col_is_*() functions). Others check cell column satisfying specific condition (col_vals_*() functions). can use many necessary satisfactory validation testing table question. certainly quite , ’s list validation functions questioning phrase function’s purpose: col_vals_lt(): column data less specified value? col_vals_lte(): column data less equal specified value? col_vals_equal(): column data equal specified value? col_vals_not_equal(): column data equal specified value? col_vals_gte(): column data greater equal specified value? col_vals_gt(): column data greater specified value? col_vals_between(): column data two specified values? col_vals_not_between(): column data two specified values? col_vals_in_set(): column data part specified set values? col_vals_not_in_set(): data part specified set values? col_vals_null(): column data NULL/NA? col_vals_not_null(): column data NULL/NA? col_vals_regex(): strings column data match regex pattern? col_vals_expr(): column data agree predicate expression? conjointly(): multiple rowwise validations result joint validity? rows_distinct(): row data distinct? col_is_character(): columns contain character/string data? col_is_numeric(): columns contain numeric values? col_is_integer(): columns contain integer values? col_is_logical(): columns contain logical values? col_is_date(): columns contain R Date objects? col_is_posix(): columns contain POSIXct dates? col_is_factor(): columns contain R factor objects? col_exists(): one columns actually exist? col_schema_match(): columns table (types) match predefined schema? final function needs called interrogate() function. validation functions, called agent object, don’t act target table interrogate() used. interrogation, usage validation functions serves instructions. interrogation phase instructions turn actions, agent carrying steps interrogation plan.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-I.html","id":"a-simple-example-with-the-basics","dir":"Articles","previous_headings":"","what":"A Simple Example with the Basics","title":"Introduction to the **Data Quality Reporting** Workflow (**VALID-I**)","text":"examples going forward, ’ll use small_table dataset. ’s included pointblank package. isn’t large, makes great simple examples. entirety: follows simple validation plan. test : date_time column indeed date-time column column f values \"low\", \"mid\", \"high\" values column less 10 strings column b fit particular regex pattern (\"^[0-9]-[-z]{3}-[0-9]{3}$\") column d values range 0 5000 (entirely true!) validation plan written interrogated. carried interactively, ’ll get status messages describe interrogation going. five OK messages means individual validations five validation steps passed within failure threshold levels. Since failure thresholds actually weren’t set, steps always display OK unless evaluation error occurred. Printing agent object gives step--step breakdown interrogation process.  Let’s look interpret report. bright green color strips left validation step indicates test units passed validation. lighter green color final step means least one failing unit. STEP column provides name validation function used basis validation step. COLUMNS shows us target column validation step. VALUES column lists values required validation step. TBL? indicates whether table mutated just interrogation validation step (via preconditions argument, available every validation function). right-facing arrows indicate table didn’t undergo transformation, working identity table every step. EVAL lets us know whether issues evaluating table (catching R errors warnings); checkmarks column show us issues interrogation. total number test units provided next ... column, absolute number fraction passing test units (PASS) failing test units (FAIL). W, S, N indicators tell us whether entered either WARN, STOP, NOTIFY states validation steps. didn’t set threshold levels states (can done actions argument, later), irrelevant report. Finally, EXT column provides opportunity download data extract rows CSV. rows represent rows failed test units. step 5, col_vals_between() validation step, data extract available (1 row). can either download CSV report examine extract R get_data_extracts() function: Recall validation step 5 asserted values column d 0 5000, however, extract small_table shows column d value 10000 lies outside specified range.","code":"small_table ## # A tibble: 13 × 8 ##    date_time           date           a b             c      d e     f     ##    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   ## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   ## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high agent <-    create_agent(     tbl = small_table,     tbl_name = \"small_table\",     label = \"VALID-I Example No. 1\"   ) %>%   col_is_posix(vars(date_time)) %>%   col_vals_in_set(vars(f), set = c(\"low\", \"mid\", \"high\")) %>%   col_vals_lt(vars(a), value = 10) %>%   col_vals_regex(vars(b), regex = \"^[0-9]-[a-z]{3}-[0-9]{3}$\") %>%   col_vals_between(vars(d), left = 0, right = 5000) %>%   interrogate() ── Interrogation Started - there are 5 steps ────────────────────────────────── ✓ Step 1: OK. ✓ Step 2: OK. ✓ Step 3: OK. ✓ Step 4: OK. ✓ Step 5: OK.  ── Interrogation Completed ───────────────────────────────────────────────── agent get_data_extracts(agent, i = 5) ## # A tibble: 1 × 8 ##   date_time           date           a b             c      d e     f     ##   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ## 1 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-I.html","id":"using-threshold-levels-and-actions","dir":"Articles","previous_headings":"","what":"Using Threshold Levels and Actions","title":"Introduction to the **Data Quality Reporting** Workflow (**VALID-I**)","text":"can useful gauge data quality setting failure thresholds validation steps. example, may acceptable point time tolerate 5% failing test units given validation. , several levels data quality might useful instructive, failing test units across validations grouped 0-5%, 5-10%, 10%- bands. can specify failure threshold levels action_levels() function. Using function generates action_levels object can passed actions argument create_agent() (thereby creating default every validation step). following, use relative values (real numbers 0 1) define thresholds WARN STOP conditions. Printing al object gives us summary settings. Let’s use action_levels object new validation. ’s similar last one parameters validation functions result failing test units. ’ll see interrogation messages show mention STOP WARNING conditions met. Printing agent provide different agent report seen previously, one ’s rife yellow red color strips left matching colors far right columns.  ’s possible invoke function particular failure condition met can set action_levels() function made part action_levels object. One example function can used included log4r_step() function logging failure conditions across validation steps. Let’s make new action_levels object include logging function WARN STOP failure conditions. Note function calls must written one-sided R formulas. Printing new al object show us failure threshold settings associated actions failure conditions. Using new al object validation workflow result failures certain validation steps logged. default, file named \"pb_log_file\" working directory log4r_step() function flexible allowing log4r appender used. Running following data validation code show us messages R console file \"pb_log_file\" can looked readLines(), showing us four entries (one validation step least WARN condition). log4r_step() function bit special provides severe condition given validation step, long function call present multiple conditions list() given action_levels()’s fns argument. ’s possible provide custom-made function generates side effect way log4r_step() used. Just like log4r_step(), custom function can take advantage x variable, x-list validation step. Let’s take look step 2 (col_vals_in_set validation step) using get_agent_x_list() function: message console shows us ’s available x, indication output types. wanted know number test units, fraction failed, whether STOP condition entered, can access even put character string (along info x-list). great way test function use validation step ‘action’ invoked undergo evaluation environment contains x (structure).","code":"al <- action_levels(warn_at = 0.1, stop_at = 0.2) al ── The `action_levels` settings ──────────────────────────────────────────── WARN failure threshold of 0.1 of all test units. STOP failure threshold of 0.2 of all test units. ────────────────────────────────────────────────────────────────────────── agent <-    create_agent(     tbl = small_table,     tbl_name = \"small_table\",     label = \"VALID-I Example No. 2\",     actions = al   ) %>%   col_is_posix(vars(date_time)) %>%   col_vals_in_set(vars(f), set = c(\"low\", \"mid\")) %>%   col_vals_lt(vars(a), value = 7) %>%   col_vals_regex(vars(b), regex = \"^[0-9]-[a-w]{3}-[2-9]{3}$\") %>%   col_vals_between(vars(d), left = 0, right = 4000) %>%   interrogate() ── Interrogation Started - there are 5 steps ────────────────────────────────── ✓ Step 1: OK. x Step 2: STOP condition met. ! Step 3: WARNING condition met. x Step 4: STOP condition met. ! Step 5: WARNING condition met.  ── Interrogation Completed ───────────────────────────────────────────────── agent al <-    action_levels(     warn_at = 0.1,     stop_at = 0.2,     fns = list(       warn = ~ log4r_step(x),       stop = ~ log4r_step(x)     )   ) al ── The `action_levels` settings ──────────────────────────────────────────── WARN failure threshold of 0.1 of all test units. \\fns\\ ~ log4r_step(x) STOP failure threshold of 0.2 of all test units. \\fns\\ ~ log4r_step(x) ────────────────────────────────────────────────────────────────────────── agent <-    create_agent(     tbl = small_table,     tbl_name = \"small_table\",     label = \"VALID-I Example No. 3\",     actions = al   ) %>%   col_is_posix(vars(date_time)) %>%   col_vals_in_set(vars(f), set = c(\"low\", \"mid\")) %>%   col_vals_lt(vars(a), value = 7) %>%   col_vals_regex(vars(b), regex = \"^[0-9]-[a-w]{3}-[2-9]{3}$\") %>%   col_vals_between(vars(d), left = 0, right = 4000) %>%   interrogate() ── Interrogation Started - there are 5 steps ────────────────────────────────── ✓ Step 1: OK. x Step 2: STOP condition met. ! Step 3: WARNING condition met. x Step 4: STOP condition met. ! Step 5: WARNING condition met.  ── Interrogation Completed ───────────────────────────────────────────────── readLines(\"pb_log_file\") [1] \"ERROR [2020-11-06 01:26:07] Step 2 exceeded the STOP failure threshold (f_failed = 0.46154) ['col_vals_in_set']\"  [2] \"WARN  [2020-11-06 01:26:07] Step 3 exceeded the WARN failure threshold (f_failed = 0.15385) ['col_vals_lt']\"      [3] \"ERROR [2020-11-06 01:26:07] Step 4 exceeded the STOP failure threshold (f_failed = 0.53846) ['col_vals_regex']\"   [4] \"WARN  [2020-11-06 01:26:07] Step 5 exceeded the WARN failure threshold (f_failed = 0.07692) ['col_vals_between']\" x <- get_agent_x_list(agent, i = 2) x ── The x-list for STEP 2 ──────────────────────────────────────────── $time_start $time_end (POSIXct [1]) $label $tbl_name $tbl_src $tbl_src_details (chr [1]) $tbl (spec_tbl_df, tbl_df, tbl, and data.frame) $col_names $col_types (chr [8]) $i $type $columns $values $label $briefs (mixed [1]) $eval_error $eval_warning (lgl [1]) $capture_stack (list [1]) $n $n_passed $n_failed $f_passed $f_failed (num [1]) $warn $stop $notify (lgl [1]) $lang (chr [1]) ───────────────────────────────────────────────────────────────── glue::glue(   \"In Step {x$i}, there were {x$n} test units and {x$f_failed * 100}% \\\\   failed. STOP condition met: {tolower(x$stop)}.\"   ) In Step 2, there were 13 test units and 46.154% failed. STOP condition met: true."},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-II.html","id":"an-example-of-this-workflow","dir":"Articles","previous_headings":"","what":"An Example of This Workflow","title":"Introduction to the **Pipeline Data Validation** Workflow (**VALID-II**)","text":"Let’s adapt example used VALID-: Data Quality Reporting Workflow article pipeline data validation workflow: terms expressions used pipeline, might notice create_agent() interrogate() functions absent. due secondary role validation functions, can operate directly immediately data, acting sort filter. validations pipeline pass (.e., failing test units validation steps), small_table data returned. Otherwise, ’s currently written, stoppage occur failure. turns , validation pipeline result error. stringent default threshold setting stops evaluation pipeline point failure (one test units failing). , turn, stops running script (key consideration script deployed automatically running sort schedule). type workflow don’t need define functions, pointblank automatically sensible thing stopping evaluation providing stock message. , first instance stoppage due validation failing, R scripts stop point R Markdown documents correspondingly cease render.","code":"small_table %>%   col_is_posix(vars(date_time)) %>%   col_vals_in_set(vars(f), set = c(\"low\", \"mid\", \"high\")) %>%   col_vals_lt(vars(a), value = 10) %>%   col_vals_regex(vars(b), regex = \"^[0-9]-[a-z]{3}-[0-9]{3}$\") %>%   col_vals_between(vars(d), left = 0, right = 5000) ## Error: Exceedance of failed test units where values in `d` should have been between `0` and `5000`. ## The `col_vals_between()` validation failed beyond the absolute threshold level (1). ## * failure level (1) >= failure threshold (1)"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-II.html","id":"modifying-the-behavior-of-validation-failures","dir":"Articles","previous_headings":"","what":"Modifying the Behavior of Validation Failures","title":"Introduction to the **Pipeline Data Validation** Workflow (**VALID-II**)","text":"ways counteract stopping behavior seen previous example. R Markdown document, set chunk option error = TRUE might expect error occur due validation failure (allowing execution continue matter happens). ’s done small_table example document, giving us error message printed input. Another way disable evaluation step level use active = FALSE option every validation function shouldn’t evaluated. works R scripts R Markdown documents quite different since can’t determine whether validation passed failed since doesn’t actually perform check (simply skips ). useful, however, want enable staged checks use data validations sort ‘debug mode’ since global variables logical can passed active argument specific validation functions. Another strategy stop() instead warn().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-II.html","id":"using-warn_on_fail-and-stop_on_fail-functions-to-generate-simple-action_levels","dir":"Articles","previous_headings":"","what":"Using warn_on_fail() and stop_on_fail() functions to generate simple action_levels","title":"Introduction to the **Pipeline Data Validation** Workflow (**VALID-II**)","text":"two helper functions convenient workflow: warn_on_fail() stop_on_fail(). functions return action_levels object either warns stops, informative warning error messages. default failure threshold set 1: one fail unit means threshold WARN FAIL condition met. stop_on_fail() helper (behind scenes) applied default using validation functions VALID-II workflow. , previous example exactly expanded form: want instead issue warnings, perhaps less stringent failure thresholds certain steps, warn_on_fail() function provides simple way express . warn_on_fail() stop_on_fail() handy ways generate action_levels objects actions argument every validation function, doesn’t provide way specify actions. , ’ll need use action_levels() function directly.","code":"small_table %>%   col_is_posix(     vars(date_time),     actions = stop_on_fail(stop_at = 1)   ) %>%   col_vals_in_set(     vars(f), set = c(\"low\", \"mid\", \"high\"),     actions = stop_on_fail(stop_at = 1)   ) %>%   col_vals_lt(     vars(a), value = 10,     actions = stop_on_fail(stop_at = 1)   ) %>%   col_vals_regex(     vars(b), regex = \"^[0-9]-[a-z]{3}-[0-9]{3}$\",     actions = stop_on_fail(stop_at = 1)   ) %>%   col_vals_between(     vars(d), left = 0, right = 5000,     actions = stop_on_fail(stop_at = 1)   ) ## Error: Exceedance of failed test units where values in `d` should have been between `0` and `5000`. ## The `col_vals_between()` validation failed beyond the absolute threshold level (1). ## * failure level (1) >= failure threshold (1) small_table %>%   col_is_posix(     vars(date_time),     actions = warn_on_fail()   ) %>%   col_vals_in_set(     vars(f), set = c(\"low\", \"mid\", \"high\"),     actions = warn_on_fail(warn_at = 0.2)   ) %>%   col_vals_lt(     vars(a), value = 10,     actions = warn_on_fail(warn_at = 3)   ) %>%   col_vals_regex(     vars(b), regex = \"^[0-9]-[a-z]{3}-[0-9]{3}$\",     actions = warn_on_fail(warn_at = 0.2)   ) %>%   col_vals_between(     vars(d), left = 0, right = 5000,     actions = warn_on_fail(warn_at = 1)   ) ## Warning: Exceedance of failed test units where values in `d` should have been between `0` and `5000`. ## The `col_vals_between()` validation failed beyond the absolute threshold level (1). ## * failure level (1) >= failure threshold (1) ## # A tibble: 13 × 8 ##    date_time           date           a b             c      d e     f     ##    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   ## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   ## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-II.html","id":"using-action_levels-for-more-control","dir":"Articles","previous_headings":"","what":"Using action_levels() for More Control","title":"Introduction to the **Pipeline Data Validation** Workflow (**VALID-II**)","text":"action_levels() function can useful VALID-workflow agent. function creates action_levels object can two roles: (1) specification threshold failure levels entering certain conditions (WARN, STOP, NOTIFY), (2) setting actions (.e., function calls invoke) entering specific condition. fns argument action_levels() allows us define custom functions evaluated upon entering three states (acts ‘step’ level, per validation function). Compared VALID-workflow, deals reporting, actions triggered failures VALID-II workflow probably useful important. can imagine situation R script deployed data validation interspersed throughout. Depending deployment, may desire hard stop (affecting downstream components), , may want softer approach warning logging. Let’s try hybrid approach three available conditions failure threshold levels set associated function invoke. functions invoke condition can whatever makes sense workflow (.e., don’t issue warnings WARN condition want something else). , use warning() WARN, stop() STOP, logging function (log4r_step()) NOTIFY. ’s might create action_levels object action_levels(): assigned action_levels object (case, al) can print get summary settings. Finally, apply object every validation function call expression (changed slightly result test units failing). addition error warning, log4r_step() function used NOTIFY condition generates, case, new \"pb_log_file\" text file logs. can examine readLines(); single entry relates Step 1 (col_vals_in_set() step): log4r_step() function offered pointblank shown examples explained detail VALID-: Data Quality Reporting Workflow article.","code":"al <-    action_levels(     warn_at = 0.1,     stop_at = 0.2,     notify_at = 0.3,     fns = list(       warn = ~ warning(\"WARN threshold exceeded.\"),       stop = ~ stop(\"STOP threshold exceeded.\"),       notify = ~ log4r_step(x)     )   ) al ── The `action_levels` settings ──────────────────────────────────────────── WARN failure threshold of 0.1 of all test units. \\fns\\ ~ warning(\"WARN threshold exceeded.\") STOP failure threshold of 0.2 of all test units. \\fns\\ ~ stop(\"STOP threshold exceeded.\") NOTIFY failure threshold of 0.3 of all test units. \\fns\\ ~ log4r_step(x) ────────────────────────────────────────────────────────────────────────── small_table %>%   col_is_posix(vars(date_time), actions = al) %>%   col_vals_in_set(vars(f), set = c(\"low\", \"mid\"), actions = al) %>%   col_vals_lt(vars(a), value = 7, actions = al) %>%   col_vals_regex(vars(b), regex = \"^[0-9]-[a-w]{3}-[2-9]{3}$\", actions = al) %>%   col_vals_between(vars(d), left = 0, right = 4000, actions = al) ## Warning in rlang::eval_tidy(.): WARN threshold exceeded. ## Error in rlang::eval_tidy(.): STOP threshold exceeded. readLines(\"pb_log_file\") FATAL [2020-11-09 00:23:48] Step 1 exceeded the NOTIFY failure threshold (f_failed = 0.46154) ['col_vals_in_set']"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-III.html","id":"using-expect_-functions-in-the-testthat-way","dir":"Articles","previous_headings":"","what":"Using expect_*() Functions in the testthat Way","title":"Introduction to the **Expectations in Unit Tests** Workflow (**VALID-III**)","text":"testthat package collection functions begin expect_. ’s coincidence pointblank VALID-III workflow adopts naming convention. idea use functions interchangeably testthat standard testthat workflow (test-<name>.R file, inside tests/testthat folder). big difference instead testing function outputs, testing data tables. However, tables may returned function calls expect_*() functions offered pointblank might offer flexibility testing data. instance expect_col_vals_between() allows us write expectation fine control boundary values (whether inclusive bounds), whether NA values ignored, can even set failure threshold makes sense expectation. ’s example generate tests data testthat also pointblank. small_table dataset, let’s write expectations show non-NA values column c 2 9. testthat function tests values two values. original strategy use testthat::expect_gte() testthat::lte() small_table$c object , however, doesn’t work results logical vector greater length 1. Also, allowance NA values skipped. best . pointblank version task makes succinct understandable expectation expression: arguments expect_col_vals_between() give us everything need check tabular data without subsetting perform transformations. added benefits. data come data source locals data frame, SQL expressions handled internally tested extensively across supported database types Spark DataFrames well.","code":"testthat::expect_true(all(na.omit(small_table$c) >= 2)) testthat::expect_true(all(na.omit(small_table$c) <= 9)) expect_col_vals_between(small_table, vars(c), 2, 9, na_pass = TRUE)"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-III.html","id":"these-expect_-functions-are-simpler-than-their-counterparts","dir":"Articles","previous_headings":"","what":"These expect_*() Functions Are Simpler Than Their Counterparts","title":"Introduction to the **Expectations in Unit Tests** Workflow (**VALID-III**)","text":"expect_*() functions leading arguments validation function counterparts omit following arguments end signatures: actions step_id label brief active lose actions argument, get place threshold argument. simple failure threshold value use expectation (expect_*) test (test_*) functions. default, threshold set 1 means single test unit failing result overall failure (.e., expectation fail). thresholds set action_levels() functions (shortcut functions warn_on_fail() stop_on_fail()), whole numbers beyond 1 indicate failing units absolute threshold value result succeeding expectation. Likewise, fractional values (0 1) act proportional failure threshold, 0.25 means 25% failing test units results failed expectation. preconditions argument can used transform input data evaluation expectation. useful cases might need summarize input data table, mutate columns, perform filtering, even perform table joins beforehand.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-IV.html","id":"exactly-like-the-expect_-functions-except-you-get-a-true-or-false","dir":"Articles","previous_headings":"","what":"Exactly Like the expect_*() Functions Except You Get a TRUE or FALSE","title":"Introduction to the **Data Tests for Conditionals** Workflow (**VALID-IV**)","text":"interface test_*() function exact match expect_*() counterpart. haven’t used either used standard validation functions, ’s quick rundown. following arguments validation functions (e.g., col_vals_in_set() many ) removed corresponding test_*() functions: actions step_id label brief active Instead actions get threshold argument simplified replacement. ’s supplied single failure threshold value. default set 1 meaning single test fails result overall failure return FALSE (otherwise, TRUE). rules threshold setting (action_levels(), warn_on_fail(), stop_on_fail()) explained detail . Whole numbers beyond 1 indicate failing units absolute threshold value result TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.25 means 25% failing test units results FALSE. can use preconditions argument cases ’d like transform input data evaluation test. like things input table like summarize , perform filtering, mutate one columns, perform table joins, etc., good way go .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-IV.html","id":"heres-several-examples-quick-snap","dir":"Articles","previous_headings":"","what":"Here’s Several Examples Quick Snap","title":"Introduction to the **Data Tests for Conditionals** Workflow (**VALID-IV**)","text":"Let’s examples leaving article. use small_table: ’d like test pointblank validation skill, guess whether TRUE FALSE hovering line code. . nice set examples revealing truthy/falsy nature ::closer inspection.","code":"small_table ## # A tibble: 13 × 8 ##    date_time           date           a b             c      d e     f     ##    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   ## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   ## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-V.html","id":"an-example-with-the-palmer-penguins-dataset","dir":"Articles","previous_headings":"","what":"An Example with the Palmer Penguins Dataset","title":"Introduction to the **Table Scan** Workflow (**VALID-V**)","text":"output HTML report appear RStudio Viewer can also integrated R Markdown HTML output. ’s example uses penguins_raw dataset palmerpenguins package. scan_data() call, option deactivate display navigation bar taken navbar = FALSE, makes sense integrating type output larger document. seen, first two sections lot additional information tucked behind detail views (Toggle details buttons) within tab sets. amount information little overwhelming, option disable one sections. scan_data()’s sections argument, can specify just sections needed specific scan. default value sections string \"OVICMS\" letter stands following sections default order: \"O\": \"overview\" \"V\": \"variables\" \"\": \"interactions\" \"C\": \"correlations\" \"M\": \"missing\" \"S\": \"sample\". string can contain less key characters order can changed suit desired layout report. example, just need Overview, Sample, description Variables target table, string use sections \"OSV\". Just workflows, tbl supplied data frame, tibble, tbl_dbi object, tbl_spark object. However, one limitation scan_data(): tbl_dbi tbl_spark objects, Interactions Correlations sections currently excluded.","code":"scan_data(palmerpenguins::penguins_raw, navbar = FALSE)"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-V.html","id":"languages-and-locales","dir":"Articles","previous_headings":"","what":"Languages and Locales","title":"Introduction to the **Table Scan** Workflow (**VALID-V**)","text":"reporting generated scan_data() can presented one eight spoken languages: English (\"en\", default), French (\"fr\"), German (\"de\"), Italian (\"\"), Spanish (\"es\"), Portuguese, (\"pt\"), Chinese (\"zh\"), Russian (\"ru\"). two-letter language codes can used argument lang argument. applied, label text non-data elements set language choice. checked translations native speakers respective languages find error corrected, please file issue. Along translations, numerical values generated part reporting (e.g., table dimensions, summary statistics, etc.) automatically formatted locale language (given lang). can overridden locale argument accepts locale ID. Examples include \"en_US\" English (United States) \"fr_FR\" French (France). simply, can language identifier without country designation, like \"es\" Spanish (Spain, \"es_ES\"). 700 locales currently accepted.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-VI.html","id":"how-it-works","dir":"Articles","previous_headings":"","what":"How It Works","title":"Introduction to the **R Markdown Document Validation** Workflow (**VALID-VI**)","text":"Using pointblank VALID-VI workflow enabled default pointblank library loaded (best done setup chunk). framework allows validation testing within specialized validation code chunks validate = TRUE option set. Using pointblank validation functions data (VALID-II workflow) marked code chunks flag overall failure stop threshold exceeded anywhere. errors shown rendering document HTML. Green status buttons indicate validations succeeded, red buttons indicate one validation failures occurred. Clicking button reveals otherwise hidden validation statements associated messaging. ’s much better demonstrate workflow works series examples, resulting output interactive varies quite bit depending input. following examples, code chunk shown rendered result subsequently placed. result typically button can pressed reveal validation result code chunk hidden upon rendering (’s need use include = FALSE chunk option). start things , ’s example uses expression takes small_table dataset pipes two validation functions: col_is_date() col_vals_in_set(). col_is_date() validation passes whereas col_vals_in_set() validation fails (set values column f also \"high\" value.  Clicking 1 validation failed. button reveal expression failed validation validation function failing within . break , really one validation step chain passed (first one) one failed (second). additional validation steps otherwise pass, ’d still get result output failing step ends execution. workflow meant stop expression executing first validation function fails, ’s advisable break validations single steps. way, expression single validation either passes fails reported accordingly. Let’s rewrite example two expressions, one per validation.  still says 1 validation failed. (workflow focuses negatives) pressing button reveals first one passed second failed. much clearer don’t run risk evaluating validations validation failed earlier pipeline. ’s example validations individual expressions pass, showing us green status button.  ’s worth reminding point failed validations stop execution R Markdown rendering. Otherwise wouldn’t see document failing validations, , wouldn’t know failed validations occurred. expectation workflow add relevant validation expressions key junctures failures occur, one can fix underlying issues (enough) validations pass.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-VI.html","id":"the-pointblank-stop_if_not-function","dir":"Articles","previous_headings":"","what":"The pointblank stop_if_not() Function","title":"Introduction to the **R Markdown Document Validation** Workflow (**VALID-VI**)","text":"may want use set validation functions everything. Perhaps using stopifnot() sufficient validations. case, consider using pointblank variation : stop_if_not(). works well enough standalone, replacement stopifnot() advantage stop_if_not() customized use VALID-VI workflow (situation ’re using R Markdown render HTML, pointblank loaded via library()). Ultimately, using stop_if_not() code chunk validate = TRUE option set yield correct reporting successes failures whereas stopifnot() . ’s code chunk uses stop_if_not() twice check two different assertions small_table object. first one passes whereas second one fails.  Keep mind stop_if_not() (like stopifnot()) can used type assertion. ’s limited checking tables like functions pointblank focused .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-VI.html","id":"including-data-quality-reporting-from-the-valid-i-workflow","dir":"Articles","previous_headings":"","what":"Including Data Quality Reporting from the VALID-I Workflow","title":"Introduction to the **R Markdown Document Validation** Workflow (**VALID-VI**)","text":"Code chunks can include data quality reporting expressions (.e., agent-based VALID-workflow) ’s important ensure two things. ’s interesting thing : can opt use validate = TRUE chunk option omit entirely, choice different effect. ’d like hide validation output (Agent Report) behind button (case, light blue one) validate = TRUE used. ’s example data quality validation workflow executed single code chunk.  code chunk exclude validate = TRUE option, output appear output normally (input appears output report table). just want output reporting table shown without input expressions, use include = FALSE chunk option . final note , ’s important use expressions result output, just stick typical create_agent() → <validation functions> → interrogate() pattern. words, dedicate code chunk just agent put validation expressions elsewhere document.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-VI.html","id":"setting-up-options-with-the-validate_rmd-function","dir":"Articles","previous_headings":"","what":"Setting Up Options with the validate_rmd() Function","title":"Introduction to the **R Markdown Document Validation** Workflow (**VALID-VI**)","text":"can modify pointblank validation testing options within R Markdown documents validate_rmd() function. framework testing set default, using validate_rmd() offers opportunity set UI logging options. summary argument, TRUE (default), leading summary validations rendered R Markdown document. FALSE, element shown. document, validate_rmd(summary = FALSE) placed setup chunk (right library(pointblank) statement) resulted suppressing display overall summary validation results. log_to_file argument, ’s option log errors text file. default, logging done setting log_to_file == TRUE write log entries \"validation_errors.log\" file working directory (generated non-existent, appended available). enable logging specify name file, include path log file (desired name) log_to_file.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Richard Iannone. Author, maintainer. Mauricio Vargas. Author.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Iannone R, Vargas M (2021). pointblank: Data Validation Organization Metadata Local Remote Tables. https://rich-iannone.github.io/pointblank/, https://github.com/rich-iannone/pointblank.","code":"@Manual{,   title = {pointblank: Data Validation and Organization of Metadata for Local and Remote Tables},   author = {Richard Iannone and Mauricio Vargas},   year = {2021},   note = {https://rich-iannone.github.io/pointblank/, https://github.com/rich-iannone/pointblank}, }"},{"path":"https://rich-iannone.github.io/pointblank/es/index.html","id":null,"dir":"","previous_headings":"","what":"Data Validation and Organization of Metadata for Local and Remote Tables","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"pointblank package ’s really easy methodically validate data whether form data frames database tables. top validation toolset, package gives means provide keep --date information defines tables. table validation, agent object works large collection simple (yet powerful!) validation functions. can enable much sophisticated validation checks using custom expressions also stepwise mutation target table (something call preconditions). Sometimes want maintain table information update table goes changes. , can use informant object + associated functions help define metadata entries present way suits .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"Want try ? pointblank package available CRAN: can also install development version pointblank GitHub: encounter bug, usage questions, want share ideas make package better, feel free file issue.","code":"install.packages(\"pointblank\") devtools::install_github(\"rich-iannone/pointblank\")"},{"path":"https://rich-iannone.github.io/pointblank/es/index.html","id":"lets-discuss","dir":"","previous_headings":"","what":"Let’s Discuss!","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"Let’s talk data validation data documentation pointblank Discussions! ’s great place ask questions use package, discuss ideas, engage others, much !","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/index.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"Please note pointblank project released contributor code conduct. participating project agree abide terms.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/index.html","id":"-license","dir":"","previous_headings":"","what":"📄 License","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"pointblank licensed MIT license. See LICENSE.md file details.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/index.html","id":"️-governance","dir":"","previous_headings":"","what":"🏛️ Governance","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"project primarily maintained Rich Iannone. authors may occasionally assist duties.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/action_levels.html","id":null,"dir":"Reference","previous_headings":"","what":"Establecer niveles de acción: umbrales de falla y funciones para invocar — action_levels","title":"Establecer niveles de acción: umbrales de falla y funciones para invocar — action_levels","text":"La función action_levels() trabaja con el argumento actions que está presente en la función create_agent() y en cada función de paso de validación (que también tiene un argumento actions). Con él, podemos proporcionar niveles de umbral falla para cualquier combinación de estados de warn, stop o notify. Podemos reaccionar ante cualquier entrada de un estado proporcionando las funciones correspondientes al argumento fns. Se someterán evaluación en el momento en que se ingrese al estado de coincidencia. Si se proporciona create_agent(), las políticas se aplicarán cada paso de validación, actuando de forma predeterminada para la validación en su conjunto. Las llamadas de action_levels() también podrían aplicarse directamente cualquier paso de validación y esto actuará como una anulación si se establece también en create_agent(). Se requiere el uso de action_levels() para tener efectos secundarios útiles (es decir, advertencias, errores de lanzamiento) en el caso de funciones de validación que operan directamente sobre los datos (p. Ej., mtcars %>% col_vals_lt(\"mpg\", 35)). Hay dos funciones auxiliares que son convenientes cuando se usan funciones de validación directamente en datos (el flujo de trabajo sin agent): warn_on_fail() y stop_on_fail(). Estos ayudantes advierten o se detienen (el umbral de falla predeterminado para cada uno se establece en 1) y lo hacen con advertencias informativas o mensajes de error. El ayudante stop_on_fail() se aplica de forma predeterminada cuando se utilizan funciones de validación directamente en los datos (se proporciona más información sobre esto en Detalles).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/action_levels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Establecer niveles de acción: umbrales de falla y funciones para invocar — action_levels","text":"","code":"action_levels(warn_at = NULL, stop_at = NULL, notify_at = NULL, fns = NULL)  warn_on_fail(warn_at = 1)  stop_on_fail(stop_at = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/action_levels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Establecer niveles de acción: umbrales de falla y funciones para invocar — action_levels","text":"warn_at, stop_at, notify_at El número de umbral o fracción de unidades de prueba que pueden proporcionar una fallar resultado antes de entrar en las warn, stop o notify estados de fallo. Si este es un valor decimal entre 0 y 1 entonces es un umbral de falla proporcional (por ejemplo, 0.15 indica que si se encuentra que el 15% por ciento de las unidades de prueba fallan, entonces se ingresa el estado de falla designado). En 1 su lugar, se pueden usar valores absolutos partir de, y esto constituye un umbral de falla absoluto (por ejemplo, 10 significa que si se encuentra que 10 de las unidades de prueba fallan , se ingresa el estado de falla). fns Una lista nombrada de funciones que se emparejará con los estados de falla apropiados. La sintaxis para esta lista implica el uso de nombres de estado fracaso desde el conjunto de warn, stop y notify. Las funciones correspondientes los estados de falla se proporcionan como fórmulas (por ejemplo list(warn = ~ warning(\"many failures.\"))). Se puede usar una serie de expresiones para cada estado nombrado encerrando el conjunto de declaraciones con { }.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/action_levels.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Establecer niveles de acción: umbrales de falla y funciones para invocar — action_levels","text":"El resultado de la action_levels() llamada actionsse interpretará de forma ligeramente diferente si se usa un agente o se usan funciones de validación directamente en una tabla de datos. Por conveniencia, cuando se trabaja directamente con datos, cualquier valor suministrado warn_at o stop_at se le asignará automáticamente un stock warning() o stop() función. Por ejemplo, el uso small_table %>% col_is_integer(\"date\") proporcionará un mensaje de detención detallado de forma predeterminada, que indica el motivo del error. Si tuviera que suministrar el fns stop o warn manualmente, las funciones de stock se anularían. Además, si actionses NULL en este flujo de trabajo (el predeterminado), pointblank usará un stop_at valor de 1 (que proporciona un mensaje de error detallado y específico del contexto si hay unidades que fallan). Podemos suprimir absolutamente este comportamiento de parada automática en cada paso de validación mediante la configuración active = FALSE. En este caso de datos interactivos, se proporciona una función de stock para notify_at. El notifyestado de falla se usa con menos frecuencia en este flujo de trabajo que en el basado en agente . Cuando se utiliza un agente , menudo opta por utilizar ninguna función en la fns que el warn, stop y notify serán reportados en los estados de insuficiencia cuando se usa create_agent_report() (y, por lo general eso es suficiente). En cambio, usar el end_fns argumento es una mejor opción, ya que ese esquema proporciona datos útiles sobre todo el interrogatorio, lo que permite un control más preciso de los efectos secundarios y reduce la posibilidad de duplicar los efectos secundarios.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/action_levels.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Establecer niveles de acción: umbrales de falla y funciones para invocar — action_levels","text":"1-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/action_levels.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Establecer niveles de acción: umbrales de falla y funciones para invocar — action_levels","text":"","code":"# Para estos ejemplos, usaremos el conjunto # de datos `small_table` incluido small_table #> # A tibble: 13 × 8 #>    date_time           date           a b             c      d e     f     #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high   # Crea un objeto `action_levels` con valores # fraccionarios para el `warn_at`, # `stop_at` y `notify_at` estados al <-    action_levels(     warn_at = 0.2,     stop_at = 0.8,     notify_at = 0.5   )    # Un resumen de la configuración de `al` # El objeto se muestra imprimiéndolo al #> ── The `action_levels` settings ──────────────────────────────────────────────── #> WARN failure threshold of 0.2 of all test units. #> STOP failure threshold of 0.8 of all test units. #> NOTIFY failure threshold of 0.5 of all test units. #> ────────────────────────────────────────────────────────────────────────────────  # Cree un agente a quemarropa y # aplicar el objeto `al` a las `actions`; # agregue dos pasos de validación y # interrogar a la `small_table` agent_1 <-   create_agent(     tbl = small_table,     actions = al   ) %>%   col_vals_gt(     vars(a), value = 2   ) %>%   col_vals_lt(     vars(d), value = 20000   ) %>%   interrogate()  # El informe del agente mostrará # que se ha entrado en el estado de advertencia # para el primer paso de validación pero no # el segundo; podemos confirmar esto # en la consola inspeccionando el # Componente `warn` en la x-list del agente x_list <- get_agent_x_list(agent_1) x_list$warn #> [1]  TRUE FALSE  # Aplicar el objeto `action_levels` # para el agente significa que toda # validación los pasos heredarán esta # configuración, pero podemos anular # esto aplicando otro objeto similar a # la validación paso en su lugar (esta # vez usando el `warn_on_fail()` # abreviatura) agent_2 <-   create_agent(     tbl = small_table,     actions = al   ) %>%   col_vals_gt(     vars(a), value = 2,     actions = warn_on_fail(warn_at = 0.5)   ) %>%   col_vals_lt(     vars(d), value = 20000   ) %>%   interrogate()  # En este caso, la primera validación # el paso tiene una falla menos estricta # umbral para el estado de advertencia y es # lo suficientemente alto como para que la # condición no sea ingresó; esto se puede # confirmar en el consola a través de la # inspección de la componente x-list `warn` x_list <- get_agent_x_list(agent_2) x_list$warn #> [1] FALSE FALSE  if (interactive()) {  # En el contexto del uso de la validación # funciona directamente en los datos (es # decir, no participación de un agente) # queremos desencadenar advertencias y # generar errores; los siguiente dará una # advertencia si se ejecuta (devolviendo el # datos de `small_table`) small_table %>%   col_vals_gt(     vars(a), value = 2,     actions = warn_on_fail(warn_at = 2)   )  # Con el mismo oleoducto, no suministrando # cualquier cosa para `actions` (es` NULL` # por predeterminado) tendrá el mismo # efecto que usando `stop_on_fail (stop_at = 1)` small_table %>%   col_vals_gt(vars(a), value = 2)  small_table %>%   col_vals_gt(     vars(a), value = 2,     actions = stop_on_fail(stop_at = 1)   )  # Esto se debe a que el `stop_on_fail()` # la llamada se inyecta automáticamente # de forma predeterminada caso (cuando # se opera con datos) para su conveniencia; # detrás de escena un agente secreto' utiliza # 'acciones encubiertas': todo para que # puedas escribir menos  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/activate_steps.html","id":null,"dir":"Reference","previous_headings":"","what":"Activar uno o más de los pasos de validación de un agent — activate_steps","title":"Activar uno o más de los pasos de validación de un agent — activate_steps","text":"Si es necesario activar ciertos pasos de validación después de la creación del plan de validación para un agent, use la función active_steps(). Este es equivalente usar active = TRUE para los pasos de validación seleccionados (active es un argumento en todas las funciones de validación). Esto reemplazará cualquier función que puede haber sido definida para el argumento active durante la creación de los pasos de validación específicos.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/activate_steps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Activar uno o más de los pasos de validación de un agent — activate_steps","text":"","code":"activate_steps(agent, i = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/activate_steps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Activar uno o más de los pasos de validación de un agent — activate_steps","text":"agent Un objeto de agente de clase ptblank_agent. El número de paso de validación, que se asigna cada paso de validación en el orden de definición.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/activate_steps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Activar uno o más de los pasos de validación de un agent — activate_steps","text":"Un objeto ptblank_agent.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/activate_steps.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Activar uno o más de los pasos de validación de un agent — activate_steps","text":"9-6","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/activate_steps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Activar uno o más de los pasos de validación de un agent — activate_steps","text":"","code":"# Cree un agente que tenga objeto # `small_table` como el tabla de  # destino, agregue algunos inactivos # pasos de validación, y luego use # `interrogar()` agent_1 <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\"   ) %>%   col_exists(     vars(date),     active = FALSE   ) %>%   col_vals_regex(     vars(b), regex = \"[0-9]-[a-z]{3}-[0-9]{3}\",     active = FALSE   ) %>%   interrogate() #> ℹ Step 1 is not set as active. Skipping. #> ℹ Step 2 is not set as active. Skipping.  # En lo anterior, los datos son no # realmente interrogado porque el # ajuste `active` fue `FALSE` en # todos los pasos; nosotros puede # cambiar esto de forma selectiva # con `active_steps()` agent_2 <-   agent_1 %>%   activate_steps(i = 1) %>%   interrogate() #> ℹ Step 2 is not set as active. Skipping."},{"path":"https://rich-iannone.github.io/pointblank/es/reference/affix_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Ponga la fecha actual en un nombre de archivo — affix_date","title":"Ponga la fecha actual en un nombre de archivo — affix_date","text":"Esta función ayuda fijar la fecha actual un nombre de archivo. Esto es útil al escribir objetos agent y informante en el disco como parte de un proceso continuo. La fecha puede ser en términos de hora UTC o del sistema local. tiempo. La fecha se puede colocar al final del nombre del archivo (antes del extensión de archivo) o al principio con un delimitador personalizable. Las funciones x_write_disk(), yaml_write() permiten la escritura de objetos pointblank al disco. Además, la función log4r_step() tiene el argumento append_to que acepta nombres de archivo, y es razonable que un La serie de archivos de registro se puede diferenciar por un componente de fecha en el nombre esquema. La modificación de la cadena del nombre del archivo tiene efecto inmediatamente, pero en el momento de escribir un archivo en el disco. En la mayoría de los casos, especialmente cuando usando affix_date() con las funciones de escritura de archivos antes mencionadas, el archivo las marcas de tiempo deben aproximarse los componentes de tiempo fijados los nombres de archivo.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/affix_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ponga la fecha actual en un nombre de archivo — affix_date","text":"","code":"affix_date(   filename,   position = c(\"end\", \"start\"),   format = \"%Y-%m-%d\",   delimiter = \"_\",   utc_time = TRUE )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/affix_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ponga la fecha actual en un nombre de archivo — affix_date","text":"filename El nombre de archivo que se va modificar. position Dónde colocar la fecha formateada. Esto podría estar al \"end\" del nombre del archivo (el predeterminado) o al \"start\". format Una cadena de formato base::strptime() para formatear la fecha. Por predeterminado, esto es \"%Y-%m-%d\" que expresa la fecha de acuerdo con la ISO 8601 estándar (como 'AAAA-MM-DD'). Consulte la documentación en base::strptime() para las especificaciones de conversión si planea usar un cadena de formato diferente. delimiter Los caracteres delimitadores que se utilizarán para separar la fecha. cadena del nombre del archivo original. utc_time Una opción para utilizar la hora UTC actual para establecer la fecha (la predeterminada, con TRUE), o, utilizar el local del sistema tiempo (FALSE).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/affix_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ponga la fecha actual en un nombre de archivo — affix_date","text":"Un vector de caracteres.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/affix_date.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Ponga la fecha actual en un nombre de archivo — affix_date","text":"13-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/affix_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ponga la fecha actual en un nombre de archivo — affix_date","text":"","code":"# Tomando el nombre genérico de `pb_file` # para un archivo, le agregamos la fecha # actual como sufijo affix_date(filename = \"pb_file\") #> [1] \"pb_file_2021-12-15\"  # Las extensiones de archivo no se # interpondrán en el camino: affix_date(filename = \"pb_file.rds\") #> [1] \"pb_file_2021-12-15.rds\"  # La fecha se puede utilizar como prefijo affix_date(   filename = \"pb_file\",   position = \"start\" ) #> [1] \"2021-12-15_pb_file\"  # El patrón de fecha se puede cambiar # y así puede el delimitador affix_date(   filename = \"pb_file.yml\",   format = \"%Y%m%d\",   delimiter = \"-\" ) #> [1] \"pb_file-20211215.yml\"  if (interactive()) {  # Podemos usar una convención de # nomenclatura de archivos que # involucran fechas al escribir la # salida archivos inmediatamente # después de interrogar; útil al # interrogar directamente de YAML # en un proceso programado yaml_agent_interrogate(   filename = system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   ) ) %>%    x_write_disk(     filename = affix_date(       filename = \"small_table_agent.rds\",       delimiter = \"-\"     ),     keep_tbl = TRUE,     keep_extracts = TRUE   )  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/affix_datetime.html","id":null,"dir":"Reference","previous_headings":"","what":"Ponga la fecha y hora actual en un nombre de archivo — affix_datetime","title":"Ponga la fecha y hora actual en un nombre de archivo — affix_datetime","text":"Esta función ayuda fijar la fecha y hora actual un nombre de archivo. Este es útil al escribir objetos agent y informant en el disco como parte de un proceso continuo. La cadena de fecha y hora puede basarse en la hora UTC actual. o la hora del sistema local. La fecha y hora se puede colocar al final de el nombre del archivo (antes de la extensión del archivo) o al principio con un delimitador personalizable. Opcionalmente, la información de la zona horaria puede ser incluido. Si la fecha y hora se basa en la hora del sistema local, el sistema del usuario La zona horaria se muestra con el formato <time>(+/-)hhmm. Si usa la hora UTC, entonces se adopta el formato <time>Z. Las funciones x_write_disk(), yaml_write() permiten la escritura de objetos pointblank al disco. La modificación de la cadena de nombre de archivo toma efecto inmediatamente, pero en el momento de escribir un archivo en el disco. En la mayoría casos, especialmente cuando se usa affix_datetime() con el mencionado funciones de escritura de archivos, las marcas de tiempo del archivo deben aproximarse al tiempo componentes adheridos los nombres de archivo.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/affix_datetime.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ponga la fecha y hora actual en un nombre de archivo — affix_datetime","text":"","code":"affix_datetime(   filename,   position = c(\"end\", \"start\"),   format = \"%Y-%m-%d_%H-%M-%S\",   delimiter = \"_\",   utc_time = TRUE,   add_tz = FALSE )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/affix_datetime.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ponga la fecha y hora actual en un nombre de archivo — affix_datetime","text":"filename El nombre de archivo que se va modificar. position Dónde colocar la fecha y hora formateada. Esto podría ser al \"end\" del nombre del archivo (predeterminado) o al \"start\". format Una cadena de formato base::strptime() para formatear el fecha y hora. De forma predeterminada, es \"%Y-%m-%dT%H:%M:%S\" que expresa la fecha según la norma ISO 8601. Por ejemplo, si la corriente fecha-hora es 2020-12-04 13:11:23, la cadena formateada se convertiría en \"2020-12-04T13:11:23\". Consulte la documentación en base::strptime() para las especificaciones de conversión si planea utilizar una cadena de formato diferente. delimiter Los caracteres delimitadores que se utilizarán para separar la cadena de fecha y hora del nombre del archivo original. utc_time Una opción para usar la hora UTC actual para establecer la fecha y hora (la predeterminada, con TRUE), o usar la hora local del sistema (FALSE). add_tz ¿Debería proporcionarse la zona horaria (como un desfase de UTC)? Si es TRUE, la compensación UTC se proporcionará como <time>Z (si utc_time = TRUE) o <time>(+/-)hhmm. De forma predeterminada, es FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/affix_datetime.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ponga la fecha y hora actual en un nombre de archivo — affix_datetime","text":"Un vector de caracteres.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/affix_datetime.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Ponga la fecha y hora actual en un nombre de archivo — affix_datetime","text":"13-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/affix_datetime.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ponga la fecha y hora actual en un nombre de archivo — affix_datetime","text":"","code":"# Tomando el nombre genérico de `pb_file` # para un archivo, le agregamos la fecha y # hora actual como sufijo affix_datetime(filename = \"pb_file\") #> [1] \"pb_file_2021-12-15_04-07-22\"  # Las extensiones de archivo no se # interpondrán en el camino: affix_datetime(filename = \"pb_file.rds\") #> [1] \"pb_file_2021-12-15_04-07-22.rds\"  # La fecha y hora se puede utilizar # como prefijo affix_datetime(   filename = \"pb_file\",   position = \"start\" ) #> [1] \"2021-12-15_04-07-22_pb_file\"  # El patrón de fecha y hora se puede # cambiar y así puede el delimitador affix_datetime(   filename = \"pb_file.yml\",   format = \"%Y%m%d_%H%M%S\",   delimiter = \"-\" ) #> [1] \"pb_file-20211215_040722.yml\"  # Se puede incluir información sobre # la zona horaria affix_datetime(   filename = \"pb_file.yml\",   add_tz = TRUE ) #> [1] \"pb_file_2021-12-15_04-07-22Z.yml\"  if (interactive()) {  # Podemos usar una convención de # nomenclatura de archivos que # involucran fechas y horas al # escribir la salida archivos # inmediatamente después de interrogar; # útil al interrogar directamente # de YAML en un proceso programado yaml_agent_interrogate(   filename = system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   ) ) %>%    x_write_disk(     filename = affix_datetime(       filename = \"small_table_agent.rds\",       delimiter = \"-\"     ),     keep_tbl = TRUE,     keep_extracts = TRUE   )  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/all_passed.html","id":null,"dir":"Reference","previous_headings":"","what":"Did all of the validations fully pass? — all_passed","title":"Did all of the validations fully pass? — all_passed","text":"Given agent's validation plan undergone interrogation via interrogate(), every single validation step result zero failing test units? Using all_passed() function let us know whether TRUE .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/all_passed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Did all of the validations fully pass? — all_passed","text":"","code":"all_passed(agent, i = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/all_passed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Did all of the validations fully pass? — all_passed","text":"agent agent object class ptblank_agent. vector validation step numbers. values assigned validation step pointblank order definition. NULL (default), validation steps used evaluation complete passing.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/all_passed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Did all of the validations fully pass? — all_passed","text":"logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/all_passed.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Did all of the validations fully pass? — all_passed","text":"all_passed() function provides single logical value based interrogation performed agent-based workflow. large-scale validation (data quality known issue, perhaps something tamed time) function likely less useful since quite stringent (test units must pass across validation steps). requirement logical values produced validation, flexible alternative using test (test_*()) variants validation functions. produce single logical value threshold option failure levels. Another option utilize post-interrogation objects within agent's x-list (obtained using get_agent_x_list() function). allows many possibilities producing single logical value interrogation.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/all_passed.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Did all of the validations fully pass? — all_passed","text":"8-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/all_passed.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Did all of the validations fully pass? — all_passed","text":"","code":"# Create a simple table with # a column of numerical values tbl <-    dplyr::tibble(a = c(4, 5, 7, 8))  # Validate that values in column # `a` are always greater than 4 agent <-   create_agent(tbl = tbl) %>%   col_vals_gt(vars(a), value = 3) %>%   col_vals_lte(vars(a), value = 10) %>%   col_vals_increasing(vars(a)) %>%   interrogate()  # Determine if these column # validations have all passed by # using `all_passed()` (they do) all_passed(agent = agent) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_exists.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Existe realmente una o más columnas? — col_exists","title":"¿Existe realmente una o más columnas? — col_exists","text":"La función de validación col_exists(), la expectativa expect_col_exists() función, y la función de prueba test_col_exists() comprueban si uno o existen más columnas en la tabla de destino. El único requisito es la especificación de los nombres de las columnas. La función de validación se puede utilizar directamente en un dato. tabla o con un objeto * agent * (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con datos mesa. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará en una sola unidad de prueba, que es si la columna existe o .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_exists.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Existe realmente una o más columnas? — col_exists","text":"","code":"col_exists(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_exists(object, columns, threshold = 1)  test_col_exists(object, columns, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_exists.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Existe realmente una o más columnas? — col_exists","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns Una o más columnas de la tabla en foco. Esto se puede proporcionar como un vector de nombres de columnas usando c() o nombres de columnas desnudos encerrados entre vars(). actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_exists.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Existe realmente una o más columnas? — col_exists","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_exists.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¿Existe realmente una o más columnas? — col_exists","text":"Si proporciona varios nombres de columna, el resultado será una expansión de pasos de validación para ese número de nombres de columna (por ejemplo, vars(col_a, col_b) dará lugar la entrada de dos pasos de validación). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares están disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_exists.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Existe realmente una o más columnas? — col_exists","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que se produce mejor con la función action_levels(). Lee esa función documentación para la verdad sobre cómo crear reacciones por encima del umbral niveles de falla en la validación. La esencia básica es que querrás al menos un nivel de umbral único (especificado como la fracción de unidades de prueba falló, o un valor absoluto), menudo usando el argumento warn_at. Utilizando action_levels(warn_at = 1) o action_levels(stop_at = 1) son buenas opciones dependiendo de la situación (el primero produce una advertencia, el otro stop()).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_exists.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Existe realmente una o más columnas? — col_exists","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_exists.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Existe realmente una o más columnas? — col_exists","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_exists() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_exists() como paso de validación se expresa en código R y en la representación YAML correspondiente. En la práctica, ambos serán menudo más cortos, ya que solo el argumento de las columns requiere un valor. Los argumentos con valores predeterminados se escribirán en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). También es posible obtener una vista previa de la transformación de un agente YAML sin escribir en el disco usando la función yaml_agent_string().","code":"# Código R agent %>%    col_exists(     vars(a),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_exists()`.\",     active = FALSE   )  # Representación YAML steps: - col_exists:     columns: vars(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_exists()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_exists.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Existe realmente una o más columnas? — col_exists","text":"2-29","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_exists.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Existe realmente una o más columnas? — col_exists","text":"","code":"# Para todos los ejemplos aquí, # usaremos una tabla simple con # dos columnas: `a` y` b` tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5, 8, 7),     b = c(7, 1, 0, 0, 0, 3)   )  # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Valide que las columnas `a` y` b` # existan en la tabla `tbl`; esto hace # dos pasos de validación distintos ya # que se proporcionaron dos columnas # a `vars()` agent <-   create_agent(tbl) %>%   col_exists(vars(a, b)) %>%   interrogate()  # Determine si esta validación no tuvo # unidades de prueba defectuosas (1) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` tbl %>% col_exists(vars(a, b)) #> # A tibble: 6 × 2 #>       a     b #>   <dbl> <dbl> #> 1     5     7 #> 2     7     1 #> 3     6     0 #> 4     5     0 #> 5     8     0 #> 6     7     3  # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_exists(tbl, vars(a)) expect_col_exists(tbl, vars(b))  # D: Usando la función de prueba  # Con el formulario `test_*()`, # deberíamos obtener un único valor # lógico que se nos devuelva (incluso # si hay varias columnas probadas, # como es el caso a continuación) tbl %>% test_col_exists(vars(a, b)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_character.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Las columnas contienen datos de caracteres / cadenas? — col_is_character","title":"¿Las columnas contienen datos de caracteres / cadenas? — col_is_character","text":"La función de validación col_is_character(), la función de expectativa expect_col_is_character() y la función de prueba test_col_is_character() comprueban si una o más columnas de una tabla son del tipo carácter. Como muchas de las funciones de tipo col_is_*() en pointblank, el único requisito es una especificación de los nombres de las columnas. La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre una sola unidad de prueba, que es si la columna es una columna de tipo carácter o .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_character.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Las columnas contienen datos de caracteres / cadenas? — col_is_character","text":"","code":"col_is_character(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_character(object, columns, threshold = 1)  test_col_is_character(object, columns, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_character.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Las columnas contienen datos de caracteres / cadenas? — col_is_character","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_character.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Las columnas contienen datos de caracteres / cadenas? — col_is_character","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_character.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¿Las columnas contienen datos de caracteres / cadenas? — col_is_character","text":"Si proporciona varios nombres de columna, el resultado será una expansión de pasos de validación para ese número de nombres de columna (por ejemplo, vars(col_a, col_b) dará lugar la entrada de dos pasos de validación). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares están disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_character.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Las columnas contienen datos de caracteres / cadenas? — col_is_character","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_is_*(), usar action_levels(warn_at = 1) o action_levels(stop_at = 1) son buenas opciones dependiendo de la situación (la primera produce una advertencia, la otra stop()).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_character.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Las columnas contienen datos de caracteres / cadenas? — col_is_character","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_character.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Las columnas contienen datos de caracteres / cadenas? — col_is_character","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_is_character() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_is_character() como paso de validación se expresa en código R y en la representación YAML correspondiente. En la práctica, ambos serán menudo más cortos, ya que solo el argumento de las columns requiere un valor. Los argumentos con valores predeterminados se escribirán en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). También es posible obtener una vista previa de la transformación de un agente YAML sin escribir en el disco usando la función yaml_agent_string().","code":"# Código R agent %>%    col_is_character(     vars(a),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_is_character()`.\",     active = FALSE   )  # Representación YAML steps: - col_is_character:     columns: vars(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_is_character()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_character.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Las columnas contienen datos de caracteres / cadenas? — col_is_character","text":"2-22","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_character.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Las columnas contienen datos de caracteres / cadenas? — col_is_character","text":"","code":"# Para todos los ejemplos aquí, # usaremos una tabla simple con una # columna numérica (`a`) y una # columna de caracteres (`b`) tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5, 8, 7),     b = LETTERS[1:6]   )    # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Validar que la columna `b` tenga la # clase `character` agent <-   create_agent(tbl) %>%   col_is_character(vars(b)) %>%   interrogate()  # Determine si esta validación no tuvo # unidades de prueba defectuosas (1) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` tbl %>% col_is_character(vars(b)) #> # A tibble: 6 × 2 #>       a b     #>   <dbl> <chr> #> 1     5 A     #> 2     7 B     #> 3     6 C     #> 4     5 D     #> 5     8 E     #> 6     7 F      # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_is_character(tbl, vars(b))  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto tbl %>% test_col_is_character(vars(b)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_date.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Las columnas contienen objetos R Date? — col_is_date","title":"¿Las columnas contienen objetos R Date? — col_is_date","text":"La función de validación col_is_date(), la función de expectativa expect_col_is_date() y la función de prueba test_col_is_date() comprueban si una o más columnas en una tabla es del tipo R Date. Como muchas de las funciones de tipo col_is_*() en pointblank, el único requisito es una especificación de los nombres de las columnas. La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre una sola unidad de prueba, que es si la columna es una columna de tipo Date o .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Las columnas contienen objetos R Date? — col_is_date","text":"","code":"col_is_date(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_date(object, columns, threshold = 1)  test_col_is_date(object, columns, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Las columnas contienen objetos R Date? — col_is_date","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Las columnas contienen objetos R Date? — col_is_date","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_date.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¿Las columnas contienen objetos R Date? — col_is_date","text":"Si proporciona varios nombres de columna, el resultado será una expansión de pasos de validación para ese número de nombres de columna (por ejemplo, vars(col_a, col_b) dará lugar la entrada de dos pasos de validación). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares están disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_date.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Las columnas contienen objetos R Date? — col_is_date","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_is_*(), usar action_levels(warn_at = 1) o action_levels(stop_at = 1) son buenas opciones dependiendo de la situación (la primera produce una advertencia, la otra stop()).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_date.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Las columnas contienen objetos R Date? — col_is_date","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_date.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Las columnas contienen objetos R Date? — col_is_date","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_is_date() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_is_date() como paso de validación se expresa en código R y en la representación YAML correspondiente. En la práctica, ambos serán menudo más cortos, ya que solo el argumento de las columns requiere un valor. Los argumentos con valores predeterminados se escribirán en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). También es posible obtener una vista previa de la transformación de un agente YAML sin escribir en el disco usando la función yaml_agent_string().","code":"# Código R agent %>%    col_is_date(     vars(a),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_is_date()`.\",     active = FALSE   )  # Representación YAML steps: - col_is_date:     columns: vars(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_is_date()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_date.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Las columnas contienen objetos R Date? — col_is_date","text":"2-26","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Las columnas contienen objetos R Date? — col_is_date","text":"","code":"# The `small_table` dataset in the # package has a `date` column; the # following examples will validate # that that column is of the `Date` # class  # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Validar que la columna `date` # tenga la clase `Date` agent <-   create_agent(small_table) %>%   col_is_date(vars(date)) %>%   interrogate()    # Determine si esta validación no tuvo # unidades de prueba defectuosas (1) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` small_table %>%   col_is_date(vars(date)) %>%   dplyr::slice(1:5) #> # A tibble: 5 × 8 #>   date_time           date           a b             c      d e     f     #>   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #> 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #> 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #> 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #> 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #> 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low    # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_is_date(   small_table, vars(date) )  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto small_table %>%   test_col_is_date(vars(date)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_factor.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Las columnas contienen objetos de factor R? — col_is_factor","title":"¿Las columnas contienen objetos de factor R? — col_is_factor","text":"La función de validación col_is_factor(), la función de expectativa expect_col_is_factor() y la función de prueba test_col_is_factor() comprueban si una o más columnas en una tabla son del tipo factor. Como muchas de las funciones de tipo col_is_*() en pointblank, el único requisito es una especificación de los nombres de las columnas. La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre una sola unidad de prueba, que es si la columna es una columna de tipo factor o .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_factor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Las columnas contienen objetos de factor R? — col_is_factor","text":"","code":"col_is_factor(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_factor(object, columns, threshold = 1)  test_col_is_factor(object, columns, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_factor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Las columnas contienen objetos de factor R? — col_is_factor","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_factor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Las columnas contienen objetos de factor R? — col_is_factor","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_factor.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¿Las columnas contienen objetos de factor R? — col_is_factor","text":"Si proporciona varios nombres de columna, el resultado será una expansión de pasos de validación para ese número de nombres de columna (por ejemplo, vars(col_a, col_b) dará lugar la entrada de dos pasos de validación). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares están disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_factor.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Las columnas contienen objetos de factor R? — col_is_factor","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_is_*(), usar action_levels(warn_at = 1) o action_levels(stop_at = 1) son buenas opciones dependiendo de la situación (la primera produce una advertencia, la otra stop()).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_factor.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Las columnas contienen objetos de factor R? — col_is_factor","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_factor.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Las columnas contienen objetos de factor R? — col_is_factor","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_is_factor() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_is_factor() como paso de validación se expresa en código R y en la representación YAML correspondiente. En la práctica, ambos serán menudo más cortos, ya que solo el argumento de las columns requiere un valor. Los argumentos con valores predeterminados se escribirán en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). También es posible obtener una vista previa de la transformación de un agente YAML sin escribir en el disco usando la función yaml_agent_string().","code":"# Código R agent %>%    col_is_factor(     vars(a),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_is_factor()`.\",     active = FALSE   )  # Representación YAML steps: - col_is_factor:     columns: vars(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_is_factor()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_factor.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Las columnas contienen objetos de factor R? — col_is_factor","text":"2-28","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_factor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Las columnas contienen objetos de factor R? — col_is_factor","text":"","code":"# Modifiquemos la columna `f` en la # tabla `small_table` para que los # valores sean factores en lugar de # tener la clase `character`; los # siguientes ejemplos validarán que la # columna `f` se mutó con éxito y # ahora consta de factores tbl <-    small_table %>%   dplyr::mutate(f = factor(f))  # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Validar que la columna `f` en el # objeto `tbl` sea de la clase `factor` agent <-   create_agent(tbl) %>%   col_is_factor(vars(f)) %>%   interrogate()    # Determine si esta validación no tuvo # unidades de prueba defectuosas (1) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` tbl %>%   col_is_factor(vars(f)) %>%   dplyr::slice(1:5) #> # A tibble: 5 × 8 #>   date_time           date           a b             c      d e     f     #>   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <fct> #> 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #> 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #> 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #> 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #> 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low    # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_is_factor(tbl, vars(f))  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto tbl %>% test_col_is_factor(vars(f)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_integer.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Las columnas contienen valores enteros? — col_is_integer","title":"¿Las columnas contienen valores enteros? — col_is_integer","text":"La función de validación col_is_integer(), la función de expectativa expect_col_is_integer() y la función de prueba test_col_is_integer() comprueban si una o más columnas de una tabla son de tipo entero. Como muchas de las funciones de tipo col_is_*() en pointblank, el único requisito es una especificación de los nombres de las columnas. La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre una sola unidad de prueba, que es si la columna es una columna de tipo entero o .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_integer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Las columnas contienen valores enteros? — col_is_integer","text":"","code":"col_is_integer(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_integer(object, columns, threshold = 1)  test_col_is_integer(object, columns, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_integer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Las columnas contienen valores enteros? — col_is_integer","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_integer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Las columnas contienen valores enteros? — col_is_integer","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_integer.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¿Las columnas contienen valores enteros? — col_is_integer","text":"Si proporciona varios nombres de columna, el resultado será una expansión de pasos de validación para ese número de nombres de columna (por ejemplo, vars(col_a, col_b) dará lugar la entrada de dos pasos de validación). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares están disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_integer.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Las columnas contienen valores enteros? — col_is_integer","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_is_*(), usar action_levels(warn_at = 1) o action_levels(stop_at = 1) son buenas opciones dependiendo de la situación (la primera produce una advertencia, la otra stop()).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_integer.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Las columnas contienen valores enteros? — col_is_integer","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_integer.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Las columnas contienen valores enteros? — col_is_integer","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_is_integer() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_is_integer() como paso de validación se expresa en código R y en la representación YAML correspondiente. En la práctica, ambos serán menudo más cortos, ya que solo el argumento de las columns requiere un valor. Los argumentos con valores predeterminados se escribirán en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). También es posible obtener una vista previa de la transformación de un agente YAML sin escribir en el disco usando la función yaml_agent_string().","code":"# Código R agent %>%    col_is_integer(     vars(a),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_is_integer()`.\",     active = FALSE   )  # Representación YAML steps: - col_is_integer:     columns: vars(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_is_integer()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_integer.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Las columnas contienen valores enteros? — col_is_integer","text":"2-24","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_integer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Las columnas contienen valores enteros? — col_is_integer","text":"","code":"# Para todos los ejemplos aquí, usaremos # una tabla simple con una columna de # caracteres (`a`) y una columna de # números enteros (`b`) tbl <-   dplyr::tibble(     a = letters[1:6],     b = 2:7   )    # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Validar que la columna `b` tenga la # clase `integer` agent <-   create_agent(tbl) %>%   col_is_integer(vars(b)) %>%   interrogate()  # Determine si esta validación no tuvo # unidades de prueba defectuosas (1) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` tbl %>% col_is_integer(vars(b)) #> # A tibble: 6 × 2 #>   a         b #>   <chr> <int> #> 1 a         2 #> 2 b         3 #> 3 c         4 #> 4 d         5 #> 5 e         6 #> 6 f         7  # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_is_integer(tbl, vars(b))  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto tbl %>% test_col_is_integer(vars(b)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_logical.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Las columnas contienen valores lógicos? — col_is_logical","title":"¿Las columnas contienen valores lógicos? — col_is_logical","text":"La función de validación col_is_logical(), la función de expectativa expect_col_is_logical() y la función de prueba test_col_is_logical() verifican si una o más columnas en una tabla son lógicas (TRUE/ FALSE). Como muchas de las funciones de tipo col_is_*() en pointblank, el único requisito es una especificación de los nombres de las columnas. La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre una sola unidad de prueba, que es si la columna es una columna de tipo lógico o .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_logical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Las columnas contienen valores lógicos? — col_is_logical","text":"","code":"col_is_logical(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_logical(object, columns, threshold = 1)  test_col_is_logical(object, columns, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_logical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Las columnas contienen valores lógicos? — col_is_logical","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_logical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Las columnas contienen valores lógicos? — col_is_logical","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_logical.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¿Las columnas contienen valores lógicos? — col_is_logical","text":"Si proporciona varios nombres de columna, el resultado será una expansión de pasos de validación para ese número de nombres de columna (por ejemplo, vars(col_a, col_b) dará lugar la entrada de dos pasos de validación). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares están disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_logical.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Las columnas contienen valores lógicos? — col_is_logical","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_is_*(), usar action_levels(warn_at = 1) o action_levels(stop_at = 1) son buenas opciones dependiendo de la situación (la primera produce una advertencia, la otra stop()).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_logical.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Las columnas contienen valores lógicos? — col_is_logical","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_logical.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Las columnas contienen valores lógicos? — col_is_logical","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_is_logical() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_is_logical() como paso de validación se expresa en código R y en la representación YAML correspondiente. En la práctica, ambos serán menudo más cortos, ya que solo el argumento de las columns requiere un valor. Los argumentos con valores predeterminados se escribirán en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). También es posible obtener una vista previa de la transformación de un agente YAML sin escribir en el disco usando la función yaml_agent_string().","code":"# Código R agent %>%    col_is_logical(     vars(a),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_is_logical()`.\",     active = FALSE   )  # Representación YAML steps: - col_is_logical:     columns: vars(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_is_logical()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_logical.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Las columnas contienen valores lógicos? — col_is_logical","text":"2-25","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_logical.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Las columnas contienen valores lógicos? — col_is_logical","text":"","code":"# La tabla `small_table` del paquete # tiene una columna `e` que tiene valores # lógicos; los siguientes ejemplos # validarán que esa columna es de la # clase `logical`  # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Validar que la columna `e` tenga la # clase `logical` agent <-   create_agent(small_table) %>%   col_is_logical(vars(e)) %>%   interrogate()    # Determine si esta validación no tuvo # unidades de prueba defectuosas (1) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` small_table %>%   col_is_logical(vars(e)) %>%   dplyr::slice(1:5) #> # A tibble: 5 × 8 #>   date_time           date           a b             c      d e     f     #>   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #> 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #> 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #> 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #> 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #> 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low    # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_is_logical(   small_table, vars(e) )  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto small_table %>%   test_col_is_logical(vars(e)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_numeric.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Las columnas contienen valores numéricos? — col_is_numeric","title":"¿Las columnas contienen valores numéricos? — col_is_numeric","text":"La función de validación col_is_numeric(), la función de expectativa expect_col_is_numeric() y la función de prueba test_col_is_numeric() verifican si una o más columnas en una tabla son de tipo numérico. Como muchas de las funciones de tipo col_is_*() en pointblank, el único requisito es una especificación de los nombres de las columnas. La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre una sola unidad de prueba, que es si la columna es de tipo numérico o .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_numeric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Las columnas contienen valores numéricos? — col_is_numeric","text":"","code":"col_is_numeric(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_numeric(object, columns, threshold = 1)  test_col_is_numeric(object, columns, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_numeric.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Las columnas contienen valores numéricos? — col_is_numeric","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_numeric.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Las columnas contienen valores numéricos? — col_is_numeric","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_numeric.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¿Las columnas contienen valores numéricos? — col_is_numeric","text":"Si proporciona varios nombres de columna, el resultado será una expansión de pasos de validación para ese número de nombres de columna (por ejemplo, vars(col_a, col_b) dará lugar la entrada de dos pasos de validación). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares están disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_numeric.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Las columnas contienen valores numéricos? — col_is_numeric","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_is_*(), usar action_levels(warn_at = 1) o action_levels(stop_at = 1) son buenas opciones dependiendo de la situación (la primera produce una advertencia, la otra stop()).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_numeric.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Las columnas contienen valores numéricos? — col_is_numeric","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_numeric.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Las columnas contienen valores numéricos? — col_is_numeric","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_is_numeric() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_is_numeric() como paso de validación se expresa en código R y en la representación YAML correspondiente. En la práctica, ambos serán menudo más cortos, ya que solo el argumento de las columns requiere un valor. Los argumentos con valores predeterminados se escribirán en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). También es posible obtener una vista previa de la transformación de un agente YAML sin escribir en el disco usando la función yaml_agent_string().","code":"# Código R agent %>%    col_is_numeric(     vars(a),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_is_numeric()`.\",     active = FALSE   )  # Representación YAML steps: - col_is_numeric:     columns: vars(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_is_numeric()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_numeric.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Las columnas contienen valores numéricos? — col_is_numeric","text":"2-23","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_numeric.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Las columnas contienen valores numéricos? — col_is_numeric","text":"","code":"# La tabla `small_table` del paquete # tiene una columna `d` que se sabe # que es numérica; los siguientes # ejemplos validarán que esa columna # es de hecho de la clase `numeric`  # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Validar que la columna `d` tenga # la clase `numeric` agent <-   create_agent(small_table) %>%   col_is_numeric(vars(d)) %>%   interrogate()    # Determine si esta validación no tuvo # unidades de prueba defectuosas (1) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` small_table %>%   col_is_numeric(vars(d)) %>%   dplyr::slice(1:5) #> # A tibble: 5 × 8 #>   date_time           date           a b             c      d e     f     #>   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #> 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #> 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #> 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #> 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #> 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low    # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_is_numeric(   small_table, vars(d) )  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto small_table %>%   test_col_is_numeric(vars(d)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_posix.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Las columnas contienen fechas POSIXct? — col_is_posix","title":"¿Las columnas contienen fechas POSIXct? — col_is_posix","text":"La función de validación col_is_posix(), la función de expectativa expect_col_is_posix() y la función de prueba test_col_is_posix() comprueban si una o más columnas en una tabla es del tipo de fecha y hora R POSIXct. Como muchas de las funciones de tipo col_is_*() en pointblank, el único requisito es una especificación de los nombres de las columnas. La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre una sola unidad de prueba, que es si la columna es una columna de tipo POSIXct o .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_posix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Las columnas contienen fechas POSIXct? — col_is_posix","text":"","code":"col_is_posix(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_posix(object, columns, threshold = 1)  test_col_is_posix(object, columns, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_posix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Las columnas contienen fechas POSIXct? — col_is_posix","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_posix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Las columnas contienen fechas POSIXct? — col_is_posix","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_posix.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¿Las columnas contienen fechas POSIXct? — col_is_posix","text":"Si proporciona varios nombres de columna, el resultado será una expansión de pasos de validación para ese número de nombres de columna (por ejemplo, vars(col_a, col_b) dará lugar la entrada de dos pasos de validación). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares están disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_posix.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Las columnas contienen fechas POSIXct? — col_is_posix","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_is_*(), usar action_levels(warn_at = 1) o action_levels(stop_at = 1) son buenas opciones dependiendo de la situación (la primera produce una advertencia, la otra stop()).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_posix.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Las columnas contienen fechas POSIXct? — col_is_posix","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_posix.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Las columnas contienen fechas POSIXct? — col_is_posix","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_is_posix() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_is_posix() como paso de validación se expresa en código R y en la representación YAML correspondiente. En la práctica, ambos serán menudo más cortos, ya que solo el argumento de las columns requiere un valor. Los argumentos con valores predeterminados se escribirán en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). También es posible obtener una vista previa de la transformación de un agente YAML sin escribir en el disco usando la función yaml_agent_string().","code":"# Código R agent %>%    col_is_posix(     vars(a),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_is_posix()`.\",     active = FALSE   )  # Representación YAML steps: - col_is_posix:     columns: vars(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_is_posix()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_posix.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Las columnas contienen fechas POSIXct? — col_is_posix","text":"2-27","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_posix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Las columnas contienen fechas POSIXct? — col_is_posix","text":"","code":"# La tabla `small_table` del paquete # tiene una columna `date_time`; los # siguientes ejemplos validarán que esa # columna es de las clases `POSIXct` # y `POSIXt`  # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Valide que la columna `date_time` sea # de hecho una columna de fecha y hora agent <-   create_agent(small_table) %>%   col_is_posix(vars(date_time)) %>%   interrogate()    # Determine si esta validación no tuvo # unidades de prueba defectuosas (1) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` small_table %>%   col_is_posix(vars(date_time)) %>%   dplyr::slice(1:5) #> # A tibble: 5 × 8 #>   date_time           date           a b             c      d e     f     #>   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #> 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #> 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #> 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #> 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #> 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low    # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_is_posix(   small_table, vars(date_time) )  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto small_table %>%   test_col_is_posix(vars(date_time)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Genere un esquema de columna de tabla manualmente o con una tabla de\nreferencia — col_schema","title":"Genere un esquema de columna de tabla manualmente o con una tabla de\nreferencia — col_schema","text":"Un objeto de esquema de columna de tabla, como puede ser creado por col_schema(), es necesario cuando se usa la función de validación col_schema_match() (que verifica si el objeto de tabla en estudio coincide con un esquema de columna conocido). El objeto col_schema se puede crear proporcionando cuidadosamente los nombres de las columnas y sus tipos como un conjunto de argumentos con nombre, o podríamos proporcionar un objeto de tabla, que podría ser de data.frame, tbl_df, tbl_dbi, o tbl_spark. Hay una opción adicional, que es solo para validar el esquema de un objeto tbl_dbi o tbl_spark: podemos validar el esquema en función de los tipos de columna R (por ejemplo, \"numeric\", \"character\", etc.), tipos de columna SQL (por ejemplo, \"double\", \"varchar\", etc.), o tipos de columna Spark SQL (\"DoubleType\", \"StringType\", etc.). Esto es genial si queremos validar los esquemas de columna de la tabla tanto en el lado del servidor como cuando se recopilan y cargan datos tabulares en R.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Genere un esquema de columna de tabla manualmente o con una tabla de\nreferencia — col_schema","text":"","code":"col_schema(..., .tbl = NULL, .db_col_types = c(\"r\", \"sql\"))"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Genere un esquema de columna de tabla manualmente o con una tabla de\nreferencia — col_schema","text":"... Un conjunto de argumentos con nombre donde los nombres se refieren nombres de columna y los valores son uno o más tipos de columna. .tbl Una opción para usar un objeto de tabla para definir el esquema. Si se proporciona esto, se ignorarán los valores proporcionados .... .db_col_types Determina si los tipos de columna se refieren tipos de columna R (\"r\") o tipos de columna SQL (\"sql\").","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Genere un esquema de columna de tabla manualmente o con una tabla de\nreferencia — col_schema","text":"13-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Genere un esquema de columna de tabla manualmente o con una tabla de\nreferencia — col_schema","text":"","code":"# Cree una tabla simple con dos # columnas: una `integer` y la # otra `character` tbl <-    dplyr::tibble(     a = 1:5,     b = letters[1:5]   )  # Cree un objeto de esquema de # columna que describa las columnas # y sus tipos (en el orden esperado) schema_obj <-    col_schema(     a = \"integer\",     b = \"character\"   )  # Valide que el objeto de esquema # `schema_obj` defina exactamente los # nombres de columna y los tipos de # columna de la tabla `tbl` agent <-   create_agent(tbl = tbl) %>%   col_schema_match(schema_obj) %>%   interrogate()  # Determine si este paso de validación # pasó usando `all_passed()` all_passed(agent) #> [1] TRUE  # Alternativamente, podemos crear un # objeto de esquema de columna a partir # de un objeto `tbl_df` schema_obj <-   col_schema(     .tbl = dplyr::tibble(       a = integer(0),       b = character(0)     )   )  # Esto debería proporcionar los mismos # resultados de interrogación que en # el ejemplo anterior create_agent(tbl = tbl) %>%   col_schema_match(schema_obj) %>%   interrogate() %>%   all_passed() #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema_match.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Las columnas de la tabla (y sus tipos) coinciden con un esquema predefinido? — col_schema_match","title":"¿Las columnas de la tabla (y sus tipos) coinciden con un esquema predefinido? — col_schema_match","text":"La función de validación col_schema_match(), la función de expectativa expect_col_schema_match() y la función de prueba test_col_schema_match() funcionan en conjunto con un objeto col_schema (generado través de la función col_schema()) para determinar si el esquema esperado coincide con el de la tabla de destino. La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). El paso de validación o expectativa opera sobre una sola unidad de prueba, que es si el esquema coincide con el de la tabla (dentro de las restricciones impuestas por las opciones complete, in_order y is_exact). Si la tabla de destino es un objeto tbl_dbi o tbl_spark, podemos optar por validar el esquema de columna que se basa en los tipos de columna R (por ejemplo, \"numeric\", \"character\", etc.), Tipos de columna SQL (p. Ej., \"Double\", \"varchar\", etc.) o tipos de Spark SQL (p. Ej., \"DoubleType\", \"StringType\", etc.). Esa opción se define en la función col_schema() (es el argumento .db_col_types). Hay opciones para hacer que la verificación de esquemas sea menos estricta (de forma predeterminada, esta validación opera con el nivel más alto de rigor). Con la opción complete establecida en FALSE, podemos proporcionar un objeto col_schema con una inclusión parcial de columnas. El uso de in_order establecido en FALSE significa que es necesario que las columnas definidas en el objeto schema estén en el mismo orden que en la tabla de destino. Finalmente, la opción is_exact establecida en FALSE significa que es necesario proporcionar todas las clases / tipos de columna para una columna en particular. Incluso puede ser NULL, omitiendo la verificación del tipo de columna.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema_match.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Las columnas de la tabla (y sus tipos) coinciden con un esquema predefinido? — col_schema_match","text":"","code":"col_schema_match(   x,   schema,   complete = TRUE,   in_order = TRUE,   is_exact = TRUE,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_schema_match(   object,   schema,   complete = TRUE,   in_order = TRUE,   is_exact = TRUE,   threshold = 1 )  test_col_schema_match(   object,   schema,   complete = TRUE,   in_order = TRUE,   is_exact = TRUE,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema_match.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Las columnas de la tabla (y sus tipos) coinciden con un esquema predefinido? — col_schema_match","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). schema Un esquema de tabla de tipo col_schema que se puede generar usando la función col_schema(). complete Este es un requisito para tener en cuenta todas las columnas de la tabla en el schema proporcionado. De forma predeterminada, es TRUE, por lo que todos los nombres de columna de la tabla de destino deben estar presentes en el objeto de esquema. Esta restricción se puede relajar usando FALSE, donde podemos proporcionar un subconjunto de columnas de tabla en el esquema. in_order Este es un requisito estricto para hacer cumplir el orden de las columnas en el schema proporcionado. De forma predeterminada, es TRUE y el orden de las columnas tanto en el esquema como en la tabla de destino debe coincidir. Al establecerlo en FALSE, se elimina este requisito de orden estricto. is_exact Esta opción determina si la verificación de los tipos de columna debe ser exacta o incluso realizada. Por ejemplo, las columnas en los marcos de datos R pueden tener varias clases (por ejemplo, una columna de fecha y hora puede tener las clases POSIXct y POSIXt). Si usa is_exact == FALSE, el tipo de columna en el esquema definido por el usuario para un valor de fecha y hora se puede establecer como \"POSIXct\" o \"POSIXt\" y pasar la validación (con esta columna, por lo menos). Esto se puede ir un paso más allá y el uso de NULL para un tipo de columna en el esquema definido por el usuario omitirá la verificación de validación de un tipo de columna. De forma predeterminada, is_exact se establece en TRUE. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema_match.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Las columnas de la tabla (y sus tipos) coinciden con un esquema predefinido? — col_schema_match","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema_match.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Las columnas de la tabla (y sus tipos) coinciden con un esquema predefinido? — col_schema_match","text":"menudo, querremos especificar \"acciones\" para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. El uso de action_levels(warn_at = 1) o action_levels(stop_at = 1) son buenas opciones dependiendo de la situación (el primero produce una advertencia, el otro stop()).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema_match.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Las columnas de la tabla (y sus tipos) coinciden con un esquema predefinido? — col_schema_match","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema_match.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Las columnas de la tabla (y sus tipos) coinciden con un esquema predefinido? — col_schema_match","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_schema_match() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_schema_match() como paso de validación se expresa en código R y en la representación YAML correspondiente. En la práctica, ambos serán menudo más cortos ya que solo el argumento schema requiere un valor. Los argumentos con valores predeterminados se escribirán en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). También es posible obtener una vista previa de la transformación de un agente YAML sin escribir en el disco usando la función yaml_agent_string().","code":"# Código R agent %>%    col_schema_match(     schema = col_schema(       a = \"integer\",       b = \"character\"     ),      complete = FALSE,     in_order = FALSE,     is_exact = FALSE,     actions = action_levels(stop_at = 1),     label = \"El paso `col_schema_match()`.\",     active = FALSE   )  # Representación YAML steps: - col_schema_match:     schema:       a: integer       b: character     complete: false     in_order: false     is_exact: false     actions:       stop_count: 1.0     label: El paso `col_schema_match()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema_match.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Las columnas de la tabla (y sus tipos) coinciden con un esquema predefinido? — col_schema_match","text":"2-30","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema_match.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Las columnas de la tabla (y sus tipos) coinciden con un esquema predefinido? — col_schema_match","text":"","code":"# Para todos los ejemplos aquí, # usaremos una tabla simple con dos # columnas: una `integral` (`a`) y la # otra `caracteres` (`b`); los # siguientes ejemplos validarán que # las columnas de la tabla coinciden # con un esquema creado por # `col_schema()`. tbl <-    dplyr::tibble(     a = 1:5,     b = letters[1:5]   )    tbl #> # A tibble: 5 × 2 #>       a b     #>   <int> <chr> #> 1     1 a     #> 2     2 b     #> 3     3 c     #> 4     4 d     #> 5     5 e      # Crear un objeto de esquema de # columnas con la función de ayuda # `col_schema()` que describa las # columnas y sus tipos (en el # orden esperado) schema_obj <-    col_schema(     a = \"integer\",     b = \"character\"   )    # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Validar que el objeto de esquema # `schema_obj` define exactamente los # nombres y tipos de columnas agent <-   create_agent(tbl) %>%   col_schema_match(schema_obj) %>%   interrogate()  # Determinar si esta validación no tenía # unidades de prueba que fallaran (hay # una única unidad de prueba gobernada # por si hay una coincidencia) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` tbl %>% col_schema_match(schema_obj) #> # A tibble: 5 × 2 #>       a b     #>   <int> <chr> #> 1     1 a     #> 2     2 b     #> 3     3 c     #> 4     4 d     #> 5     5 e      # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_schema_match(tbl, schema_obj)  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto tbl %>% test_col_schema_match(schema_obj) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_between.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Los datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? — col_vals_between","title":"¿Los datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? — col_vals_between","text":"La función de validación col_vals_between(), la función de expectativa expect_col_vals_between() y la función de prueba test_col_vals_between() comprueban si los valores de las columnas de una tabla están dentro de un rango. El rango especificado con tres argumentos: left, right e inclusive. Los valores left y right especifican los límites superior e inferior. Los límites se pueden especificar como valores literales simples o como nombres de columna dados en vars(). El argumento inclusive, como un vector de dos valores lógicos relacionados con \"izquierda\" y \"derecha\", establece si cada límite es inclusivo o . El valor predeterminado es c(TRUE, TRUE), donde ambos extremos son inclusivos (es decir, [izquierda, derecha]). Para versiones parcialmente ilimitadas de esta función, podemos usar las funciones de validación col_vals_lt(), col_vals_lte(), col_vals_gt() o col_vals_gte(). La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre el número de unidades de prueba que es igual al número de filas en la tabla (después de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_between.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Los datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? — col_vals_between","text":"","code":"col_vals_between(   x,   columns,   left,   right,   inclusive = c(TRUE, TRUE),   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_between(   object,   columns,   left,   right,   inclusive = c(TRUE, TRUE),   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_between(   object,   columns,   left,   right,   inclusive = c(TRUE, TRUE),   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_between.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Los datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? — col_vals_between","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. left El límite inferior del rango. La validación incluye este valor límite (si el primer elemento en inclusive es TRUE) además de valores mayores que left. Puede ser un valor único o una columna compatible dada en vars(). right El límite superior del rango. La validación incluye este valor límite (si el segundo elemento en inclusive es TRUE) además de valores inferiores right. Puede ser un valor único o una columna compatible dada en vars(). inclusive Un valor lógico de dos elementos que indica si los límites left y right deben ser inclusivos. De forma predeterminada, ambos límites son inclusivos. na_pass ¿Debería considerarse que los valores de NA encontrados pasan unidades de prueba? Esto es por defecto FALSE. Ajústelo en TRUE para darle un pase NA. preconditions Una expresión opcional para mutar la tabla de entrada antes de continuar con la validación. Esto se puede proporcionar como una fórmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una función (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la sección Preconditions para obtener más información. segments Una expresión opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la sección Segments para obtener más detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_between.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Los datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? — col_vals_between","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_between.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¿Los datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? — col_vals_between","text":"Si proporciona varios nombres de columna, el resultado será una expansión de pasos de validación para ese número de nombres de columna (por ejemplo, vars(col_a, col_b) dará lugar la entrada de dos pasos de validación). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares están disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_between.html","id":"valores-faltantes","dir":"Reference","previous_headings":"","what":"Valores faltantes","title":"¿Los datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? — col_vals_between","text":"Esta función de validación admite el manejo especial de valores NA. El argumento na_pass determinará si un valor de NA que aparece en una unidad de prueba debe pasar o . El valor predeterminado de na_pass = FALSE significa que cualquier NA encontrado acumulará unidades de prueba fallidas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_between.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¿Los datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? — col_vals_between","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesará la tabla de destino durante la interrogación como paso preparatorio. Puede suceder que una validación en particular requiera una columna calculada, algún filtrado de filas o la adición de columnas través de una combinación, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validación con una sola tabla de destino y realice ajustes menores en ella, según sea necesario, lo largo del camino. La mutación de la tabla está totalmente aislada en el alcance de los pasos de validación en los que se utilizan las preconditions. Aquí se sugiere usar el código dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El código se proporciona más fácilmente como una fórmula R unilateral (utilizando un ~ inicial). En la representación de la fórmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podría proporcionar una función (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_between.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¿Los datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? — col_vals_between","text":"Al usar el argumento segments, es posible definir una validación particular con segmentos (o porciones de fila) de la tabla de destino. Una expresión opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresión que se puede utilizar, vars(a_column) segmentará la tabla de destino en la forma en que estén presentes muchos valores únicos en la columna llamada a_column. Esto es excelente si cada valor único en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validación repetida. Con una fórmula, podemos ser más selectivos con los valores de columna que se deben usar para la segmentación. El uso de a_column ~ c(\"group_1\", \"group_2\") intentará obtener dos segmentos donde uno es una porción de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la fórmula dará como resultado un paso de validación independiente. Si hay varias columns especificadas, el número potencial de pasos de validación será m columnas multiplicadas por n segmentos resueltos. La segmentación siempre ocurrirá después de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinación, es posible generar etiquetas para la segmentación usando una expresión para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versión separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_between.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Los datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? — col_vals_between","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situación (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_between.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Los datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? — col_vals_between","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_between.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Los datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? — col_vals_between","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_vals_between() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_vals_between() como paso de validación se expresa en código R y en la representación YAML correspondiente. En la práctica, ambos suelen ser más cortos, ya que solo los argumentos de las columns, left y right requieren valores. Los argumentos con valores predeterminados se escribirán en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). También es posible obtener una vista previa de la transformación de un agente YAML sin escribir en el disco usando la función yaml_agent_string().","code":"# Código R agent %>%    col_vals_between(     columns = vars(a),     left = 1,     right = 2,     inclusive = c(TRUE, FALSE),     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_between()`.\",     active = FALSE   )  # Representación YAML steps: - col_vals_between:     columns: vars(a)     left: 1.0     right: 2.0     inclusive:     - true     - false     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_between()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_between.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Los datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? — col_vals_between","text":"2-7","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_between.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Los datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? — col_vals_between","text":"","code":"# El conjunto de datos `small_table` en # el paquete tiene una columna de valores # numéricos en `c` (hay algunas `NA` en # esa columna); los siguientes ejemplos # validarán los valores en esa # columna numérica  # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Valide que los valores en la columna # `c` estén todos entre `1` y `9`; # debido a que hay valores `NA`, # elegiremos dejar que pasen la # validación configurando `na_pass = TRUE` agent <-   create_agent(small_table) %>%   col_vals_between(     vars(c), 1, 9, na_pass = TRUE   ) %>%   interrogate()    # Determine si esta validación no tuvo # unidades de prueba fallidas (hay 13 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` small_table %>%   col_vals_between(     vars(c), 1, 9, na_pass = TRUE   ) %>%   dplyr::pull(c) #>  [1]  3  8  3 NA  7  4  3  2  9  9  7  8 NA  # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_between(   small_table, vars(c), 1, 9,   na_pass = TRUE )  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto small_table %>%   test_col_vals_between(     vars(c), 1, 9,     na_pass = TRUE   ) #> [1] TRUE  # Una nota adicional sobre los límites # de esta función: son inclusivos por # defecto (es decir, se aprobarán valores # de exactamente `1` y `9`); podemos # modificar la inclusividad de los límites # superior e inferior con la opción # `inclusive`, que es un vector lógico # de longitud 2  # Al probar con el límite superior no # inclusivo, obtenemos `FALSO` ya que dos # valores son `9` y ahora quedan fuera # del límite superior (o derecho) small_table %>%   test_col_vals_between(     vars(c), 1, 9,     inclusive = c(TRUE, FALSE),     na_pass = TRUE   ) #> [1] FALSE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_decreasing.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Los datos de las columnas están disminuyendo por filas? — col_vals_decreasing","title":"¿Los datos de las columnas están disminuyendo por filas? — col_vals_decreasing","text":"La función de validación col_vals_decreasing(), la función de expectativa expect_col_vals_decreasing() y la función de prueba test_col_vals_decreasing() comprueban si los valores de las columnas en una tabla están disminuyendo cuando se mueve hacia abajo en una tabla. Hay opciones para permitir valores NA en la columna de destino, permitir fases estacionarias (donde los valores consecutivos cambian), e incluso para permitir movimientos crecientes hasta un cierto umbral. La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre el número de unidades de prueba que es igual al número de filas en la tabla (después de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_decreasing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Los datos de las columnas están disminuyendo por filas? — col_vals_decreasing","text":"","code":"col_vals_decreasing(   x,   columns,   allow_stationary = FALSE,   increasing_tol = NULL,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_decreasing(   object,   columns,   allow_stationary = FALSE,   increasing_tol = NULL,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_decreasing(   object,   columns,   allow_stationary = FALSE,   increasing_tol = NULL,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_decreasing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Los datos de las columnas están disminuyendo por filas? — col_vals_decreasing","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. allow_stationary Una opción para permitir pausas en valores decrecientes. Por ejemplo, si los valores de las unidades de prueba son [85, 82, 82, 80, 77], la tercera unidad (82, que aparece por segunda vez) fallará cuando allow_stationary sea FALSE (el valor predeterminado ). El uso de allow_stationary = TRUE dará como resultado que todas las unidades de prueba en [85, 82, 82, 80, 77] se marquen con aprobado. increasing_tol Un valor de umbral opcional que permite el movimiento de valores numéricos en la dirección positiva. De forma predeterminada, es NULL, pero se utiliza un valor numérico para establecer el umbral absoluto de recorrido positivo permitido en las unidades de prueba numéricas. Tenga en cuenta que establecer un valor aquí también tiene el efecto de establecer allow_stationary en TRUE. na_pass ¿Debería considerarse que los valores de NA encontrados pasan unidades de prueba? Esto es por defecto FALSE. Ajústelo en TRUE para darle un pase NA. preconditions Una expresión opcional para mutar la tabla de entrada antes de continuar con la validación. Esto se puede proporcionar como una fórmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una función (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la sección Preconditions para obtener más información. segments Una expresión opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la sección Segments para obtener más detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_decreasing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Los datos de las columnas están disminuyendo por filas? — col_vals_decreasing","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_decreasing.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¿Los datos de las columnas están disminuyendo por filas? — col_vals_decreasing","text":"Si proporciona varios nombres de columna, el resultado será una expansión de pasos de validación para ese número de nombres de columna (por ejemplo, vars(col_a, col_b) dará lugar la entrada de dos pasos de validación). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares están disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_decreasing.html","id":"valores-faltantes","dir":"Reference","previous_headings":"","what":"Valores faltantes","title":"¿Los datos de las columnas están disminuyendo por filas? — col_vals_decreasing","text":"Esta función de validación admite el manejo especial de valores NA. El argumento na_pass determinará si un valor de NA que aparece en una unidad de prueba debe pasar o . El valor predeterminado de na_pass = FALSE significa que cualquier NA encontrado acumulará unidades de prueba fallidas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_decreasing.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¿Los datos de las columnas están disminuyendo por filas? — col_vals_decreasing","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesará la tabla de destino durante la interrogación como paso preparatorio. Puede suceder que una validación en particular requiera una columna calculada, algún filtrado de filas o la adición de columnas través de una combinación, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validación con una sola tabla de destino y realice ajustes menores en ella, según sea necesario, lo largo del camino. La mutación de la tabla está totalmente aislada en el alcance de los pasos de validación en los que se utilizan las preconditions. Aquí se sugiere usar el código dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El código se proporciona más fácilmente como una fórmula R unilateral (utilizando un ~ inicial). En la representación de la fórmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podría proporcionar una función (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_decreasing.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¿Los datos de las columnas están disminuyendo por filas? — col_vals_decreasing","text":"Al usar el argumento segments, es posible definir una validación particular con segmentos (o porciones de fila) de la tabla de destino. Una expresión opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresión que se puede utilizar, vars(a_column) segmentará la tabla de destino en la forma en que estén presentes muchos valores únicos en la columna llamada a_column. Esto es excelente si cada valor único en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validación repetida. Con una fórmula, podemos ser más selectivos con los valores de columna que se deben usar para la segmentación. El uso de a_column ~ c(\"group_1\", \"group_2\") intentará obtener dos segmentos donde uno es una porción de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la fórmula dará como resultado un paso de validación independiente. Si hay varias columns especificadas, el número potencial de pasos de validación será m columnas multiplicadas por n segmentos resueltos. La segmentación siempre ocurrirá después de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinación, es posible generar etiquetas para la segmentación usando una expresión para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versión separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_decreasing.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Los datos de las columnas están disminuyendo por filas? — col_vals_decreasing","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situación (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_decreasing.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Los datos de las columnas están disminuyendo por filas? — col_vals_decreasing","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_decreasing.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Los datos de las columnas están disminuyendo por filas? — col_vals_decreasing","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_vals_decreasing() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_vals_decreasing() como paso de validación se expresa en código R y en la representación YAML correspondiente. En la práctica, ambos serán menudo más cortos, ya que solo el argumento de las columns requiere un valor. Los argumentos con valores predeterminados se escribirán en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). También es posible obtener una vista previa de la transformación de un agente YAML sin escribir en el disco usando la función yaml_agent_string().","code":"# Código R agent %>%    col_vals_decreasing(     columns = vars(a),     allow_stationary = TRUE,     increasing_tol = 0.5,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_decreasing()`.\",     active = FALSE   ) %>% yaml_agent_string()  # Representación YAML steps: - col_vals_decreasing:     columns: vars(a)     allow_stationary: true     increasing_tol: 0.5     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_decreasing()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_decreasing.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Los datos de las columnas están disminuyendo por filas? — col_vals_decreasing","text":"2-14","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_equal.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Son los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_equal","title":"¿Son los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_equal","text":"La función de validación col_vals_equal(), la función de expectativa expect_col_vals_equal() y la función de prueba test_col_vals_equal() comprueban si los valores de las columnas en una tabla son iguales un value especificado. El value se puede especificar como un valor literal único o como un nombre de columna dado en vars(). La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre el número de unidades de prueba que es igual al número de filas en la tabla (después de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_equal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Son los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_equal","text":"","code":"col_vals_equal(   x,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_equal(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_equal(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_equal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Son los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_equal","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. value Un valor utilizado para esta prueba de igualdad. Puede ser un valor único o una columna compatible dada en vars(). Cualquier valor de columna igual lo que se especifica aquí pasará la validación. na_pass ¿Debería considerarse que los valores de NA encontrados pasan unidades de prueba? Esto es por defecto FALSE. Ajústelo en TRUE para darle un pase NA. preconditions Una expresión opcional para mutar la tabla de entrada antes de continuar con la validación. Esto se puede proporcionar como una fórmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una función (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la sección Preconditions para obtener más información. segments Una expresión opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la sección Segments para obtener más detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_equal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Son los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_equal","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_equal.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¿Son los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_equal","text":"Si proporciona varios nombres de columna, el resultado será una expansión de pasos de validación para ese número de nombres de columna (por ejemplo, vars(col_a, col_b) dará lugar la entrada de dos pasos de validación). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares están disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_equal.html","id":"valores-faltantes","dir":"Reference","previous_headings":"","what":"Valores faltantes","title":"¿Son los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_equal","text":"Esta función de validación admite el manejo especial de valores NA. El argumento na_pass determinará si un valor de NA que aparece en una unidad de prueba debe pasar o . El valor predeterminado de na_pass = FALSE significa que cualquier NA encontrado acumulará unidades de prueba fallidas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_equal.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¿Son los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_equal","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesará la tabla de destino durante la interrogación como paso preparatorio. Puede suceder que una validación en particular requiera una columna calculada, algún filtrado de filas o la adición de columnas través de una combinación, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validación con una sola tabla de destino y realice ajustes menores en ella, según sea necesario, lo largo del camino. La mutación de la tabla está totalmente aislada en el alcance de los pasos de validación en los que se utilizan las preconditions. Aquí se sugiere usar el código dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El código se proporciona más fácilmente como una fórmula R unilateral (utilizando un ~ inicial). En la representación de la fórmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podría proporcionar una función (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_equal.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¿Son los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_equal","text":"Al usar el argumento segments, es posible definir una validación particular con segmentos (o porciones de fila) de la tabla de destino. Una expresión opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresión que se puede utilizar, vars(a_column) segmentará la tabla de destino en la forma en que estén presentes muchos valores únicos en la columna llamada a_column. Esto es excelente si cada valor único en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validación repetida. Con una fórmula, podemos ser más selectivos con los valores de columna que se deben usar para la segmentación. El uso de a_column ~ c(\"group_1\", \"group_2\") intentará obtener dos segmentos donde uno es una porción de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la fórmula dará como resultado un paso de validación independiente. Si hay varias columns especificadas, el número potencial de pasos de validación será m columnas multiplicadas por n segmentos resueltos. La segmentación siempre ocurrirá después de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinación, es posible generar etiquetas para la segmentación usando una expresión para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versión separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_equal.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Son los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_equal","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situación (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_equal.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Son los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_equal","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_equal.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Son los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_equal","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_vals_equal() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_vals_equal() como paso de validación se expresa en código R y en la representación YAML correspondiente. En la práctica, ambos serán menudo más cortos, ya que solo el argumento de las columns requiere un valor. Los argumentos con valores predeterminados se escribirán en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). También es posible obtener una vista previa de la transformación de un agente YAML sin escribir en el disco usando la función yaml_agent_string().","code":"# Código R agent %>%    col_vals_equal(     columns = vars(a),     value = 1,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_equal()`.\",     active = FALSE   )  # Representación YAML steps: - col_vals_equal:     columns: vars(a)     value: 1.0     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_equal()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_equal.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Son los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_equal","text":"2-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_equal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Son los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_equal","text":"","code":"# Para todos los ejemplos aquí, # usaremos una tabla simple con tres # columnas numéricas (`a`,` b` y `c`) # y tres columnas de caracteres # (`d`, `e` y `f`) tbl <-   dplyr::tibble(     a = c(5, 5, 5, 5, 5, 5),     b = c(1, 1, 1, 2, 2, 2),     c = c(1, 1, 1, 2, 2, 2),     d = LETTERS[c(1:3, 5:7)],     e = LETTERS[c(1:6)],     f = LETTERS[c(1:6)]   )    tbl #> # A tibble: 6 × 6 #>       a     b     c d     e     f     #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 A     A     A     #> 2     5     1     1 B     B     B     #> 3     5     1     1 C     C     C     #> 4     5     2     2 E     D     D     #> 5     5     2     2 F     E     E     #> 6     5     2     2 G     F     F      # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Valide que los valores en la columna # `a` sean todos iguales al valor de `5` agent <-   create_agent(tbl) %>%   col_vals_equal(vars(a), 5) %>%   interrogate()  # Determine si esta validación no tuvo # unidades de prueba fallidas (hay 6 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` tbl %>%    col_vals_equal(vars(a), 5) %>%   dplyr::pull(a) #> [1] 5 5 5 5 5 5    # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_equal(tbl, vars(a), 5)  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto test_col_vals_equal(tbl, vars(a), 5) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_expr.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Coinciden los datos de la columna con una expresión de predicado? — col_vals_expr","title":"¿Coinciden los datos de la columna con una expresión de predicado? — col_vals_expr","text":"La función de validación col_vals_expr(), la función de expectativa expect_col_vals_expr() y la función de prueba test_col_vals_expr() comprueban si los valores de las columnas en una tabla concuerdan con una expresión de predicado definida por el usuario. La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre el número de unidades de prueba que es igual al número de filas en la tabla (después de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_expr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Coinciden los datos de la columna con una expresión de predicado? — col_vals_expr","text":"","code":"col_vals_expr(   x,   expr,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_expr(object, expr, preconditions = NULL, threshold = 1)  test_col_vals_expr(object, expr, preconditions = NULL, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_expr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Coinciden los datos de la columna con una expresión de predicado? — col_vals_expr","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). expr Una expresión para usar en esta prueba. Esto puede ser en forma de una llamada realizada con la función expr() o como una fórmula R unilateral (usando un ~ inicial). preconditions Una expresión opcional para mutar la tabla de entrada antes de continuar con la validación. Esto se puede proporcionar como una fórmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una función (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la sección Preconditions para obtener más información. segments Una expresión opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la sección Segments para obtener más detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_expr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Coinciden los datos de la columna con una expresión de predicado? — col_vals_expr","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_expr.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¿Coinciden los datos de la columna con una expresión de predicado? — col_vals_expr","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesará la tabla de destino durante la interrogación como paso preparatorio. Puede suceder que una validación en particular requiera una columna calculada, algún filtrado de filas o la adición de columnas través de una combinación, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validación con una sola tabla de destino y realice ajustes menores en ella, según sea necesario, lo largo del camino. La mutación de la tabla está totalmente aislada en el alcance de los pasos de validación en los que se utilizan las preconditions. Aquí se sugiere usar el código dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El código se proporciona más fácilmente como una fórmula R unilateral (utilizando un ~ inicial). En la representación de la fórmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podría proporcionar una función (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_expr.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¿Coinciden los datos de la columna con una expresión de predicado? — col_vals_expr","text":"Al usar el argumento segments, es posible definir una validación particular con segmentos (o porciones de fila) de la tabla de destino. Una expresión opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresión que se puede utilizar, vars(a_column) segmentará la tabla de destino en la forma en que estén presentes muchos valores únicos en la columna llamada a_column. Esto es excelente si cada valor único en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validación repetida. Con una fórmula, podemos ser más selectivos con los valores de columna que se deben usar para la segmentación. El uso de a_column ~ c(\"group_1\", \"group_2\") intentará obtener dos segmentos donde uno es una porción de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la fórmula dará como resultado un paso de validación independiente. Si hay varias columns especificadas, el número potencial de pasos de validación será m columnas multiplicadas por n segmentos resueltos. La segmentación siempre ocurrirá después de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinación, es posible generar etiquetas para la segmentación usando una expresión para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versión separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_expr.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Coinciden los datos de la columna con una expresión de predicado? — col_vals_expr","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situación (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_expr.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Coinciden los datos de la columna con una expresión de predicado? — col_vals_expr","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_expr.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Coinciden los datos de la columna con una expresión de predicado? — col_vals_expr","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_vals_expr() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_vals_expr() como paso de validación se expresa en código R y en la representación YAML correspondiente. En la práctica, ambos serán menudo más cortos ya que solo el argumento expr requiere un valor. Los argumentos con valores predeterminados se escribirán en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). También es posible obtener una vista previa de la transformación de un agente YAML sin escribir en el disco usando la función yaml_agent_string().","code":"# Código R agent %>%    col_vals_expr(     expr = ~ a %% 1 == 0,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_expr()`.\",     active = FALSE   )  # Representación YAML steps: - col_vals_expr:     expr: ~a%%1 == 0     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_expr()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_expr.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Coinciden los datos de la columna con una expresión de predicado? — col_vals_expr","text":"2-19","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_expr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Coinciden los datos de la columna con una expresión de predicado? — col_vals_expr","text":"","code":"# Para todos los ejemplos aquí, # usaremos una tabla simple con tres # columnas numéricas (`a`, `b` y `c`) # y tres columnas de caracteres # (`d`, `e` y `f`) tbl <-   dplyr::tibble(     a = c(1, 2, 1, 7, 8, 6),     b = c(0, 0, 0, 1, 1, 1),     c = c(0.5, 0.3, 0.8, 1.4, 1.9, 1.2),   )    tbl #> # A tibble: 6 × 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     1     0   0.5 #> 2     2     0   0.3 #> 3     1     0   0.8 #> 4     7     1   1.4 #> 5     8     1   1.9 #> 6     6     1   1.2  # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Valide que los valores en la columna # `a` sean de tipo entero usando el # operador de módulo R y esperando `0` agent <-   create_agent(tbl) %>%   col_vals_expr(expr(a %% 1 == 0)) %>%   interrogate()  # Determine si esta validación no tuvo # unidades de prueba fallidas (hay 6 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` tbl %>%    col_vals_expr(expr(a %% 1 == 0)) %>%   dplyr::pull(a) #> [1] 1 2 1 7 8 6    # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_expr(tbl, ~ a %% 1 == 0)  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto test_col_vals_expr(tbl, ~ a %% 1 == 0) #> [1] TRUE  # Variaciones  # Podemos hacer cosas más complejas # aprovechando las funciones `case_when()` # y `between()` (disponibles para su uso # en el paquete pointblank) tbl %>%   test_col_vals_expr(~ case_when(     b == 0 ~ a %>% between(0, 5) & c < 1,     b == 1 ~ a > 5 & c >= 1   )) #> [1] TRUE  # Si solo desea probar un subconjunto de # filas, entonces la declaración # `case_when()` no necesita ser exhaustiva; # todas las filas que no caigan en los # casos se recortarán (lo que nos dará # menos unidades de prueba en general) tbl %>%   test_col_vals_expr(~ case_when(     b == 1 ~ a > 5 & c >= 1   )) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gt.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Los datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? — col_vals_gt","title":"¿Los datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? — col_vals_gt","text":"La función de validación col_vals_gt(), la función de expectativa expect_col_vals_gt() y la función de prueba test_col_vals_gt() comprueban si los valores de las columnas en una tabla son mayores que un value especificado (la comparación exacta utilizada en esta función es col_val > value). El value se puede especificar como un valor literal único o como un nombre de columna dado en vars(). La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre el número de unidades de prueba que es igual al número de filas en la tabla (después de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Los datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? — col_vals_gt","text":"","code":"col_vals_gt(   x,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_gt(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_gt(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Los datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? — col_vals_gt","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. value Un valor utilizado para esta comparación. Puede ser un valor único o una columna compatible dada en vars(). Cualquier valor de columna mayor que el especificado aquí pasará la validación. na_pass ¿Debería considerarse que los valores de NA encontrados pasan unidades de prueba? Esto es por defecto FALSE. Ajústelo en TRUE para darle un pase NA. preconditions Una expresión opcional para mutar la tabla de entrada antes de continuar con la validación. Esto se puede proporcionar como una fórmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una función (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la sección Preconditions para obtener más información. segments Una expresión opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la sección Segments para obtener más detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Los datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? — col_vals_gt","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gt.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¿Los datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? — col_vals_gt","text":"Si proporciona varios nombres de columna, el resultado será una expansión de pasos de validación para ese número de nombres de columna (por ejemplo, vars(col_a, col_b) dará lugar la entrada de dos pasos de validación). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares están disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gt.html","id":"valores-faltantes","dir":"Reference","previous_headings":"","what":"Valores faltantes","title":"¿Los datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? — col_vals_gt","text":"Esta función de validación admite el manejo especial de valores NA. El argumento na_pass determinará si un valor de NA que aparece en una unidad de prueba debe pasar o . El valor predeterminado de na_pass = FALSE significa que cualquier NA encontrado acumulará unidades de prueba fallidas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gt.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¿Los datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? — col_vals_gt","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesará la tabla de destino durante la interrogación como paso preparatorio. Puede suceder que una validación en particular requiera una columna calculada, algún filtrado de filas o la adición de columnas través de una combinación, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validación con una sola tabla de destino y realice ajustes menores en ella, según sea necesario, lo largo del camino. La mutación de la tabla está totalmente aislada en el alcance de los pasos de validación en los que se utilizan las preconditions. Aquí se sugiere usar el código dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El código se proporciona más fácilmente como una fórmula R unilateral (utilizando un ~ inicial). En la representación de la fórmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podría proporcionar una función (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gt.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¿Los datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? — col_vals_gt","text":"Al usar el argumento segments, es posible definir una validación particular con segmentos (o porciones de fila) de la tabla de destino. Una expresión opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresión que se puede utilizar, vars(a_column) segmentará la tabla de destino en la forma en que estén presentes muchos valores únicos en la columna llamada a_column. Esto es excelente si cada valor único en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validación repetida. Con una fórmula, podemos ser más selectivos con los valores de columna que se deben usar para la segmentación. El uso de a_column ~ c(\"group_1\", \"group_2\") intentará obtener dos segmentos donde uno es una porción de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la fórmula dará como resultado un paso de validación independiente. Si hay varias columns especificadas, el número potencial de pasos de validación será m columnas multiplicadas por n segmentos resueltos. La segmentación siempre ocurrirá después de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinación, es posible generar etiquetas para la segmentación usando una expresión para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versión separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gt.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Los datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? — col_vals_gt","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situación (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gt.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Los datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? — col_vals_gt","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gt.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Los datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? — col_vals_gt","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_vals_gt() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_vals_gt() como paso de validación se expresa en código R y en la representación YAML correspondiente. practice, often shorter columns value arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# Código R agent %>%    col_vals_gt(     columns = vars(a),     value = 1,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_gt()`.\",     active = FALSE   )  # Representación YAML steps: - col_vals_gt:     columns: vars(a)     value: 1.0     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_gt()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gt.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Los datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? — col_vals_gt","text":"2-6","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Los datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? — col_vals_gt","text":"","code":"# Para todos los ejemplos, # utilizaremos una tabla sencilla # con tres columnas numéricas # (`a`, `b` y `c`) y tres columnas # de caracteres (`d`, `e` y `f`) tbl <-   dplyr::tibble(     a = c(5, 5, 5, 5, 5, 5),     b = c(1, 1, 1, 2, 2, 2),     c = c(1, 1, 1, 2, 3, 4),     d = LETTERS[a],     e = LETTERS[b],     f = LETTERS[c]   )    tbl #> # A tibble: 6 × 6 #>       a     b     c d     e     f     #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 E     A     A     #> 2     5     1     1 E     A     A     #> 3     5     1     1 E     A     A     #> 4     5     2     2 E     B     B     #> 5     5     2     3 E     B     C     #> 6     5     2     4 E     B     D      # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Valida que los valores de la columna # `a` son todos mayores que el valor # de `4`. agent <-   create_agent(tbl) %>%   col_vals_gt(vars(a), value = 4) %>%   interrogate()  # Determine si esta validación no tuvo # unidades de prueba fallidas (hay 6 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` tbl %>%    col_vals_gt(vars(a), value = 4) %>%   dplyr::pull(a) #> [1] 5 5 5 5 5 5    # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_gt(   tbl, vars(a),   value = 4 )  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto test_col_vals_gt(   tbl, vars(a),    value = 4 ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gte.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Los datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? — col_vals_gte","title":"¿Los datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? — col_vals_gte","text":"La función de validación col_vals_gte(), la función de expectativa expect_col_vals_gte() y la función de prueba test_col_vals_gte() comprueban si los valores de las columnas en una tabla son mayores o iguales un value especificado (el La comparación exacta utilizada en esta función es col_val> = value). El value se puede especificar como un valor literal único o como un nombre de columna dado en vars(). La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre el número de unidades de prueba que es igual al número de filas en la tabla (después de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gte.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Los datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? — col_vals_gte","text":"","code":"col_vals_gte(   x,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_gte(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_gte(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gte.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Los datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? — col_vals_gte","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. value Un valor utilizado para esta comparación. Puede ser un valor único o una columna compatible dada en vars(). Cualquier valor de columna mayor o igual lo especificado aquí pasará la validación. na_pass ¿Debería considerarse que los valores de NA encontrados pasan unidades de prueba? Esto es por defecto FALSE. Ajústelo en TRUE para darle un pase NA. preconditions Una expresión opcional para mutar la tabla de entrada antes de continuar con la validación. Esto se puede proporcionar como una fórmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una función (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la sección Preconditions para obtener más información. segments Una expresión opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la sección Segments para obtener más detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gte.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Los datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? — col_vals_gte","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gte.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¿Los datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? — col_vals_gte","text":"Si proporciona varios nombres de columna, el resultado será una expansión de pasos de validación para ese número de nombres de columna (por ejemplo, vars(col_a, col_b) dará lugar la entrada de dos pasos de validación). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares están disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gte.html","id":"valores-faltantes","dir":"Reference","previous_headings":"","what":"Valores faltantes","title":"¿Los datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? — col_vals_gte","text":"Esta función de validación admite el manejo especial de valores NA. El argumento na_pass determinará si un valor de NA que aparece en una unidad de prueba debe pasar o . El valor predeterminado de na_pass = FALSE significa que cualquier NA encontrado acumulará unidades de prueba fallidas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gte.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¿Los datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? — col_vals_gte","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesará la tabla de destino durante la interrogación como paso preparatorio. Puede suceder que una validación en particular requiera una columna calculada, algún filtrado de filas o la adición de columnas través de una combinación, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validación con una sola tabla de destino y realice ajustes menores en ella, según sea necesario, lo largo del camino. La mutación de la tabla está totalmente aislada en el alcance de los pasos de validación en los que se utilizan las preconditions. Aquí se sugiere usar el código dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El código se proporciona más fácilmente como una fórmula R unilateral (utilizando un ~ inicial). En la representación de la fórmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podría proporcionar una función (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gte.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¿Los datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? — col_vals_gte","text":"Al usar el argumento segments, es posible definir una validación particular con segmentos (o porciones de fila) de la tabla de destino. Una expresión opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresión que se puede utilizar, vars(a_column) segmentará la tabla de destino en la forma en que estén presentes muchos valores únicos en la columna llamada a_column. Esto es excelente si cada valor único en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validación repetida. Con una fórmula, podemos ser más selectivos con los valores de columna que se deben usar para la segmentación. El uso de a_column ~ c(\"group_1\", \"group_2\") intentará obtener dos segmentos donde uno es una porción de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la fórmula dará como resultado un paso de validación independiente. Si hay varias columns especificadas, el número potencial de pasos de validación será m columnas multiplicadas por n segmentos resueltos. La segmentación siempre ocurrirá después de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinación, es posible generar etiquetas para la segmentación usando una expresión para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versión separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gte.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Los datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? — col_vals_gte","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situación (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gte.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Los datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? — col_vals_gte","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gte.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Los datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? — col_vals_gte","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_vals_gte() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_vals_gte() como paso de validación se expresa en código R y en la representación YAML correspondiente. practice, often shorter columns value arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# Código R agent %>%    col_vals_gte(     columns = vars(a),     value = 1,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_gte()`.\",     active = FALSE   )  # Representación YAML steps: - col_vals_gte:     columns: vars(a)     value: 1.0     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_gte()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gte.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Los datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? — col_vals_gte","text":"2-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gte.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Los datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? — col_vals_gte","text":"","code":"# Para todos los ejemplos, # utilizaremos una tabla sencilla # con tres columnas numéricas # (`a`, `b` y `c`) y tres columnas # de caracteres (`d`, `e` y `f`) tbl <-   dplyr::tibble(       a = c(5, 5, 5, 5, 5, 5),       b = c(1, 1, 1, 2, 2, 2),       c = c(1, 1, 1, 2, 3, 4),       d = LETTERS[a],       e = LETTERS[b],       f = LETTERS[c]   )    tbl #> # A tibble: 6 × 6 #>       a     b     c d     e     f     #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 E     A     A     #> 2     5     1     1 E     A     A     #> 3     5     1     1 E     A     A     #> 4     5     2     2 E     B     B     #> 5     5     2     3 E     B     C     #> 6     5     2     4 E     B     D      # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Validate that values in column `a` # are all greater than or equal to the # value of `5` agent <-   create_agent(tbl) %>%   col_vals_gte(vars(a), 5) %>%   interrogate()  # Determine si esta validación no tuvo # unidades de prueba fallidas (hay 6 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` tbl %>%    col_vals_gte(vars(a), 5) %>%   dplyr::pull(a) #> [1] 5 5 5 5 5 5    # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_gte(tbl, vars(a), 5)  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto test_col_vals_gte(tbl, vars(a), 5) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_in_set.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Los datos de la columna forman parte de un conjunto de valores específico? — col_vals_in_set","title":"¿Los datos de la columna forman parte de un conjunto de valores específico? — col_vals_in_set","text":"La función de validación col_vals_in_set(), la función de expectativa expect_col_vals_in_set() y la función de prueba test_col_vals_in_set() comprueban si los valores de las columnas en una tabla son parte de un set de valores especificado. La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre el número de unidades de prueba que es igual al número de filas en la tabla (después de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_in_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Los datos de la columna forman parte de un conjunto de valores específico? — col_vals_in_set","text":"","code":"col_vals_in_set(   x,   columns,   set,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_in_set(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )  test_col_vals_in_set(object, columns, set, preconditions = NULL, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_in_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Los datos de la columna forman parte de un conjunto de valores específico? — col_vals_in_set","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. set vector numeric string-based elements, column values found within set considered passing. preconditions Una expresión opcional para mutar la tabla de entrada antes de continuar con la validación. Esto se puede proporcionar como una fórmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una función (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la sección Preconditions para obtener más información. segments Una expresión opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la sección Segments para obtener más detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_in_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Los datos de la columna forman parte de un conjunto de valores específico? — col_vals_in_set","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_in_set.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¿Los datos de la columna forman parte de un conjunto de valores específico? — col_vals_in_set","text":"Si proporciona varios nombres de columna, el resultado será una expansión de pasos de validación para ese número de nombres de columna (por ejemplo, vars(col_a, col_b) dará lugar la entrada de dos pasos de validación). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares están disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_in_set.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¿Los datos de la columna forman parte de un conjunto de valores específico? — col_vals_in_set","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesará la tabla de destino durante la interrogación como paso preparatorio. Puede suceder que una validación en particular requiera una columna calculada, algún filtrado de filas o la adición de columnas través de una combinación, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validación con una sola tabla de destino y realice ajustes menores en ella, según sea necesario, lo largo del camino. La mutación de la tabla está totalmente aislada en el alcance de los pasos de validación en los que se utilizan las preconditions. Aquí se sugiere usar el código dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El código se proporciona más fácilmente como una fórmula R unilateral (utilizando un ~ inicial). En la representación de la fórmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podría proporcionar una función (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_in_set.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¿Los datos de la columna forman parte de un conjunto de valores específico? — col_vals_in_set","text":"Al usar el argumento segments, es posible definir una validación particular con segmentos (o porciones de fila) de la tabla de destino. Una expresión opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresión que se puede utilizar, vars(a_column) segmentará la tabla de destino en la forma en que estén presentes muchos valores únicos en la columna llamada a_column. Esto es excelente si cada valor único en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validación repetida. Con una fórmula, podemos ser más selectivos con los valores de columna que se deben usar para la segmentación. El uso de a_column ~ c(\"group_1\", \"group_2\") intentará obtener dos segmentos donde uno es una porción de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la fórmula dará como resultado un paso de validación independiente. Si hay varias columns especificadas, el número potencial de pasos de validación será m columnas multiplicadas por n segmentos resueltos. La segmentación siempre ocurrirá después de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinación, es posible generar etiquetas para la segmentación usando una expresión para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versión separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_in_set.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Los datos de la columna forman parte de un conjunto de valores específico? — col_vals_in_set","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situación (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_in_set.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Los datos de la columna forman parte de un conjunto de valores específico? — col_vals_in_set","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_in_set.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Los datos de la columna forman parte de un conjunto de valores específico? — col_vals_in_set","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_vals_in_set() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_vals_in_set() como paso de validación se expresa en código R y en la representación YAML correspondiente. practice, often shorter columns, set arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# Código R agent %>%    col_vals_in_set(     columns = vars(a),     set = c(1, 2, 3, 4),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_in_set()`.\",     active = FALSE   )  # Representación YAML steps: - col_vals_in_set:     columns: vars(a)    set:    - 1.0    - 2.0    - 3.0    - 4.0    preconditions: ~. %>% dplyr::filter(a < 10)    segments: b ~ c(\"group_1\", \"group_2\")    actions:      warn_fraction: 0.1      stop_fraction: 0.2    label: El paso `col_vals_in_set()`.    active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_in_set.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Los datos de la columna forman parte de un conjunto de valores específico? — col_vals_in_set","text":"2-9","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_in_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Los datos de la columna forman parte de un conjunto de valores específico? — col_vals_in_set","text":"","code":"# La tabla `small_table` del paquete # se utilizará para validar que los # valores de las columnas forman # parte de un conjunto determinado  # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Validar que los valores de la # columna `f` forman parte del # conjunto de valores que contienen # `low`, `mid` y `high` agent <-   create_agent(small_table) %>%   col_vals_in_set(     vars(f), c(\"low\", \"mid\", \"high\")   ) %>%   interrogate()    # Determine si esta validación no tuvo # unidades de prueba fallidas (hay 13 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` small_table %>%   col_vals_in_set(     vars(f), c(\"low\", \"mid\", \"high\")   ) %>%   dplyr::pull(f) %>%   unique() #> [1] \"high\" \"low\"  \"mid\"   # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_in_set(   small_table,   vars(f), c(\"low\", \"mid\", \"high\") )  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto small_table %>%   test_col_vals_in_set(     vars(f), c(\"low\", \"mid\", \"high\")   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_increasing.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Los datos de la columna aumentan por fila? — col_vals_increasing","title":"¿Los datos de la columna aumentan por fila? — col_vals_increasing","text":"La función de validación col_vals_increasing(), la función de expectativa expect_col_vals_increasing() y la función de prueba test_col_vals_increasing() comprueban si los valores de las columnas en una tabla están aumentando cuando se mueve hacia abajo en una tabla. Hay opciones para permitir valores NA en la columna de destino, permitir fases estacionarias (donde los valores consecutivos cambian), e incluso para permitir movimientos decrecientes hasta un cierto umbral. La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre el número de unidades de prueba que es igual al número de filas en la tabla (después de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_increasing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Los datos de la columna aumentan por fila? — col_vals_increasing","text":"","code":"col_vals_increasing(   x,   columns,   allow_stationary = FALSE,   decreasing_tol = NULL,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_increasing(   object,   columns,   allow_stationary = FALSE,   decreasing_tol = NULL,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_increasing(   object,   columns,   allow_stationary = FALSE,   decreasing_tol = NULL,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_increasing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Los datos de la columna aumentan por fila? — col_vals_increasing","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. allow_stationary option allow pauses decreasing values. example values test units [80, 82, 82, 85, 88] third unit (82, appearing second time) marked fail allow_stationary FALSE (default). Using allow_stationary = TRUE result test units [80, 82, 82, 85, 88] marked pass. decreasing_tol optional threshold value allows movement numerical values negative direction. default NULL using numerical value set absolute threshold negative travel allowed across numerical test units. Note setting value also effect setting allow_stationary TRUE. na_pass ¿Debería considerarse que los valores de NA encontrados pasan unidades de prueba? Esto es por defecto FALSE. Ajústelo en TRUE para darle un pase NA. preconditions Una expresión opcional para mutar la tabla de entrada antes de continuar con la validación. Esto se puede proporcionar como una fórmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una función (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la sección Preconditions para obtener más información. segments Una expresión opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la sección Segments para obtener más detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_increasing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Los datos de la columna aumentan por fila? — col_vals_increasing","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_increasing.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¿Los datos de la columna aumentan por fila? — col_vals_increasing","text":"Si proporciona varios nombres de columna, el resultado será una expansión de pasos de validación para ese número de nombres de columna (por ejemplo, vars(col_a, col_b) dará lugar la entrada de dos pasos de validación). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares están disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_increasing.html","id":"valores-faltantes","dir":"Reference","previous_headings":"","what":"Valores faltantes","title":"¿Los datos de la columna aumentan por fila? — col_vals_increasing","text":"Esta función de validación admite el manejo especial de valores NA. El argumento na_pass determinará si un valor de NA que aparece en una unidad de prueba debe pasar o . El valor predeterminado de na_pass = FALSE significa que cualquier NA encontrado acumulará unidades de prueba fallidas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_increasing.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¿Los datos de la columna aumentan por fila? — col_vals_increasing","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesará la tabla de destino durante la interrogación como paso preparatorio. Puede suceder que una validación en particular requiera una columna calculada, algún filtrado de filas o la adición de columnas través de una combinación, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validación con una sola tabla de destino y realice ajustes menores en ella, según sea necesario, lo largo del camino. La mutación de la tabla está totalmente aislada en el alcance de los pasos de validación en los que se utilizan las preconditions. Aquí se sugiere usar el código dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El código se proporciona más fácilmente como una fórmula R unilateral (utilizando un ~ inicial). En la representación de la fórmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podría proporcionar una función (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_increasing.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¿Los datos de la columna aumentan por fila? — col_vals_increasing","text":"Al usar el argumento segments, es posible definir una validación particular con segmentos (o porciones de fila) de la tabla de destino. Una expresión opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresión que se puede utilizar, vars(a_column) segmentará la tabla de destino en la forma en que estén presentes muchos valores únicos en la columna llamada a_column. Esto es excelente si cada valor único en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validación repetida. Con una fórmula, podemos ser más selectivos con los valores de columna que se deben usar para la segmentación. El uso de a_column ~ c(\"group_1\", \"group_2\") intentará obtener dos segmentos donde uno es una porción de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la fórmula dará como resultado un paso de validación independiente. Si hay varias columns especificadas, el número potencial de pasos de validación será m columnas multiplicadas por n segmentos resueltos. La segmentación siempre ocurrirá después de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinación, es posible generar etiquetas para la segmentación usando una expresión para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versión separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_increasing.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Los datos de la columna aumentan por fila? — col_vals_increasing","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situación (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_increasing.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Los datos de la columna aumentan por fila? — col_vals_increasing","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_increasing.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Los datos de la columna aumentan por fila? — col_vals_increasing","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_vals_increasing() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_vals_increasing() como paso de validación se expresa en código R y en la representación YAML correspondiente. En la práctica, ambos serán menudo más cortos, ya que solo el argumento de las columns requiere un valor. Los argumentos con valores predeterminados se escribirán en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). También es posible obtener una vista previa de la transformación de un agente YAML sin escribir en el disco usando la función yaml_agent_string().","code":"# Código R agent %>%    col_vals_increasing(     columns = vars(a),     allow_stationary = TRUE,     decreasing_tol = 0.5,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_increasing()`.\",     active = FALSE   )  # Representación YAML steps: - col_vals_increasing:     columns: vars(a)     allow_stationary: true     decreasing_tol: 0.5     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_increasing()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_increasing.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Los datos de la columna aumentan por fila? — col_vals_increasing","text":"2-13","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lt.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Los datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? — col_vals_lt","title":"¿Los datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? — col_vals_lt","text":"La función de validación col_vals_lt(), la función de expectativa expect_col_vals_lt() y la función de prueba test_col_vals_lt() comprueban si los valores de las columnas en una tabla son menores que un value especificado (la comparación exacta utilizada en esta función es col_val < value). El value se puede especificar como un valor literal único o como un nombre de columna dado en vars(). La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre el número de unidades de prueba que es igual al número de filas en la tabla (después de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Los datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? — col_vals_lt","text":"","code":"col_vals_lt(   x,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_lt(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_lt(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Los datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? — col_vals_lt","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. value value used comparison. can single value compatible column given vars(). column values less specified pass validation. na_pass ¿Debería considerarse que los valores de NA encontrados pasan unidades de prueba? Esto es por defecto FALSE. Ajústelo en TRUE para darle un pase NA. preconditions Una expresión opcional para mutar la tabla de entrada antes de continuar con la validación. Esto se puede proporcionar como una fórmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una función (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la sección Preconditions para obtener más información. segments Una expresión opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la sección Segments para obtener más detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Los datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? — col_vals_lt","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lt.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¿Los datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? — col_vals_lt","text":"Si proporciona varios nombres de columna, el resultado será una expansión de pasos de validación para ese número de nombres de columna (por ejemplo, vars(col_a, col_b) dará lugar la entrada de dos pasos de validación). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares están disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lt.html","id":"valores-faltantes","dir":"Reference","previous_headings":"","what":"Valores faltantes","title":"¿Los datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? — col_vals_lt","text":"Esta función de validación admite el manejo especial de valores NA. El argumento na_pass determinará si un valor de NA que aparece en una unidad de prueba debe pasar o . El valor predeterminado de na_pass = FALSE significa que cualquier NA encontrado acumulará unidades de prueba fallidas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lt.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¿Los datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? — col_vals_lt","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesará la tabla de destino durante la interrogación como paso preparatorio. Puede suceder que una validación en particular requiera una columna calculada, algún filtrado de filas o la adición de columnas través de una combinación, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validación con una sola tabla de destino y realice ajustes menores en ella, según sea necesario, lo largo del camino. La mutación de la tabla está totalmente aislada en el alcance de los pasos de validación en los que se utilizan las preconditions. Aquí se sugiere usar el código dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El código se proporciona más fácilmente como una fórmula R unilateral (utilizando un ~ inicial). En la representación de la fórmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podría proporcionar una función (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lt.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¿Los datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? — col_vals_lt","text":"Al usar el argumento segments, es posible definir una validación particular con segmentos (o porciones de fila) de la tabla de destino. Una expresión opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresión que se puede utilizar, vars(a_column) segmentará la tabla de destino en la forma en que estén presentes muchos valores únicos en la columna llamada a_column. Esto es excelente si cada valor único en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validación repetida. Con una fórmula, podemos ser más selectivos con los valores de columna que se deben usar para la segmentación. El uso de a_column ~ c(\"group_1\", \"group_2\") intentará obtener dos segmentos donde uno es una porción de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la fórmula dará como resultado un paso de validación independiente. Si hay varias columns especificadas, el número potencial de pasos de validación será m columnas multiplicadas por n segmentos resueltos. La segmentación siempre ocurrirá después de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinación, es posible generar etiquetas para la segmentación usando una expresión para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versión separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lt.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Los datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? — col_vals_lt","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situación (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lt.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Los datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? — col_vals_lt","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lt.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Los datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? — col_vals_lt","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_vals_lt() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_vals_lt() como paso de validación se expresa en código R y en la representación YAML correspondiente. practice, often shorter columns value arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# Código R agent %>%    col_vals_lt(     columns = vars(a),     value = 1,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_lt()`.\",     active = FALSE   )  # Representación YAML steps: - col_vals_lt:     columns: vars(a)     value: 1.0     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_lt()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lt.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Los datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? — col_vals_lt","text":"2-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Los datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? — col_vals_lt","text":"","code":"# Para todos los ejemplos, utilizaremos # una tabla sencilla con tres columnas # numéricas (`a`, `b` y `c`) y tres # columnas de caracteres (`d`, `e` # y `f`) tbl <-   dplyr::tibble(       a = c(5, 5, 5, 5, 5, 5),       b = c(1, 1, 1, 2, 2, 2),       c = c(1, 1, 1, 2, 3, 4),       d = LETTERS[a],       e = LETTERS[b],       f = LETTERS[c]   )    tbl #> # A tibble: 6 × 6 #>       a     b     c d     e     f     #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 E     A     A     #> 2     5     1     1 E     A     A     #> 3     5     1     1 E     A     A     #> 4     5     2     2 E     B     B     #> 5     5     2     3 E     B     C     #> 6     5     2     4 E     B     D      # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Valida que los valores de la columna # `c` son todos menores que el valor # de `5`. agent <-   create_agent(tbl) %>%   col_vals_lt(vars(c), 5) %>%   interrogate()  # Determine si esta validación no tuvo # unidades de prueba fallidas (hay 6 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` tbl %>%    col_vals_lt(vars(c), 5) %>%   dplyr::pull(c) #> [1] 1 1 1 2 3 4    # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_lt(tbl, vars(c), 5)  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto test_col_vals_lt(tbl, vars(c), 5) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lte.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Los datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? — col_vals_lte","title":"¿Los datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? — col_vals_lte","text":"La función de validación col_vals_lte(), la función de expectativa expect_col_vals_lte() y la función de prueba test_col_vals_lte() comprueban si los valores de las columnas en una tabla son menores o iguales un value especificado (la comparación exacta utilizada en esta función es col_val < value). El value se puede especificar como un valor literal único o como un nombre de columna dado en vars(). La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre el número de unidades de prueba que es igual al número de filas en la tabla (después de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lte.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Los datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? — col_vals_lte","text":"","code":"col_vals_lte(   x,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_lte(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_lte(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lte.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Los datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? — col_vals_lte","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. value value used comparison. can single value compatible column given vars(). column values less equal specified pass validation. na_pass ¿Debería considerarse que los valores de NA encontrados pasan unidades de prueba? Esto es por defecto FALSE. Ajústelo en TRUE para darle un pase NA. preconditions Una expresión opcional para mutar la tabla de entrada antes de continuar con la validación. Esto se puede proporcionar como una fórmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una función (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la sección Preconditions para obtener más información. segments Una expresión opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la sección Segments para obtener más detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lte.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Los datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? — col_vals_lte","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lte.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¿Los datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? — col_vals_lte","text":"Si proporciona varios nombres de columna, el resultado será una expansión de pasos de validación para ese número de nombres de columna (por ejemplo, vars(col_a, col_b) dará lugar la entrada de dos pasos de validación). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares están disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lte.html","id":"valores-faltantes","dir":"Reference","previous_headings":"","what":"Valores faltantes","title":"¿Los datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? — col_vals_lte","text":"Esta función de validación admite el manejo especial de valores NA. El argumento na_pass determinará si un valor de NA que aparece en una unidad de prueba debe pasar o . El valor predeterminado de na_pass = FALSE significa que cualquier NA encontrado acumulará unidades de prueba fallidas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lte.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¿Los datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? — col_vals_lte","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesará la tabla de destino durante la interrogación como paso preparatorio. Puede suceder que una validación en particular requiera una columna calculada, algún filtrado de filas o la adición de columnas través de una combinación, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validación con una sola tabla de destino y realice ajustes menores en ella, según sea necesario, lo largo del camino. La mutación de la tabla está totalmente aislada en el alcance de los pasos de validación en los que se utilizan las preconditions. Aquí se sugiere usar el código dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El código se proporciona más fácilmente como una fórmula R unilateral (utilizando un ~ inicial). En la representación de la fórmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podría proporcionar una función (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lte.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¿Los datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? — col_vals_lte","text":"Al usar el argumento segments, es posible definir una validación particular con segmentos (o porciones de fila) de la tabla de destino. Una expresión opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresión que se puede utilizar, vars(a_column) segmentará la tabla de destino en la forma en que estén presentes muchos valores únicos en la columna llamada a_column. Esto es excelente si cada valor único en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validación repetida. Con una fórmula, podemos ser más selectivos con los valores de columna que se deben usar para la segmentación. El uso de a_column ~ c(\"group_1\", \"group_2\") intentará obtener dos segmentos donde uno es una porción de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la fórmula dará como resultado un paso de validación independiente. Si hay varias columns especificadas, el número potencial de pasos de validación será m columnas multiplicadas por n segmentos resueltos. La segmentación siempre ocurrirá después de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinación, es posible generar etiquetas para la segmentación usando una expresión para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versión separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lte.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Los datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? — col_vals_lte","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situación (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lte.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Los datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? — col_vals_lte","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lte.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Los datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? — col_vals_lte","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_vals_lte() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_vals_lte() como paso de validación se expresa en código R y en la representación YAML correspondiente. practice, often shorter columns value arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# Código R agent %>%    col_vals_lte(     columns = vars(a),     value = 1,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_lte()`.\",     active = FALSE   )  # Representación YAML steps: - col_vals_lte:     columns: vars(a)     value: 1.0     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_lte()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lte.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Los datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? — col_vals_lte","text":"2-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lte.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Los datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? — col_vals_lte","text":"","code":"# Para todos los ejemplos, utilizaremos # una tabla sencilla con tres columnas # numéricas (`a`, `b` y `c`) y tres # columnas de caracteres (`d`, `e` # y `f`) tbl <-   dplyr::tibble(       a = c(5, 5, 5, 5, 5, 5),       b = c(1, 1, 1, 2, 2, 2),       c = c(1, 1, 1, 2, 3, 4),       d = LETTERS[a],       e = LETTERS[b],       f = LETTERS[c]   )    tbl #> # A tibble: 6 × 6 #>       a     b     c d     e     f     #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 E     A     A     #> 2     5     1     1 E     A     A     #> 3     5     1     1 E     A     A     #> 4     5     2     2 E     B     B     #> 5     5     2     3 E     B     C     #> 6     5     2     4 E     B     D      # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Validate that values in column `c` # are all less than or equal to the # value of `4` agent <-   create_agent(tbl) %>%   col_vals_lte(vars(c), 4) %>%   interrogate()  # Determine si esta validación no tuvo # unidades de prueba fallidas (hay 6 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` tbl %>%    col_vals_lte(vars(c), 4) %>%   dplyr::pull(c) #> [1] 1 1 1 2 3 4    # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_lte(tbl, vars(c), 4)  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto test_col_vals_lte(tbl, vars(c), 4) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_set.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Un conjunto de valores se tiene en cuenta por completo en una columna de\nvalores? — col_vals_make_set","title":"¿Un conjunto de valores se tiene en cuenta por completo en una columna de\nvalores? — col_vals_make_set","text":"La función de validación col_vals_make_set(), la función de expectativa expect_col_vals_make_set() y la función de prueba test_col_vals_make_set() comprueban si los valores de set se ven al menos una vez en una columna de la tabla. Un criterio necesario aquí es que se deben ver valores adicionales (fuera de los definidos en el set) (este requisito se relaja en la función de validación col_vals_make_subset() y en sus variantes de expectativa y prueba). La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). validation step expectation operate number test units equal number elements set plus test unit reserved detecting column values outside set (outside value seen make additional test unit fail).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Un conjunto de valores se tiene en cuenta por completo en una columna de\nvalores? — col_vals_make_set","text":"","code":"col_vals_make_set(   x,   columns,   set,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_make_set(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )  test_col_vals_make_set(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Un conjunto de valores se tiene en cuenta por completo en una columna de\nvalores? — col_vals_make_set","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. set vector elements expected equal set unique values target column. preconditions Una expresión opcional para mutar la tabla de entrada antes de continuar con la validación. Esto se puede proporcionar como una fórmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una función (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la sección Preconditions para obtener más información. segments Una expresión opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la sección Segments para obtener más detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Un conjunto de valores se tiene en cuenta por completo en una columna de\nvalores? — col_vals_make_set","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_set.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¿Un conjunto de valores se tiene en cuenta por completo en una columna de\nvalores? — col_vals_make_set","text":"Si proporciona varios nombres de columna, el resultado será una expansión de pasos de validación para ese número de nombres de columna (por ejemplo, vars(col_a, col_b) dará lugar la entrada de dos pasos de validación). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares están disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_set.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¿Un conjunto de valores se tiene en cuenta por completo en una columna de\nvalores? — col_vals_make_set","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesará la tabla de destino durante la interrogación como paso preparatorio. Puede suceder que una validación en particular requiera una columna calculada, algún filtrado de filas o la adición de columnas través de una combinación, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validación con una sola tabla de destino y realice ajustes menores en ella, según sea necesario, lo largo del camino. La mutación de la tabla está totalmente aislada en el alcance de los pasos de validación en los que se utilizan las preconditions. Aquí se sugiere usar el código dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El código se proporciona más fácilmente como una fórmula R unilateral (utilizando un ~ inicial). En la representación de la fórmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podría proporcionar una función (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_set.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¿Un conjunto de valores se tiene en cuenta por completo en una columna de\nvalores? — col_vals_make_set","text":"Al usar el argumento segments, es posible definir una validación particular con segmentos (o porciones de fila) de la tabla de destino. Una expresión opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresión que se puede utilizar, vars(a_column) segmentará la tabla de destino en la forma en que estén presentes muchos valores únicos en la columna llamada a_column. Esto es excelente si cada valor único en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validación repetida. Con una fórmula, podemos ser más selectivos con los valores de columna que se deben usar para la segmentación. El uso de a_column ~ c(\"group_1\", \"group_2\") intentará obtener dos segmentos donde uno es una porción de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la fórmula dará como resultado un paso de validación independiente. Si hay varias columns especificadas, el número potencial de pasos de validación será m columnas multiplicadas por n segmentos resueltos. La segmentación siempre ocurrirá después de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinación, es posible generar etiquetas para la segmentación usando una expresión para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versión separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_set.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Un conjunto de valores se tiene en cuenta por completo en una columna de\nvalores? — col_vals_make_set","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situación (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_set.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Un conjunto de valores se tiene en cuenta por completo en una columna de\nvalores? — col_vals_make_set","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_set.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Un conjunto de valores se tiene en cuenta por completo en una columna de\nvalores? — col_vals_make_set","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_vals_make_set() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_vals_make_set() como paso de validación se expresa en código R y en la representación YAML correspondiente. practice, often shorter columns, set arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# Código R agent %>%    col_vals_make_set(     columns = vars(a),     set = c(1, 2, 3, 4),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_make_set()`.\",     active = FALSE   )  # Representación YAML steps: - col_vals_make_set:     columns: vars(a)    set:    - 1.0    - 2.0    - 3.0    - 4.0    preconditions: ~. %>% dplyr::filter(a < 10)    segments: b ~ c(\"group_1\", \"group_2\")    actions:      warn_fraction: 0.1      stop_fraction: 0.2    label: El paso `col_vals_make_set()`.    active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_set.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Un conjunto de valores se tiene en cuenta por completo en una columna de\nvalores? — col_vals_make_set","text":"2-11","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Un conjunto de valores se tiene en cuenta por completo en una columna de\nvalores? — col_vals_make_set","text":"","code":"# The `small_table` dataset in the # package will be used to validate that # column values are part of a given set  # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Validate that values in column `f` # comprise the values of `low`, `mid`, # and `high`, and, no other values agent <-   create_agent(small_table) %>%   col_vals_make_set(     vars(f), c(\"low\", \"mid\", \"high\")   ) %>%   interrogate()    # Determine si esta validación no tuvo # unidades de prueba fallidas (hay 4 # unidades de prueba) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` small_table %>%   col_vals_make_set(     vars(f), c(\"low\", \"mid\", \"high\")   ) %>%   dplyr::pull(f) %>%   unique() #> [1] \"high\" \"low\"  \"mid\"   # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_make_set(   small_table,   vars(f), c(\"low\", \"mid\", \"high\") )  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto small_table %>%   test_col_vals_make_set(     vars(f), c(\"low\", \"mid\", \"high\")   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_subset.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Es un conjunto de valores un subconjunto de una columna de valores? — col_vals_make_subset","title":"¿Es un conjunto de valores un subconjunto de una columna de valores? — col_vals_make_subset","text":"La función de validación col_vals_make_subset(), la función de expectativa expect_col_vals_make_subset() y la función de prueba test_col_vals_make_subset() comprueban si todos los valores de set se ven al menos una vez en una columna de tabla. La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre el número de unidades de prueba que es igual al número de elementos en el set.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_subset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Es un conjunto de valores un subconjunto de una columna de valores? — col_vals_make_subset","text":"","code":"col_vals_make_subset(   x,   columns,   set,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_make_subset(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )  test_col_vals_make_subset(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_subset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Es un conjunto de valores un subconjunto de una columna de valores? — col_vals_make_subset","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. set vector elements expected subset unique values target column. preconditions Una expresión opcional para mutar la tabla de entrada antes de continuar con la validación. Esto se puede proporcionar como una fórmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una función (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la sección Preconditions para obtener más información. segments Una expresión opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la sección Segments para obtener más detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_subset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Es un conjunto de valores un subconjunto de una columna de valores? — col_vals_make_subset","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_subset.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¿Es un conjunto de valores un subconjunto de una columna de valores? — col_vals_make_subset","text":"Si proporciona varios nombres de columna, el resultado será una expansión de pasos de validación para ese número de nombres de columna (por ejemplo, vars(col_a, col_b) dará lugar la entrada de dos pasos de validación). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares están disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_subset.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¿Es un conjunto de valores un subconjunto de una columna de valores? — col_vals_make_subset","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesará la tabla de destino durante la interrogación como paso preparatorio. Puede suceder que una validación en particular requiera una columna calculada, algún filtrado de filas o la adición de columnas través de una combinación, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validación con una sola tabla de destino y realice ajustes menores en ella, según sea necesario, lo largo del camino. La mutación de la tabla está totalmente aislada en el alcance de los pasos de validación en los que se utilizan las preconditions. Aquí se sugiere usar el código dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El código se proporciona más fácilmente como una fórmula R unilateral (utilizando un ~ inicial). En la representación de la fórmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podría proporcionar una función (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_subset.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¿Es un conjunto de valores un subconjunto de una columna de valores? — col_vals_make_subset","text":"Al usar el argumento segments, es posible definir una validación particular con segmentos (o porciones de fila) de la tabla de destino. Una expresión opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresión que se puede utilizar, vars(a_column) segmentará la tabla de destino en la forma en que estén presentes muchos valores únicos en la columna llamada a_column. Esto es excelente si cada valor único en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validación repetida. Con una fórmula, podemos ser más selectivos con los valores de columna que se deben usar para la segmentación. El uso de a_column ~ c(\"group_1\", \"group_2\") intentará obtener dos segmentos donde uno es una porción de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la fórmula dará como resultado un paso de validación independiente. Si hay varias columns especificadas, el número potencial de pasos de validación será m columnas multiplicadas por n segmentos resueltos. La segmentación siempre ocurrirá después de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinación, es posible generar etiquetas para la segmentación usando una expresión para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versión separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_subset.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Es un conjunto de valores un subconjunto de una columna de valores? — col_vals_make_subset","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situación (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_subset.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Es un conjunto de valores un subconjunto de una columna de valores? — col_vals_make_subset","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_subset.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Es un conjunto de valores un subconjunto de una columna de valores? — col_vals_make_subset","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_vals_make_subset() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_vals_make_subset() como paso de validación se expresa en código R y en la representación YAML correspondiente. practice, often shorter columns, set arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# Código R agent %>%    col_vals_make_subset(     columns = vars(a),     set = c(1, 2, 3, 4),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_make_subset()`.\",     active = FALSE   )  # Representación YAML steps: - col_vals_make_subset:     columns: vars(a)    set:    - 1.0    - 2.0    - 3.0    - 4.0    preconditions: ~. %>% dplyr::filter(a < 10)    segments: b ~ c(\"group_1\", \"group_2\")    actions:      warn_fraction: 0.1      stop_fraction: 0.2    label: El paso `col_vals_make_subset()`.    active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_subset.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Es un conjunto de valores un subconjunto de una columna de valores? — col_vals_make_subset","text":"2-12","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_subset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Es un conjunto de valores un subconjunto de una columna de valores? — col_vals_make_subset","text":"","code":"# The `small_table` dataset in the # package will be used to validate that # column values are part of a given set  # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Validate that the distinct set of values # in column `f` contains at least the # subset defined as `low` and `high` (the # column actually has both of those and # some `mid` values) agent <-   create_agent(small_table) %>%   col_vals_make_subset(     vars(f), c(\"low\", \"high\")   ) %>%   interrogate()    # Determine if this validation # had no failing test units (there # are 2 test units, one per element # in the `set`) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` small_table %>%   col_vals_make_subset(     vars(f), c(\"low\", \"high\")   ) %>%   dplyr::pull(f) %>%   unique() #> [1] \"high\" \"low\"  \"mid\"   # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_make_subset(   small_table,   vars(f), c(\"low\", \"high\") )  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto small_table %>%   test_col_vals_make_subset(     vars(f), c(\"low\", \"high\")   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_between.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Los datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? — col_vals_not_between","title":"¿Los datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? — col_vals_not_between","text":"La función de validación col_vals_not_between(), la función de expectativa expect_col_vals_not_between() y la función de prueba test_col_vals_not_between() comprueban si los valores de las columnas en una tabla caen dentro de un rango. El rango especificado con tres argumentos: left, right e inclusive. Los valores left y right especifican los límites superior e inferior. Los límites se pueden especificar como valores literales simples o como nombres de columna dados en vars(). El argumento inclusive, como un vector de dos valores lógicos relacionados con left y right, establece si cada límite es inclusivo o . El valor predeterminado es c(TRUE, TRUE), donde ambos extremos son inclusivos (es decir, [izquierda, derecha]). Para versiones parcialmente ilimitadas de esta función, podemos usar las funciones de validación col_vals_lt(), col_vals_lte(), col_vals_gt() o col_vals_gte(). La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre el número de unidades de prueba que es igual al número de filas en la tabla (después de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_between.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Los datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? — col_vals_not_between","text":"","code":"col_vals_not_between(   x,   columns,   left,   right,   inclusive = c(TRUE, TRUE),   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_not_between(   object,   columns,   left,   right,   inclusive = c(TRUE, TRUE),   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_not_between(   object,   columns,   left,   right,   inclusive = c(TRUE, TRUE),   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_between.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Los datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? — col_vals_not_between","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. left, right Los valores límite inferior (o izquierdo) y superior (o derecho) del rango. Pueden expresarse como valores individuales, columnas compatibles dadas en vars(), o una combinación de ambos. Por defecto, cualquier valor de columna mayor o igual que left y menor o igual que right fallará la validación. La inclusividad de los límites puede ser modificada por la opción inclusive. inclusive Un valor lógico de dos elementos que indica si los límites left y right deben ser inclusivos. De forma predeterminada, ambos límites son inclusivos. na_pass ¿Debería considerarse que los valores de NA encontrados pasan unidades de prueba? Esto es por defecto FALSE. Ajústelo en TRUE para darle un pase NA. preconditions Una expresión opcional para mutar la tabla de entrada antes de continuar con la validación. Esto se puede proporcionar como una fórmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una función (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la sección Preconditions para obtener más información. segments Una expresión opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la sección Segments para obtener más detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_between.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Los datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? — col_vals_not_between","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_between.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¿Los datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? — col_vals_not_between","text":"Si proporciona varios nombres de columna, el resultado será una expansión de pasos de validación para ese número de nombres de columna (por ejemplo, vars(col_a, col_b) dará lugar la entrada de dos pasos de validación). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares están disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_between.html","id":"valores-faltantes","dir":"Reference","previous_headings":"","what":"Valores faltantes","title":"¿Los datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? — col_vals_not_between","text":"Esta función de validación admite el manejo especial de valores NA. El argumento na_pass determinará si un valor de NA que aparece en una unidad de prueba debe pasar o . El valor predeterminado de na_pass = FALSE significa que cualquier NA encontrado acumulará unidades de prueba fallidas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_between.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¿Los datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? — col_vals_not_between","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesará la tabla de destino durante la interrogación como paso preparatorio. Puede suceder que una validación en particular requiera una columna calculada, algún filtrado de filas o la adición de columnas través de una combinación, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validación con una sola tabla de destino y realice ajustes menores en ella, según sea necesario, lo largo del camino. La mutación de la tabla está totalmente aislada en el alcance de los pasos de validación en los que se utilizan las preconditions. Aquí se sugiere usar el código dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El código se proporciona más fácilmente como una fórmula R unilateral (utilizando un ~ inicial). En la representación de la fórmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podría proporcionar una función (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_between.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¿Los datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? — col_vals_not_between","text":"Al usar el argumento segments, es posible definir una validación particular con segmentos (o porciones de fila) de la tabla de destino. Una expresión opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresión que se puede utilizar, vars(a_column) segmentará la tabla de destino en la forma en que estén presentes muchos valores únicos en la columna llamada a_column. Esto es excelente si cada valor único en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validación repetida. Con una fórmula, podemos ser más selectivos con los valores de columna que se deben usar para la segmentación. El uso de a_column ~ c(\"group_1\", \"group_2\") intentará obtener dos segmentos donde uno es una porción de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la fórmula dará como resultado un paso de validación independiente. Si hay varias columns especificadas, el número potencial de pasos de validación será m columnas multiplicadas por n segmentos resueltos. La segmentación siempre ocurrirá después de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinación, es posible generar etiquetas para la segmentación usando una expresión para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versión separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_between.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Los datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? — col_vals_not_between","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situación (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_between.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Los datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? — col_vals_not_between","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_between.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Los datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? — col_vals_not_between","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_vals_not_between() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_vals_not_between() como paso de validación se expresa en código R y en la representación YAML correspondiente. practice, often shorter columns, left, right arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# Código R agent %>%    col_vals_not_between(     columns = vars(a),     left = 1,     right = 2,     inclusive = c(TRUE, FALSE),     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_not_between()`.\",     active = FALSE   )  # Representación YAML steps: - col_vals_not_between:     columns: vars(a)     left: 1.0     right: 2.0     inclusive:     - true     - false     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_not_between()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_between.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Los datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? — col_vals_not_between","text":"2-8","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_between.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Los datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? — col_vals_not_between","text":"","code":"# La tabla `small_table` del paquete # tiene una columna de valores # numéricos en `c` (hay algunos `NA` # en esa columna); los siguientes # ejemplos validarán los valores de # esa columna numérica  # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Valida que los valores de la # columna `c` estén todos entre `10` # y `20`; como hay valores `NA`, # elegiremos que pasen la validación # poniendo `na_pass = TRUE`. agent <-   create_agent(small_table) %>%   col_vals_not_between(     vars(c), 10, 20, na_pass = TRUE   ) %>%   interrogate()    # Determine si esta validación no tuvo # unidades de prueba fallidas (hay 13 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` small_table %>%   col_vals_not_between(     vars(c), 10, 20, na_pass = TRUE   ) %>%   dplyr::pull(c) #>  [1]  3  8  3 NA  7  4  3  2  9  9  7  8 NA  # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_not_between(   small_table, vars(c), 10, 20,   na_pass = TRUE )  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto small_table %>%   test_col_vals_not_between(     vars(c), 10, 20,     na_pass = TRUE   ) #> [1] TRUE  # Una nota adicional sobre los límites # de esta función: son inclusivos por # defecto; podemos modificar la # inclusividad de los límites superior # e inferior con la opción `inclusive`, # que es un vector lógico de longitud 2  # Al cambiar el límite inferior para # que sea `9` y hacerlo no inclusivo, # obtenemos `TRUE` ya que aunque dos # valores son `9` y quedan fuera del # límite inferior (o izquierdo) (y # cualquier valor `no entre` cuenta # como unidades de prueba que pasan) small_table %>%   test_col_vals_not_between(     vars(c), 9, 20,     inclusive = c(FALSE, TRUE),     na_pass = TRUE   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_equal.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Los datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_not_equal","title":"¿Los datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_not_equal","text":"La función de validación col_vals_not_equal(), la función de expectativa expect_col_vals_not_equal() y la función de prueba test_col_vals_not_equal() comprueban si los valores de las columnas en una tabla son iguales un value especificado. La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre el número de unidades de prueba que es igual al número de filas en la tabla (después de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_equal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Los datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_not_equal","text":"","code":"col_vals_not_equal(   x,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_not_equal(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_not_equal(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_equal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Los datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_not_equal","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. value value used test inequality. can single value compatible column given vars(). column values equal specified pass validation. na_pass ¿Debería considerarse que los valores de NA encontrados pasan unidades de prueba? Esto es por defecto FALSE. Ajústelo en TRUE para darle un pase NA. preconditions Una expresión opcional para mutar la tabla de entrada antes de continuar con la validación. Esto se puede proporcionar como una fórmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una función (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la sección Preconditions para obtener más información. segments Una expresión opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la sección Segments para obtener más detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_equal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Los datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_not_equal","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_equal.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¿Los datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_not_equal","text":"Si proporciona varios nombres de columna, el resultado será una expansión de pasos de validación para ese número de nombres de columna (por ejemplo, vars(col_a, col_b) dará lugar la entrada de dos pasos de validación). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares están disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_equal.html","id":"valores-faltantes","dir":"Reference","previous_headings":"","what":"Valores faltantes","title":"¿Los datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_not_equal","text":"Esta función de validación admite el manejo especial de valores NA. El argumento na_pass determinará si un valor de NA que aparece en una unidad de prueba debe pasar o . El valor predeterminado de na_pass = FALSE significa que cualquier NA encontrado acumulará unidades de prueba fallidas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_equal.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¿Los datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_not_equal","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesará la tabla de destino durante la interrogación como paso preparatorio. Puede suceder que una validación en particular requiera una columna calculada, algún filtrado de filas o la adición de columnas través de una combinación, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validación con una sola tabla de destino y realice ajustes menores en ella, según sea necesario, lo largo del camino. La mutación de la tabla está totalmente aislada en el alcance de los pasos de validación en los que se utilizan las preconditions. Aquí se sugiere usar el código dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El código se proporciona más fácilmente como una fórmula R unilateral (utilizando un ~ inicial). En la representación de la fórmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podría proporcionar una función (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_equal.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¿Los datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_not_equal","text":"Al usar el argumento segments, es posible definir una validación particular con segmentos (o porciones de fila) de la tabla de destino. Una expresión opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresión que se puede utilizar, vars(a_column) segmentará la tabla de destino en la forma en que estén presentes muchos valores únicos en la columna llamada a_column. Esto es excelente si cada valor único en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validación repetida. Con una fórmula, podemos ser más selectivos con los valores de columna que se deben usar para la segmentación. El uso de a_column ~ c(\"group_1\", \"group_2\") intentará obtener dos segmentos donde uno es una porción de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la fórmula dará como resultado un paso de validación independiente. Si hay varias columns especificadas, el número potencial de pasos de validación será m columnas multiplicadas por n segmentos resueltos. La segmentación siempre ocurrirá después de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinación, es posible generar etiquetas para la segmentación usando una expresión para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versión separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_equal.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Los datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_not_equal","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situación (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_equal.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Los datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_not_equal","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_equal.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Los datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_not_equal","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_vals_not_equal() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_vals_not_equal() como paso de validación se expresa en código R y en la representación YAML correspondiente. practice, often shorter columns value arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# Código R agent %>%    col_vals_not_equal(     columns = vars(a),     value = 1,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_not_equal()`.\",     active = FALSE   )  # Representación YAML steps: - col_vals_not_equal:     columns: vars(a)     value: 1.0     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_not_equal()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_equal.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Los datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_not_equal","text":"2-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_equal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Los datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? — col_vals_not_equal","text":"","code":"# Para todos los ejemplos, utilizaremos # una tabla sencilla con tres columnas # numéricas (`a`, `b` y `c`) y tres # columnas de caracteres (`d`, `e` # y `f`) tbl <-   dplyr::tibble(     a = c(5, 5, 5, 5, 5, 5),     b = c(1, 1, 1, 2, 2, 2),     c = c(1, 1, 1, 2, 2, 2),     d = LETTERS[c(1:3, 5:7)],     e = LETTERS[c(1:6)],     f = LETTERS[c(1:6)]   )    tbl #> # A tibble: 6 × 6 #>       a     b     c d     e     f     #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 A     A     A     #> 2     5     1     1 B     B     B     #> 3     5     1     1 C     C     C     #> 4     5     2     2 E     D     D     #> 5     5     2     2 F     E     E     #> 6     5     2     2 G     F     F      # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Validate that values in column `a` # are all *not* equal to the value # of `6` agent <-   create_agent(tbl) %>%   col_vals_not_equal(vars(a), 6) %>%   interrogate()  # Determine si esta validación no tuvo # unidades de prueba fallidas (hay 6 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` tbl %>%    col_vals_not_equal(vars(a), 6) %>%   dplyr::pull(a) #> [1] 5 5 5 5 5 5    # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_not_equal(tbl, vars(a), 6)  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto test_col_vals_not_equal(tbl, vars(a), 6) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_in_set.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Los datos no forman parte de un conjunto específico de valores? — col_vals_not_in_set","title":"¿Los datos no forman parte de un conjunto específico de valores? — col_vals_not_in_set","text":"La función de validación col_vals_not_in_set(), la función de expectativa expect_col_vals_not_in_set() y la función de prueba test_col_vals_not_in_set() comprueban si los valores de columna en una tabla son parte de un conjunto de valores especificado. La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre el número de unidades de prueba que es igual al número de filas en la tabla (después de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_in_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Los datos no forman parte de un conjunto específico de valores? — col_vals_not_in_set","text":"","code":"col_vals_not_in_set(   x,   columns,   set,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_not_in_set(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )  test_col_vals_not_in_set(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_in_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Los datos no forman parte de un conjunto específico de valores? — col_vals_not_in_set","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. set vector numeric string-based elements, column values found within set considered failing. preconditions Una expresión opcional para mutar la tabla de entrada antes de continuar con la validación. Esto se puede proporcionar como una fórmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una función (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la sección Preconditions para obtener más información. segments Una expresión opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la sección Segments para obtener más detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_in_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Los datos no forman parte de un conjunto específico de valores? — col_vals_not_in_set","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_in_set.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¿Los datos no forman parte de un conjunto específico de valores? — col_vals_not_in_set","text":"Si proporciona varios nombres de columna, el resultado será una expansión de pasos de validación para ese número de nombres de columna (por ejemplo, vars(col_a, col_b) dará lugar la entrada de dos pasos de validación). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares están disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_in_set.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¿Los datos no forman parte de un conjunto específico de valores? — col_vals_not_in_set","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesará la tabla de destino durante la interrogación como paso preparatorio. Puede suceder que una validación en particular requiera una columna calculada, algún filtrado de filas o la adición de columnas través de una combinación, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validación con una sola tabla de destino y realice ajustes menores en ella, según sea necesario, lo largo del camino. La mutación de la tabla está totalmente aislada en el alcance de los pasos de validación en los que se utilizan las preconditions. Aquí se sugiere usar el código dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El código se proporciona más fácilmente como una fórmula R unilateral (utilizando un ~ inicial). En la representación de la fórmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podría proporcionar una función (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_in_set.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¿Los datos no forman parte de un conjunto específico de valores? — col_vals_not_in_set","text":"Al usar el argumento segments, es posible definir una validación particular con segmentos (o porciones de fila) de la tabla de destino. Una expresión opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresión que se puede utilizar, vars(a_column) segmentará la tabla de destino en la forma en que estén presentes muchos valores únicos en la columna llamada a_column. Esto es excelente si cada valor único en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validación repetida. Con una fórmula, podemos ser más selectivos con los valores de columna que se deben usar para la segmentación. El uso de a_column ~ c(\"group_1\", \"group_2\") intentará obtener dos segmentos donde uno es una porción de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la fórmula dará como resultado un paso de validación independiente. Si hay varias columns especificadas, el número potencial de pasos de validación será m columnas multiplicadas por n segmentos resueltos. La segmentación siempre ocurrirá después de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinación, es posible generar etiquetas para la segmentación usando una expresión para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versión separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_in_set.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Los datos no forman parte de un conjunto específico de valores? — col_vals_not_in_set","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situación (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_in_set.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Los datos no forman parte de un conjunto específico de valores? — col_vals_not_in_set","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_in_set.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Los datos no forman parte de un conjunto específico de valores? — col_vals_not_in_set","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_vals_not_in_set() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_vals_not_in_set() como paso de validación se expresa en código R y en la representación YAML correspondiente. practice, often shorter columns, set arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# Código R agent %>%    col_vals_not_in_set(     columns = vars(a),     set = c(1, 2, 3, 4),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_not_in_set()`.\",     active = FALSE   )  # Representación YAML steps: - col_vals_not_in_set:     columns: vars(a)    set:    - 1.0    - 2.0    - 3.0    - 4.0    preconditions: ~. %>% dplyr::filter(a < 10)    segments: b ~ c(\"group_1\", \"group_2\")    actions:      warn_fraction: 0.1      stop_fraction: 0.2    label: El paso `col_vals_not_in_set()`.    active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_in_set.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Los datos no forman parte de un conjunto específico de valores? — col_vals_not_in_set","text":"2-10","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_in_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Los datos no forman parte de un conjunto específico de valores? — col_vals_not_in_set","text":"","code":"# The `small_table` dataset in the # package will be used to validate that # column values are part of a given set  # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Validate that values in column `f` # contain none of the values `lows`, # `mids`, and `highs` agent <-   create_agent(small_table) %>%   col_vals_not_in_set(     vars(f), c(\"lows\", \"mids\", \"highs\")   ) %>%   interrogate()    # Determine si esta validación no tuvo # unidades de prueba fallidas (hay 13 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` small_table %>%   col_vals_not_in_set(     vars(f), c(\"lows\", \"mids\", \"highs\")   ) %>%   dplyr::pull(f) %>%   unique() #> [1] \"high\" \"low\"  \"mid\"   # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_not_in_set(   small_table,   vars(f), c(\"lows\", \"mids\", \"highs\") )  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto small_table %>%   test_col_vals_not_in_set(     vars(f), c(\"lows\", \"mids\", \"highs\")   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_null.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Los datos de la columna no son NULL/NA? — col_vals_not_null","title":"¿Los datos de la columna no son NULL/NA? — col_vals_not_null","text":"La función de validación col_vals_not_null(), la función de expectativa expect_col_vals_not_null() y la función de prueba test_col_vals_not_null() comprueban si los valores de columna en una tabla son valores de NA o, en el contexto de la base de datos, valores NULL. La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre el número de unidades de prueba que es igual al número de filas en la tabla (después de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_null.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Los datos de la columna no son NULL/NA? — col_vals_not_null","text":"","code":"col_vals_not_null(   x,   columns,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_not_null(object, columns, preconditions = NULL, threshold = 1)  test_col_vals_not_null(object, columns, preconditions = NULL, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_null.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Los datos de la columna no son NULL/NA? — col_vals_not_null","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. preconditions Una expresión opcional para mutar la tabla de entrada antes de continuar con la validación. Esto se puede proporcionar como una fórmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una función (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la sección Preconditions para obtener más información. segments Una expresión opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la sección Segments para obtener más detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_null.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Los datos de la columna no son NULL/NA? — col_vals_not_null","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_null.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¿Los datos de la columna no son NULL/NA? — col_vals_not_null","text":"Si proporciona varios nombres de columna, el resultado será una expansión de pasos de validación para ese número de nombres de columna (por ejemplo, vars(col_a, col_b) dará lugar la entrada de dos pasos de validación). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares están disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_null.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¿Los datos de la columna no son NULL/NA? — col_vals_not_null","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesará la tabla de destino durante la interrogación como paso preparatorio. Puede suceder que una validación en particular requiera una columna calculada, algún filtrado de filas o la adición de columnas través de una combinación, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validación con una sola tabla de destino y realice ajustes menores en ella, según sea necesario, lo largo del camino. La mutación de la tabla está totalmente aislada en el alcance de los pasos de validación en los que se utilizan las preconditions. Aquí se sugiere usar el código dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El código se proporciona más fácilmente como una fórmula R unilateral (utilizando un ~ inicial). En la representación de la fórmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podría proporcionar una función (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_null.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¿Los datos de la columna no son NULL/NA? — col_vals_not_null","text":"Al usar el argumento segments, es posible definir una validación particular con segmentos (o porciones de fila) de la tabla de destino. Una expresión opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresión que se puede utilizar, vars(a_column) segmentará la tabla de destino en la forma en que estén presentes muchos valores únicos en la columna llamada a_column. Esto es excelente si cada valor único en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validación repetida. Con una fórmula, podemos ser más selectivos con los valores de columna que se deben usar para la segmentación. El uso de a_column ~ c(\"group_1\", \"group_2\") intentará obtener dos segmentos donde uno es una porción de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la fórmula dará como resultado un paso de validación independiente. Si hay varias columns especificadas, el número potencial de pasos de validación será m columnas multiplicadas por n segmentos resueltos. La segmentación siempre ocurrirá después de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinación, es posible generar etiquetas para la segmentación usando una expresión para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versión separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_null.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Los datos de la columna no son NULL/NA? — col_vals_not_null","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situación (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_null.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Los datos de la columna no son NULL/NA? — col_vals_not_null","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_null.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Los datos de la columna no son NULL/NA? — col_vals_not_null","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_vals_not_null() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_vals_not_null() como paso de validación se expresa en código R y en la representación YAML correspondiente. En la práctica, ambos serán menudo más cortos, ya que solo el argumento de las columns requiere un valor. Los argumentos con valores predeterminados se escribirán en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). También es posible obtener una vista previa de la transformación de un agente YAML sin escribir en el disco usando la función yaml_agent_string().","code":"# Código R agent %>%    col_vals_not_null(     vars(a),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_not_null()`.\",     active = FALSE   )  # Representación YAML steps: - col_vals_not_null:     columns: vars(a)     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_not_null()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_null.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Los datos de la columna no son NULL/NA? — col_vals_not_null","text":"2-16","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_null.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Los datos de la columna no son NULL/NA? — col_vals_not_null","text":"","code":"# For all examples here, we'll use # a simple table with four columns: # `a`, `b`, `c`, and `d` tbl <-   dplyr::tibble(     a = c( 5,  7,  6,  5,  8),     b = c( 7,  1,  0,  0,  0),     c = c(NA, NA, NA, NA, NA),     d = c(35, 23, NA, NA, NA)   )    tbl #> # A tibble: 5 × 4 #>       a     b c         d #>   <dbl> <dbl> <lgl> <dbl> #> 1     5     7 NA       35 #> 2     7     1 NA       23 #> 3     6     0 NA       NA #> 4     5     0 NA       NA #> 5     8     0 NA       NA    # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Validate that all values in column # `b` are *not* NA (they would be # non-NULL in a database context, which # isn't the case here) agent <-   create_agent(tbl) %>%   col_vals_not_null(vars(b)) %>%   interrogate()  # Determine si esta validación no tuvo # unidades de prueba fallidas (hay 5 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` tbl %>%   col_vals_not_null(vars(b)) %>%   dplyr::pull(b) #> [1] 7 1 0 0 0  # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_not_null(tbl, vars(b))  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto tbl %>% test_col_vals_not_null(vars(b)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_null.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Son los datos de la columna NULL/NA? — col_vals_null","title":"¿Son los datos de la columna NULL/NA? — col_vals_null","text":"La función de validación col_vals_null(), la función de expectativa expect_col_vals_null() y la función de prueba test_col_vals_null() comprueban si los valores de las columnas en una tabla son valores NA o, en el contexto de la base de datos, NULL valores. La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre el número de unidades de prueba que es igual al número de filas en la tabla (después de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_null.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Son los datos de la columna NULL/NA? — col_vals_null","text":"","code":"col_vals_null(   x,   columns,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_null(object, columns, preconditions = NULL, threshold = 1)  test_col_vals_null(object, columns, preconditions = NULL, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_null.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Son los datos de la columna NULL/NA? — col_vals_null","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. preconditions Una expresión opcional para mutar la tabla de entrada antes de continuar con la validación. Esto se puede proporcionar como una fórmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una función (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la sección Preconditions para obtener más información. segments Una expresión opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la sección Segments para obtener más detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_null.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Son los datos de la columna NULL/NA? — col_vals_null","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_null.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¿Son los datos de la columna NULL/NA? — col_vals_null","text":"Si proporciona varios nombres de columna, el resultado será una expansión de pasos de validación para ese número de nombres de columna (por ejemplo, vars(col_a, col_b) dará lugar la entrada de dos pasos de validación). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares están disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_null.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¿Son los datos de la columna NULL/NA? — col_vals_null","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesará la tabla de destino durante la interrogación como paso preparatorio. Puede suceder que una validación en particular requiera una columna calculada, algún filtrado de filas o la adición de columnas través de una combinación, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validación con una sola tabla de destino y realice ajustes menores en ella, según sea necesario, lo largo del camino. La mutación de la tabla está totalmente aislada en el alcance de los pasos de validación en los que se utilizan las preconditions. Aquí se sugiere usar el código dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El código se proporciona más fácilmente como una fórmula R unilateral (utilizando un ~ inicial). En la representación de la fórmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podría proporcionar una función (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_null.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¿Son los datos de la columna NULL/NA? — col_vals_null","text":"Al usar el argumento segments, es posible definir una validación particular con segmentos (o porciones de fila) de la tabla de destino. Una expresión opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresión que se puede utilizar, vars(a_column) segmentará la tabla de destino en la forma en que estén presentes muchos valores únicos en la columna llamada a_column. Esto es excelente si cada valor único en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validación repetida. Con una fórmula, podemos ser más selectivos con los valores de columna que se deben usar para la segmentación. El uso de a_column ~ c(\"group_1\", \"group_2\") intentará obtener dos segmentos donde uno es una porción de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la fórmula dará como resultado un paso de validación independiente. Si hay varias columns especificadas, el número potencial de pasos de validación será m columnas multiplicadas por n segmentos resueltos. La segmentación siempre ocurrirá después de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinación, es posible generar etiquetas para la segmentación usando una expresión para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versión separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_null.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Son los datos de la columna NULL/NA? — col_vals_null","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situación (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_null.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Son los datos de la columna NULL/NA? — col_vals_null","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_null.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Son los datos de la columna NULL/NA? — col_vals_null","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_vals_null() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_vals_null() como paso de validación se expresa en código R y en la representación YAML correspondiente. En la práctica, ambos serán menudo más cortos, ya que solo el argumento de las columns requiere un valor. Los argumentos con valores predeterminados se escribirán en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). También es posible obtener una vista previa de la transformación de un agente YAML sin escribir en el disco usando la función yaml_agent_string().","code":"# Código R agent %>%    col_vals_null(     vars(a),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_null()`.\",     active = FALSE   )  # Representación YAML steps: - col_vals_null:     columns: vars(a)     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_null()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_null.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Son los datos de la columna NULL/NA? — col_vals_null","text":"2-15","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_null.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Son los datos de la columna NULL/NA? — col_vals_null","text":"","code":"# For all examples here, we'll use # a simple table with four columns: # `a`, `b`, `c`, and `d` tbl <-   dplyr::tibble(     a = c( 5,  7,  6,  5,  8),     b = c( 7,  1,  0,  0,  0),     c = c(NA, NA, NA, NA, NA),     d = c(35, 23, NA, NA, NA)   )    tbl #> # A tibble: 5 × 4 #>       a     b c         d #>   <dbl> <dbl> <lgl> <dbl> #> 1     5     7 NA       35 #> 2     7     1 NA       23 #> 3     6     0 NA       NA #> 4     5     0 NA       NA #> 5     8     0 NA       NA    # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Validate that all values in column # `c` are NA (they would be NULL in a # database context, which isn't the # case here) agent <-   create_agent(tbl) %>%   col_vals_null(vars(c)) %>%   interrogate()  # Determine si esta validación no tuvo # unidades de prueba fallidas (hay 5 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` tbl %>%   col_vals_null(vars(c)) %>%   dplyr::pull(c) #> [1] NA NA NA NA NA  # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_null(tbl, vars(c))  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto tbl %>% test_col_vals_null(vars(c)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_regex.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Las cadenas en los datos de la columna coinciden con un patrón de\nexpresiones regulares? — col_vals_regex","title":"¿Las cadenas en los datos de la columna coinciden con un patrón de\nexpresiones regulares? — col_vals_regex","text":"La función de validación col_vals_regex(), la función de expectativa expect_col_vals_regex() y la función de prueba test_col_vals_regex() comprueban si los valores de las columnas en una tabla corresponden una expresión coincidente de regex. La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre el número de unidades de prueba que es igual al número de filas en la tabla (después de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_regex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Las cadenas en los datos de la columna coinciden con un patrón de\nexpresiones regulares? — col_vals_regex","text":"","code":"col_vals_regex(   x,   columns,   regex,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_regex(   object,   columns,   regex,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_regex(   object,   columns,   regex,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_regex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Las cadenas en los datos de la columna coinciden con un patrón de\nexpresiones regulares? — col_vals_regex","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. regex regular expression pattern test match target column. regex matches values target columns pass validation. na_pass ¿Debería considerarse que los valores de NA encontrados pasan unidades de prueba? Esto es por defecto FALSE. Ajústelo en TRUE para darle un pase NA. preconditions Una expresión opcional para mutar la tabla de entrada antes de continuar con la validación. Esto se puede proporcionar como una fórmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una función (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la sección Preconditions para obtener más información. segments Una expresión opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la sección Segments para obtener más detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_regex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Las cadenas en los datos de la columna coinciden con un patrón de\nexpresiones regulares? — col_vals_regex","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_regex.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¿Las cadenas en los datos de la columna coinciden con un patrón de\nexpresiones regulares? — col_vals_regex","text":"Si proporciona varios nombres de columna, el resultado será una expansión de pasos de validación para ese número de nombres de columna (por ejemplo, vars(col_a, col_b) dará lugar la entrada de dos pasos de validación). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares están disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_regex.html","id":"valores-faltantes","dir":"Reference","previous_headings":"","what":"Valores faltantes","title":"¿Las cadenas en los datos de la columna coinciden con un patrón de\nexpresiones regulares? — col_vals_regex","text":"Esta función de validación admite el manejo especial de valores NA. El argumento na_pass determinará si un valor de NA que aparece en una unidad de prueba debe pasar o . El valor predeterminado de na_pass = FALSE significa que cualquier NA encontrado acumulará unidades de prueba fallidas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_regex.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¿Las cadenas en los datos de la columna coinciden con un patrón de\nexpresiones regulares? — col_vals_regex","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesará la tabla de destino durante la interrogación como paso preparatorio. Puede suceder que una validación en particular requiera una columna calculada, algún filtrado de filas o la adición de columnas través de una combinación, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validación con una sola tabla de destino y realice ajustes menores en ella, según sea necesario, lo largo del camino. La mutación de la tabla está totalmente aislada en el alcance de los pasos de validación en los que se utilizan las preconditions. Aquí se sugiere usar el código dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El código se proporciona más fácilmente como una fórmula R unilateral (utilizando un ~ inicial). En la representación de la fórmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podría proporcionar una función (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_regex.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¿Las cadenas en los datos de la columna coinciden con un patrón de\nexpresiones regulares? — col_vals_regex","text":"Al usar el argumento segments, es posible definir una validación particular con segmentos (o porciones de fila) de la tabla de destino. Una expresión opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresión que se puede utilizar, vars(a_column) segmentará la tabla de destino en la forma en que estén presentes muchos valores únicos en la columna llamada a_column. Esto es excelente si cada valor único en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validación repetida. Con una fórmula, podemos ser más selectivos con los valores de columna que se deben usar para la segmentación. El uso de a_column ~ c(\"group_1\", \"group_2\") intentará obtener dos segmentos donde uno es una porción de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la fórmula dará como resultado un paso de validación independiente. Si hay varias columns especificadas, el número potencial de pasos de validación será m columnas multiplicadas por n segmentos resueltos. La segmentación siempre ocurrirá después de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinación, es posible generar etiquetas para la segmentación usando una expresión para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versión separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_regex.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Las cadenas en los datos de la columna coinciden con un patrón de\nexpresiones regulares? — col_vals_regex","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situación (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_regex.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Las cadenas en los datos de la columna coinciden con un patrón de\nexpresiones regulares? — col_vals_regex","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_regex.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Las cadenas en los datos de la columna coinciden con un patrón de\nexpresiones regulares? — col_vals_regex","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_vals_regex() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_vals_regex() como paso de validación se expresa en código R y en la representación YAML correspondiente. practice, often shorter columns regex arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# Código R agent %>%    col_vals_regex(     columns = vars(a),     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\",     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_regex()`.\",     active = FALSE   )  # Representación YAML steps: - col_vals_regex:     columns: vars(a)     regex: '[0-9]-[a-z]{3}-[0-9]{3}'     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_regex()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_regex.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Las cadenas en los datos de la columna coinciden con un patrón de\nexpresiones regulares? — col_vals_regex","text":"2-17","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_regex.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Las cadenas en los datos de la columna coinciden con un patrón de\nexpresiones regulares? — col_vals_regex","text":"","code":"# The `small_table` dataset in the # package has a character-based `b` # column with values that adhere to # a very particular pattern; the # following examples will validate # that that column abides by a regex # pattern small_table #> # A tibble: 13 × 8 #>    date_time           date           a b             c      d e     f     #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high   # This is the regex pattern that will # be used throughout pattern <- \"[0-9]-[a-z]{3}-[0-9]{3}\"  # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Validate that all values in column # `b` match the regex `pattern` agent <-   create_agent(small_table) %>%   col_vals_regex(vars(b), pattern) %>%   interrogate()    # Determine si esta validación no tuvo # unidades de prueba fallidas (hay 13 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` small_table %>%   col_vals_regex(vars(b), pattern) %>%   dplyr::slice(1:5) #> # A tibble: 5 × 8 #>   date_time           date           a b             c      d e     f     #>   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #> 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #> 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #> 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #> 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #> 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low    # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_regex(   small_table,   vars(b), pattern )  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto small_table %>%   test_col_vals_regex(     vars(b), pattern   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Los valores de los datos de la columna se ajustan a una especificación? — col_vals_within_spec","title":"¿Los valores de los datos de la columna se ajustan a una especificación? — col_vals_within_spec","text":"La función de validación col_vals_within_spec(), la función de expectativa expect_col_vals_within_spec() y la función de prueba test_col_vals_within_spec() comprueban si los valores de columna en una tabla corresponden un tipo de especificación (spec) (los detalles son disponible en la sección Especificaciones) La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre el número de unidades de prueba que es igual al número de filas en la tabla (después de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Los valores de los datos de la columna se ajustan a una especificación? — col_vals_within_spec","text":"","code":"col_vals_within_spec(   x,   columns,   spec,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_within_spec(   object,   columns,   spec,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_within_spec(   object,   columns,   spec,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Los valores de los datos de la columna se ajustan a una especificación? — col_vals_within_spec","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. spec specification string. Examples \"email\", \"url\", \"postal[USA]\". options explained Specifications section. na_pass ¿Debería considerarse que los valores de NA encontrados pasan unidades de prueba? Esto es por defecto FALSE. Ajústelo en TRUE para darle un pase NA. preconditions Una expresión opcional para mutar la tabla de entrada antes de continuar con la validación. Esto se puede proporcionar como una fórmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una función (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la sección Preconditions para obtener más información. segments Una expresión opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la sección Segments para obtener más detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Los valores de los datos de la columna se ajustan a una especificación? — col_vals_within_spec","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":"especificaciones","dir":"Reference","previous_headings":"","what":"Especificaciones","title":"¿Los valores de los datos de la columna se ajustan a una especificación? — col_vals_within_spec","text":"specification type must used spec argument. character-based keyword corresponds type data specified columns. following keywords can used: \"isbn\": International Standard Book Number (ISBN) unique numerical identifier books, pamphletes, educational kits, microforms, digital/electronic publications. specification formalized ISO 2108. keyword can used validate 10- 13-digit ISBNs. \"VIN\": vehicle identification number (VIN) unique code (includes serial number) used automotive industry identify individual motor vehicles, motorcycles, scooters, mopeds stipulated ISO 3779 ISO 4030. \"postal_code[<country_code>]\": postal code (also known postcodes, PIN, ZIP codes, depending region) series letters, digits, (sometimes including spaces/punctuation) included postal address aid sorting mail. coding varies country, country code either 2- (ISO 3166-1 alpha-2) 3-letter (ISO 3166-1 alpha-3) formats needs supplied along keywords (e.g., postal codes Germany, \"postal_code[DE]\" \"postal_code[DEU]\" can used). keyword alias \"zip\" can used US ZIP codes. \"credit_card\": credit card number can validated check works across large variety credit type issuers (card numbers allocated accordance ISO/IEC 7812). Numbers can various lengths (typically, 14-19 digits) key validation performed usage Luhn algorithm. \"iban[<country_code>]\": International Bank Account Number (IBAN) system identifying bank accounts across different countries purpose improving cross-border transactions. IBAN values validated conversion integer values performing basic mod-97 operation (described ISO 7064) . length coding varies country, country code either 2- (ISO 3166-1 alpha-2) 3-letter (ISO 3166-1 alpha-3) formats needs supplied along keywords (e.g., IBANs Germany, \"iban[DE]\" \"iban[DEU]\" can used). \"swift\": Business Identifier Codes (also known SWIFT-BIC, BIC, SWIFT code) defined standard format described ISO 9362. codes unique identifiers financial non-financial institutions. SWIFT stands Society Worldwide Interbank Financial Telecommunication. numbers used transferring money banks, especially important international wire transfers. \"phone\", \"email\", \"url\", \"ipv4\", \"ipv6\", \"mac\": Phone numbers, email addresses, Internet URLs, IPv4 IPv6 addresses, MAC addresses can validated respective keywords. validations use regex-based matching determine validity. single spec value provided per function call.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¿Los valores de los datos de la columna se ajustan a una especificación? — col_vals_within_spec","text":"Si proporciona varios nombres de columna, el resultado será una expansión de pasos de validación para ese número de nombres de columna (por ejemplo, vars(col_a, col_b) dará lugar la entrada de dos pasos de validación). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares están disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":"valores-faltantes","dir":"Reference","previous_headings":"","what":"Valores faltantes","title":"¿Los valores de los datos de la columna se ajustan a una especificación? — col_vals_within_spec","text":"Esta función de validación admite el manejo especial de valores NA. El argumento na_pass determinará si un valor de NA que aparece en una unidad de prueba debe pasar o . El valor predeterminado de na_pass = FALSE significa que cualquier NA encontrado acumulará unidades de prueba fallidas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¿Los valores de los datos de la columna se ajustan a una especificación? — col_vals_within_spec","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesará la tabla de destino durante la interrogación como paso preparatorio. Puede suceder que una validación en particular requiera una columna calculada, algún filtrado de filas o la adición de columnas través de una combinación, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validación con una sola tabla de destino y realice ajustes menores en ella, según sea necesario, lo largo del camino. La mutación de la tabla está totalmente aislada en el alcance de los pasos de validación en los que se utilizan las preconditions. Aquí se sugiere usar el código dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El código se proporciona más fácilmente como una fórmula R unilateral (utilizando un ~ inicial). En la representación de la fórmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podría proporcionar una función (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¿Los valores de los datos de la columna se ajustan a una especificación? — col_vals_within_spec","text":"Al usar el argumento segments, es posible definir una validación particular con segmentos (o porciones de fila) de la tabla de destino. Una expresión opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresión que se puede utilizar, vars(a_column) segmentará la tabla de destino en la forma en que estén presentes muchos valores únicos en la columna llamada a_column. Esto es excelente si cada valor único en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validación repetida. Con una fórmula, podemos ser más selectivos con los valores de columna que se deben usar para la segmentación. El uso de a_column ~ c(\"group_1\", \"group_2\") intentará obtener dos segmentos donde uno es una porción de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la fórmula dará como resultado un paso de validación independiente. Si hay varias columns especificadas, el número potencial de pasos de validación será m columnas multiplicadas por n segmentos resueltos. La segmentación siempre ocurrirá después de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinación, es posible generar etiquetas para la segmentación usando una expresión para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versión separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Los valores de los datos de la columna se ajustan a una especificación? — col_vals_within_spec","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situación (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Los valores de los datos de la columna se ajustan a una especificación? — col_vals_within_spec","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Los valores de los datos de la columna se ajustan a una especificación? — col_vals_within_spec","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando col_vals_within_spec() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de col_vals_within_spec() como paso de validación se expresa en código R y en la representación YAML correspondiente. practice, often shorter columns spec arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# Código R agent %>%    col_vals_within_spec(     columns = vars(a),     spec = \"email\",     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(b < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_within_spec()`.\",     active = FALSE   )  # Representación YAML steps: - col_vals_within_spec:     columns: vars(a)     spec: email     na_pass: true     preconditions: ~. %>% dplyr::filter(b < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_within_spec()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Los valores de los datos de la columna se ajustan a una especificación? — col_vals_within_spec","text":"2-18","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Los valores de los datos de la columna se ajustan a una especificación? — col_vals_within_spec","text":"","code":"# The `specifications` dataset in the # package has columns of character data # that correspond to each of the # specifications that can be tested; # the following examples will validate # that the `email_addresses` column # has 5 correct values (this is true if # we get a subset of the data: the first # five rows) spec_slice <- specifications[1:5, ]  # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Validate that all values in the column # `email_addresses` are correct agent <-   create_agent(spec_slice) %>%   col_vals_within_spec(     vars(email_addresses),     spec = \"email\"   ) %>%   interrogate()    # Determine si esta validación no tuvo # unidades de prueba fallidas (hay 5 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` spec_slice %>%   col_vals_within_spec(     vars(email_addresses),     spec = \"email\"   ) %>%   dplyr::select(email_addresses) #> # A tibble: 5 × 1 #>   email_addresses                                                           #>   <chr>                                                                     #> 1 test@test.com                                                             #> 2 mail+mail@example.com                                                     #> 3 mail.email@e.test.com                                                     #> 4 abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@letters-in-local.org #> 5 01234567890@numbers-in-local.net                                           # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_within_spec(   spec_slice,   vars(email_addresses),   spec = \"email\" )  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto spec_slice %>%   test_col_vals_within_spec(     vars(email_addresses),     spec = \"email\"   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/conjointly.html","id":null,"dir":"Reference","previous_headings":"","what":"Realice múltiples validaciones por filas para la validez conjunta — conjointly","title":"Realice múltiples validaciones por filas para la validez conjunta — conjointly","text":"La función de validación conjointly(), la función de expectativa expect_conjointly() y la función de prueba test_conjointly() comprueban si las unidades de prueba en cada índice (típicamente cada fila) pasan todas las validaciones múltiples. Podemos usar funciones de validación que validan las unidades de fila (la serie col_vals_*()), verificar la existencia de la columna (col_exists()), o validar el tipo de columna (la serie col_is_*()). Debido la restricción impuesta sobre las funciones de validación permitidas, el conjunto de unidades de prueba está compuesto por filas de la tabla (después de que se hayan aplicado las preconditions comunes) o son unidades de prueba únicas (para aquellas funciones que validan columnas). Cada una de las funciones usadas en un paso de validación conjointly() (compuesto usando múltiples llamadas funciones de validación) finalmente realiza una prueba por filas de si todas las subvalidaciones reportaron un aprobado para las mismas unidades de prueba. En la práctica, un ejemplo de validación conjunta es probar si los valores de la columna son mayores que un valor específico, mientras que los valores adyacentes en la columna b se encuentran dentro de un rango específico. Las funciones de validación que serán parte de la validación conjunta deben ser suministradas como fórmulas R unilaterales (usando un ~ inicial y con un . como el objeto de datos). La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/conjointly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Realice múltiples validaciones por filas para la validez conjunta — conjointly","text":"","code":"conjointly(   x,   ...,   .list = list2(...),   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_conjointly(   object,   ...,   .list = list2(...),   preconditions = NULL,   threshold = 1 )  test_conjointly(   object,   ...,   .list = list2(...),   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/conjointly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Realice múltiples validaciones por filas para la validez conjunta — conjointly","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). ... Una colección de fórmulas unilaterales que constan de funciones de validación que validan unidades de fila (la serie col_vals_*()), existencia de columna (col_exists()) o tipo de columna (la serie col_is_*()). Un ejemplo de esto es ~ col_vals_gte(., vars(), 5.5), ~ col_vals_not_null(., vars(b)). .list Allows use list input alternative .... preconditions Una expresión opcional para mutar la tabla de entrada antes de continuar con la validación. Esto se puede proporcionar como una fórmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una función (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la sección Preconditions para obtener más información. segments Una expresión opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la sección Segments para obtener más detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/conjointly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Realice múltiples validaciones por filas para la validez conjunta — conjointly","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/conjointly.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"Realice múltiples validaciones por filas para la validez conjunta — conjointly","text":"Si proporciona varios nombres de columna en cualquiera de los pasos de validación proporcionados, el resultado será una expansión de los pasos de subvalidación ese número de nombres de columna. Aparte de los nombres de las columnas entre comillas y en vars(), las funciones auxiliares tidyselect están disponibles para especificar columnas. Son: starts_with(), ends_with(), contains(), matches() y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/conjointly.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Realice múltiples validaciones por filas para la validez conjunta — conjointly","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesará la tabla de destino durante la interrogación como paso preparatorio. Puede suceder que una validación en particular requiera una columna calculada, algún filtrado de filas o la adición de columnas través de una combinación, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validación con una sola tabla de destino y realice ajustes menores en ella, según sea necesario, lo largo del camino. La mutación de la tabla está totalmente aislada en el alcance de los pasos de validación en los que se utilizan las preconditions. Aquí se sugiere usar el código dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El código se proporciona más fácilmente como una fórmula R unilateral (utilizando un ~ inicial). En la representación de la fórmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podría proporcionar una función (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/conjointly.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"Realice múltiples validaciones por filas para la validez conjunta — conjointly","text":"Al usar el argumento segments, es posible definir una validación particular con segmentos (o porciones de fila) de la tabla de destino. Una expresión opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresión que se puede utilizar, vars(a_column) segmentará la tabla de destino en la forma en que estén presentes muchos valores únicos en la columna llamada a_column. Esto es excelente si cada valor único en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validación repetida. Con una fórmula, podemos ser más selectivos con los valores de columna que se deben usar para la segmentación. El uso de a_column ~ c(\"group_1\", \"group_2\") intentará obtener dos segmentos donde uno es una porción de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la fórmula dará como resultado un paso de validación independiente. Si hay varias columns especificadas, el número potencial de pasos de validación será m columnas multiplicadas por n segmentos resueltos. La segmentación siempre ocurrirá después de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinación, es posible generar etiquetas para la segmentación usando una expresión para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versión separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/conjointly.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Realice múltiples validaciones por filas para la validez conjunta — conjointly","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situación (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop()s en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/conjointly.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Realice múltiples validaciones por filas para la validez conjunta — conjointly","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/conjointly.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Realice múltiples validaciones por filas para la validez conjunta — conjointly","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando conjointly() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de conjointly() como paso de validación se expresa en código R y en la representación YAML correspondiente. En la práctica, ambos serán menudo más cortos, ya que solo son necesarias las expresiones para los pasos de validación. Los argumentos con valores predeterminados se escribirán en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). También es posible obtener una vista previa de la transformación de un agente YAML sin escribir en el disco usando la función yaml_agent_string().","code":"# Código R agent %>%    conjointly(     ~ col_vals_lt(., vars(a), 8),     ~ col_vals_gt(., vars(c), vars(a)),     ~ col_vals_not_null(., vars(b)),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),      label = \"El paso `conjointly()`.\",     active = FALSE   )  # Representación YAML steps: - conjointly:     fns:     - ~col_vals_lt(., vars(a), 8)     - ~col_vals_gt(., vars(c), vars(a))     - ~col_vals_not_null(., vars(b))     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `conjointly()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/conjointly.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Realice múltiples validaciones por filas para la validez conjunta — conjointly","text":"2-31","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/conjointly.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Realice múltiples validaciones por filas para la validez conjunta — conjointly","text":"","code":"# Para todos los ejemplos aquí, usaremos # una tabla simple con tres columnas # numéricas (`a`, `b` y `c`); esta es # una tabla muy básica, pero será más # útil cuando se expliquen las cosas # más adelante tbl <-   dplyr::tibble(     a = c(5, 2, 6),     b = c(3, 4, 6),     c = c(9, 8, 7)   )    tbl #> # A tibble: 3 × 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     3     9 #> 2     2     4     8 #> 3     6     6     7    # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # Validate a number of things on a # row-by-row basis using validation # functions of the `col_vals*` type # (all have the same number of test # units): (1) values in `a` are less # than `8`, (2) values in `c` are # greater than the adjacent values in # `a`, and (3) there aren't any NA # values in `b` agent <-   create_agent(tbl = tbl) %>%   conjointly(     ~ col_vals_lt(., vars(a), value = 8),     ~ col_vals_gt(., vars(c), value = vars(a)),     ~ col_vals_not_null(., vars(b))     ) %>%   interrogate()    # Determine si esta validación no tuvo # unidades de prueba fallidas (hay 3 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # ¿Que esta pasando? Piense en que hay # tres validaciones paralelas, cada una # de las cuales produce una columna de # valores `TRUE` o `FALSE` (\"pasa\" o # \"falla\") y alinéelos uno al lado del # otro, cualquier fila con cualquier # valor `FALSE` da como resultado una # unidad de prueba conjunta \"fallida\"  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` tbl %>%   conjointly(     ~ col_vals_lt(., vars(a), value = 8),     ~ col_vals_gt(., vars(c), value = vars(a)),     ~ col_vals_not_null(., vars(b))   ) #> # A tibble: 3 × 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     3     9 #> 2     2     4     8 #> 3     6     6     7  # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_conjointly(   tbl,   ~ col_vals_lt(., vars(a), value = 8),   ~ col_vals_gt(., vars(c), value = vars(a)),   ~ col_vals_not_null(., vars(b)) )  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto tbl %>%   test_conjointly(     ~ col_vals_lt(., vars(a), value = 8),     ~ col_vals_gt(., vars(c), value = vars(a)),     ~ col_vals_not_null(., vars(b))   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_agent.html","id":null,"dir":"Reference","previous_headings":"","what":"Crear un objeto pointblank agent — create_agent","title":"Crear un objeto pointblank agent — create_agent","text":"La función create_agent() crea un objeto agent, que se utiliza en un flujo de trabajo de informes de calidad de datos. El objetivo general de este flujo de trabajo es generar información de informes útil para evaluar el nivel de calidad de los datos para la tabla de destino. Podemos proporcionar tantas funciones de validación como el usuario desee escribir, aumentando así el nivel de cobertura de validación para esa tabla. El agent asignado por la llamada create_agent() toma funciones de validación, que se expanden los pasos de validación (cada uno está numerado). Este proceso se conoce como desarrollo de un plan de validación. Las funciones de validación, cuando se llaman en un agent, son simplemente instrucciones hasta el punto en que se llama la función interrogate(). Eso inicia el proceso del agent actuando sobre el * plan de validación * y obteniendo resultados para cada paso. Una vez que se completa el proceso de interrogación, podemos decir que el agent tiene inteligencia. Llamar al agent en sí mismo dará como resultado una tabla de informes. También se puede acceder este informe de la interrogación con la función get_agent_report(), donde hay más opciones de informe.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_agent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Crear un objeto pointblank agent — create_agent","text":"","code":"create_agent(   tbl = NULL,   read_fn = NULL,   tbl_name = NULL,   label = NULL,   actions = NULL,   end_fns = NULL,   embed_report = FALSE,   lang = NULL,   locale = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_agent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Crear un objeto pointblank agent — create_agent","text":"tbl La tabla de entrada. Puede ser un marco de datos, un tibble, un objeto tbl_dbi o un objeto tbl_spark. Alternativamente, se puede usar una función para leer en la tabla de datos de entrada con el argumento read_fn (en cuyo caso, tbl puede ser NULL). read_fn Una fórmula de preparación de tablas que se usa para acceder la tabla de destino. Incluso si se proporciona un tbl, esta fórmula se invocará para obtener los datos (es decir, el read_fn tiene prioridad). Hay dos formas de especificar un read_fn: (1) con una expresión de fórmula del lado derecho (RHS) (p. Ej., ~ {<código de lectura de la tabla>}) o (2) como una función (p. Ej., function () {<código de lectura de la tabla>}). tbl_name Un nombre opcional para asignar al objeto de la tabla de entrada. Si se proporciona ningún valor, se generará un nombre en función de la información disponible. Este nombre de tabla se mostrará en el área de encabezado del informe del agente generado al imprimir el agent o llamar get_agent_report(). label Una etiqueta opcional para el plan de validación. Si se proporciona ningún valor, se generará una etiqueta basada en la hora actual del sistema. Markdown se puede usar aquí para hacer que la etiqueta sea más atractiva visualmente (aparecerá en el área de encabezado del informe del agente). actions Una opción para incluir una lista con niveles de umbral para que todos los pasos de validación puedan reaccionar en consecuencia al exceder los niveles establecidos. Esto se creará con la función auxiliar action_levels(). Si se utiliza una lista de niveles de acción para un paso de validación específico, se anulará el conjunto predeterminado especificado aquí. end_fns Una lista de expresiones que deben invocarse al final de un interrogatorio. Cada expresión debe tener la forma de una fórmula R unilateral, por lo que en general se debe usar esta construcción: end_fns = list (~ <declaraciones R>, ~ <declaraciones R>, ...). Un ejemplo de una función incluida en pointblank que se puede utilizar con sensatez aquí es email_blast(), que envía un correo electrónico del informe de validación (basado en una condición de envío). embed_report Una opción para incrustar un informe de validación basado en gt en el objeto ptblank_agent. Si es FALSE (el valor predeterminado), el objeto de la tabla se generará ni estará disponible con el agent al regresar del interrogatorio. lang El idioma que se utilizará para la creación automática de resúmenes (descripciones breves para cada paso de validación) y para el informe del agente (una tabla de resumen que proporciona el plan de validación y los resultados de la interrogación. De forma predeterminada, NULL creará inglés (\"en\") texto. Otras opciones incluyen francés (\"fr\"), alemán (\"de\"), italiano (\"\"), español (\"es\"), portugués (\"pt\"), turco (\"tr\"), chino (\"zh\"), ruso (\"ru\"), polaco (\"pl\"), danés (\"da\") , Sueco (\"sv\") y holandés (\"nl\"). locale Un ID de configuración regional opcional que se utilizará para formatear valores en la tabla de resumen informe del agente de acuerdo con las reglas de la configuración regional. Los ejemplos incluyen \"en_US\" para inglés (Estados Unidos) y \"fr_FR\" para francés (Francia); más simplemente, puede ser un identificador de idioma sin una designación de país, como \"es\" para español (España, igual que \"es_ES\").","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_agent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Crear un objeto pointblank agent — create_agent","text":"Un objeto ptblank_agent.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_agent.html","id":"data-products-obtained-from-an-agent","dir":"Reference","previous_headings":"","what":"Data Products Obtained from an Agent","title":"Crear un objeto pointblank agent — create_agent","text":"Se puede obtener un objeto de lista muy detallado, conocido como x-list, usando la función get_agent_x_list() en el agent. Esta fuente de información puede tomarse como un todo o desglosarse por el número de paso (con el argumento ). veces es útil ver qué filas fallaron. Al usar la función get_data_extracts() en el agent, obtenemos una lista de tibbles (para aquellos pasos que tienen extracciones de datos) o un tibble si el paso de validación se especifica con el argumento . Los datos de destino se pueden dividir en partes que representan las porciones de 'pasa' y 'falla' con la función get_sundered_data(). Un requisito principal es un agente al que se le haya llamado interrogate(). Además, los pasos de validación considerados para esta división de datos deben ser aquellos que operan en valores en una columna (por ejemplo, las funciones col_vals_*() o conjointly()). Con estos pasos de validación en consideración, las filas sin unidades de prueba fallidas en todos los pasos de validación comprenden la pieza de datos 'aprobada', y las filas con al menos una unidad de prueba fallida en la misma serie de validaciones constituyen la pieza 'fallida'. Si solo necesitamos saber si todas las validaciones pasaron por completo (es decir, todos los pasos tenían unidades de prueba fallidas), la función all_passed() podría usarse en el agent. Sin embargo, en la práctica, es frecuente que todos los pasos de validación de datos estén libres de unidades defectuosas. Si bien la impresión de un agent mostrará el informe agent en el Viewer, podemos usar alternativamente get_agent_report() para aprovechar otras opciones (por ejemplo, cambiar el idioma, modificar la disposición de las filas del informe, etc.) y devolver el informe como objetos independientes. Por ejemplo, con la opción display_table = TRUE (la predeterminada), get_agent_report() devolverá un objeto de tabla gt (\"gt_tbl\"). Si display_table se establece en FALSE, obtendremos un marco de datos en su lugar.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_agent.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Crear un objeto pointblank agent — create_agent","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()) . Aquí hay un ejemplo de cómo se expresa una llamada compleja de create_agent() en código R y en la representación YAML correspondiente. En la práctica, este bloque de YAML será más corto ya que los argumentos con valores predeterminados se escribirán en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con su valor predeterminado al generar el YAML por otros medios). El único requisito para escribir la representación YAML de un agent es tener especificado read_fn (cualquier tabla proporcionada tbl es ignorado). Lo que sigue típicamente este fragmento de YAML es una parte de \"pasos\", y eso corresponde la adición de pasos de validación través de funciones de validación. Los artículos de ayuda para cada función de validación tienen una sección YAML que describe cómo una función de validación determinada se traduce YAML. Si necesita obtener una vista previa de la transformación de un agent YAML (sin enviar nada al disco), use la función yaml_agent_string(). Si ya tiene un archivo .yml que contiene un agent, puede echar un vistazo las expresiones R que se utilizan para regenerar ese agente con yaml_agent_show_exprs().","code":"# Código R create_agent(   read_fn = ~ small_table,   tbl_name = \"small_table\",   label = \"Un ejemplo.\",   actions = action_levels(     warn_at = 0.10,     stop_at = 0.25,     notify_at = 0.35   ),    end_fns = list(     ~ beepr::beep(2),     ~ Sys.sleep(1)   ),    embed_report = TRUE,   lang = \"fr\",    locale = \"fr_CA\" )  # Representación YAML type: agent read_fn: ~small_table tbl_name: small_table label: Un ejemplo. lang: fr locale: fr_CA actions:   warn_fraction: 0.1 stop_fraction: 0.25 notify_fraction: 0.35 end_fns: - ~beepr::beep(2) - ~Sys.sleep(1) embed_report: true"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_agent.html","id":"escribir-un-agente-en-el-disco","dir":"Reference","previous_headings":"","what":"Escribir un agente en el disco","title":"Crear un objeto pointblank agent — create_agent","text":"Se puede escribir un objeto agent en el disco con la función x_write_disk(). Esto puede resultar útil para mantener un historial de validaciones y generar vistas de la calidad de los datos lo largo del tiempo. Los agentes se almacenan en formato RDS serializado y se pueden recuperar fácilmente con la función x_read_disk(). Se recomienda que las fórmulas de preparación de tablas se proporcionen al argumento read_fn de create_agent(). De esta manera, cuando se lee un agent desde el disco través de x_read_disk(), se puede reutilizar para acceder la tabla de destino (que puede cambiar, de ahí la necesidad de usar una expresión para esto).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_agent.html","id":"combinaci-n-de-varios-agentes-en-un-objeto-multiagent","dir":"Reference","previous_headings":"","what":"Combinación de varios agentes en un objeto multiagent","title":"Crear un objeto pointblank agent — create_agent","text":"Varios objetos agent pueden formar parte de un objeto agent múltiple, y se pueden usar dos funciones para esto: create_multiagent() y read_disk_multiagent(). Al recopilar varios agentes que han realizado interrogaciones en el pasado, podemos obtener un informe multiagent que muestra cómo evolucionó la calidad de los datos con el tiempo. Este caso de uso es interesante para el control y la gestión de la calidad de los datos, y los informes (que se pueden personalizar con get_multiagent_report()) son sólidos frente los cambios en los pasos de validación para una tabla de destino determinada.","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_agent.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Crear un objeto pointblank agent — create_agent","text":"1-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_agent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Crear un objeto pointblank agent — create_agent","text":"","code":"# Analicemos un análisis de la calidad de # los datos de una tabla extremadamente pequeña; # en realidad se llama `small_table` y podemos # encontrarlo como un conjunto de datos en # este paquete small_table #> # A tibble: 13 × 8 #>    date_time           date           a b             c      d e     f     #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high   # Debemos pensar en lo que es tolerable en # términos de calidad de los datos, así que # designemos umbrales de falla proporcionales # a los estados `warn`,` stop` y `notify` # usando `action_levels()` al <-    action_levels(       warn_at = 0.10,       stop_at = 0.25,     notify_at = 0.35   )  # Ahora cree un objeto `agent` en blanco y # asígnele el objeto` al` (que sirve como valor # predeterminado para todos los pasos de # validación que se pueden anular); los umbrales # estáticos proporcionados por `al` harán que # los informes sean un poco más útiles agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\",     actions = al   )  # Luego, como con cualquier objeto `agent`, # podemos agregar pasos al plan de validación # usando tantas funciones de validación como # queramos; luego, usamos `interrogate()` # para realizar físicamente las validaciones # y recopilar información agent <-   agent %>%    col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b),     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5) %>%   col_vals_equal(     vars(d), value = vars(d),     na_pass = TRUE   ) %>%   col_vals_between(     vars(c),     left = vars(a), right = vars(d),     na_pass = TRUE   ) %>%   interrogate()    # Llamar a un objeto *agent* en la consola # imprime el informe del agente; pero # podemos obtener un objeto `gt_tbl` # directamente con `get_agent_report(agent)` report <- get_agent_report(agent) class(report) #> [1] \"ptblank_agent_report\" \"gt_tbl\"               \"list\"                  # ¿Qué puedes hacer con el informe? Imprima # desde un fragmento de código R Markdown, # úselo en un correo electrónico **blastula**, # colóquelo en una página web o modifíquelo # con el paquete **gt**  # Por el informe sabemos que el Paso 4 # tenía dos unidades de prueba (filas, # en realidad) que fallaron; podemos ver # esas filas con `get_data_extracts()` agent %>% get_data_extracts(i = 4) #> # A tibble: 2 × 8 #>   date_time           date           a b             c     d e     f     #>   <dttm>              <date>     <int> <chr>     <dbl> <dbl> <lgl> <chr> #> 1 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high  #> 2 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high   # Podemos obtener una 'x-list' para toda # la validación (8 pasos), o solo para el # cuarto paso con `get_agent_x_list()` xl_step_4 <-   agent %>% get_agent_x_list(i = 4)   # Y luego podemos examinar las diferentes # partes de la lista; obtengamos la fracción # de unidades de prueba que fallaron xl_step_4$f_failed #> [1] 0.15385  # Simplemente imprimiendo la lista x nos # dirá qué hay disponible allí xl_step_4 #> ── The x-list for `small_table` ────────────────────────────────────── STEP 4 ── #> $time_start $time_end (POSIXct [1]) #> $label $tbl_name $tbl_src $tbl_src_details (chr [1]) #> $tbl (spec_tbl_df, tbl_df, tbl, and data.frame) #> $col_names $col_types (chr [8]) #> $i $type $columns $values $label $briefs (mixed [1]) #> $eval_error $eval_warning (lgl [1]) #> $capture_stack (list [1]) #> $n $n_passed $n_failed $f_passed $f_failed (num [1]) #> $warn $stop $notify (lgl [1]) #> $lang (chr [1]) #> ────────────────────────────────────────────────────────────────────────────────  # Una 'x-list' que no sea específica de # ningún paso tendrá mucha más información # y una estructura ligeramente diferente; ver # `help(get_agent_x_list)` para más información # get_agent_x_list(agent)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_informant.html","id":null,"dir":"Reference","previous_headings":"","what":"Crear un objeto pointblank informant — create_informant","title":"Crear un objeto pointblank informant — create_informant","text":"La función create_informant() crea un objeto informant, que se utiliza en un flujo de trabajo de gestión de información. El objetivo general de este flujo de trabajo es registrar, recopilar y generar información útil en tablas de datos. Podemos proporcionar cualquier información que sea útil para describir una tabla de datos en particular. El objeto informant creado por la función create_informant() toma funciones enfocadas en información: info_columns(), info_tabular(), info_section(), y info_snippet(). La serie de funciones info_*() permite una acumulación progresiva de información sobre la tabla de destino. Las funciones info_columns() y info_tabular() facilitan la entrada de texto de información que concierne las columnas de la tabla y la tabla propiamente dicha; la función info_section() permite la creación de secciones arbitrarias que pueden tener múltiples subsecciones llenas de texto de información adicional. El sistema permite valores dinámicos seleccionados de la tabla de destino mediante info_snippet(), para obtener extractos de texto con nombre de consultas y el uso de {<snippet_name>} en el texto de información. Para hacer el uso de info_snippet() más conveniente para consultas comunes, se proporciona un conjunto de funciones snip_*() en el paquete (snip_list(), snip_stats(), snip_lowest(), y snip_highest()) aunque puedes usar tus propias expresiones. Debido que los fragmentos necesitan consultar la tabla de destino para devolver fragmentos de texto de información, la función incorporate() debe usarse para iniciar esta acción. Esto también es necesario para que el informant actualice otros elementos de metadatos, como los recuentos de filas y columnas. Una vez que se complete el proceso de incorporación, se actualizarán los fragmentos y otros metadatos. Llamar al informant en sí mismo dará como resultado una tabla de informes. También se puede acceder este informe con la función get_informant_report(), donde hay más opciones de informe.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_informant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Crear un objeto pointblank informant — create_informant","text":"","code":"create_informant(   tbl = NULL,   read_fn = NULL,   agent = NULL,   tbl_name = NULL,   label = NULL,   lang = NULL,   locale = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_informant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Crear un objeto pointblank informant — create_informant","text":"tbl La tabla de entrada. Puede ser un marco de datos, un tibble, un objeto tbl_dbi o un objeto tbl_spark. Alternativamente, se puede usar una función para leer en la tabla de datos de entrada con el argumento read_fn (en cuyo caso, tbl puede ser NULL). read_fn Una función que se usa para leer los datos. Incluso si se proporciona un tbl, esta función se invocará para obtener los datos (es decir, el read_fn tiene prioridad). Hay dos formas de especificar un read_fn: (1) usando una función (por ejemplo, function () {<código de lectura de la tabla>}) o, (2) con una expresión de fórmula R. agent Un objeto agent quemarropa. Este objeto se puede utilizar en lugar de proporcionar una tabla en tbl o una fórmula de preparación de tablas en read_fn. tbl_name Un nombre opcional para asignar al objeto de la tabla de entrada. Si se proporciona ningún valor, se generará un nombre en función de la información disponible. label Una etiqueta opcional para el informe de información. Si se proporciona ningún valor, se generará una etiqueta basada en la hora actual del sistema. Markdown se puede utilizar aquí para hacer que la etiqueta sea más atractiva visualmente (aparecerá en el área de encabezado del informe de información). lang El idioma que se utilizará para el informe de información (una tabla de resumen que proporciona toda la información disponible para la tabla. De forma predeterminada, NULL creará texto en inglés (\"en\"). Otras opciones incluyen francés (\"fr\"), Alemán (\"de\"), italiano (\"\"), español (\"es\"), portugués (\"pt\"), turco (\"tr\"), chino (\"zh\"), ruso (\"ru\"), polaco (\"pl\"), danés (\"da\"), sueco (\"sv\") y holandés (\"nl\"). locale Un ID de configuración regional opcional que se utilizará para dar formato los valores en el informe de información de acuerdo con las reglas de la configuración regional. Los ejemplos incluyen \"en_US\" para inglés (Estados Unidos) y \"fr_FR\" para francés (Francia); más simplemente, puede ser un identificador de idioma sin una designación de país, como \"es\" para español (España, igual que \"es_ES\").","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_informant.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Crear un objeto pointblank informant — create_informant","text":"Un objeto ptblank_informant.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_informant.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Crear un objeto pointblank informant — create_informant","text":"Se puede escribir un informante pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un informante (con yaml_read_informant()) o realizar la acción 'incorporar' usando la tabla de destino (través de yaml_informant_incorporate()). Aquí hay un ejemplo de cómo una llamada compleja de create_informant() se expresa en código R y en la representación YAML correspondiente. El YAML generado incluye algunas claves de nivel superior donde type y read_fn son obligatorios, y dos secciones de metadatos: table y columns. Las claves que comienzan con un carácter de subrayado son las que se actualizan cada vez que se llama incorporate() en un informant. La sección de metadatos table puede tener múltiples subsecciones con texto de información. De manera similar, la sección de metadatos columns puede tener múltiples subsecciones, siempre que sean elementos secundarios de cada una de las claves de columna (en el ejemplo de YAML anterior, date_time y date son claves de columna y coinciden con los nombres de columna de la tabla). Se pueden agregar secciones adicionales, pero deben tener nombres de clave en el nivel superior que dupliquen el conjunto predeterminado (es decir, type, table, columns, etc. se tratan como claves reservadas).","code":"# Código R create_informant(   read_fn = ~ small_table,   tbl_name = \"small_table\",   label = \"Un ejemplo.\",   lang = \"fr\",    locale = \"fr_CA\" )  # Representación YAML type: informant read_fn: ~small_table tbl_name: small_table info_label: Un ejemplo. lang: fr locale: fr_CA table:   name: small_table   _columns: 8   _rows: 13.0   _type: tbl_df columns:   date_time:     _type: POSIXct, POSIXt   date:     _type: Date   a:     _type: integer   b:     _type: character   c:     _type: numeric   d:     _type: numeric   e:     _type: logical   f:     _type: character"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_informant.html","id":"escribir-un-objeto-informant-en-el-disco","dir":"Reference","previous_headings":"","what":"Escribir un objeto informant en el disco","title":"Crear un objeto pointblank informant — create_informant","text":"Se puede escribir un objeto informant en el disco con la función x_write_disk(). Los informantes se almacenan en formato RDS serializado y se pueden recuperar fácilmente con la función x_read_disk(). Se recomienda que las fórmulas de preparación de tablas se proporcionen al argumento read_fn de create_informant(). De esta manera, cuando se lee un informante desde el disco través de x_read_disk(), se puede reutilizar para acceder la tabla de destino (que puede cambiar, de ahí la necesidad de usar una expresión para esto).","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_informant.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Crear un objeto pointblank informant — create_informant","text":"1-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_informant.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Crear un objeto pointblank informant — create_informant","text":"","code":"# Veamos cómo podemos generar información # útil para una mesa realmente pequeña; en # realidad se llama `small_table` y podemos # encontrarlo como un conjunto de datos en # este paquete small_table #> # A tibble: 13 × 8 #>    date_time           date           a b             c      d e     f     #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high   # Cree un objeto `informant` en blanco con # `create_informant()` y el conjunto de # datos `small_table` informant <-    create_informant(     read_fn = ~small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\"   )  # Esta función crea información sin ninguna # ayuda adicional al perfilar el objeto de # tabla proporcionado; agrega las secciones: # (1) 'tabla' y (2) 'columnas' y podemos # imprimir el objeto para ver el informe # de información  # Alternativamente, podemos obtener el mismo # informe usando `get_informant_report()` report <- get_informant_report(informant) class(report) #> [1] \"ptblank_informant_report\" \"gt_tbl\"                   #> [3] \"list\""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_multiagent.html","id":null,"dir":"Reference","previous_headings":"","what":"Crear un objeto pointblank multiagent — create_multiagent","title":"Crear un objeto pointblank multiagent — create_multiagent","text":"Varios agents pueden formar parte de un solo objeto llamado multiagent. Esto puede ser útil cuando se reúnen varios agentes que han realizado interrogaciones en el pasado (quizás guardados en el disco con x_write_disk()). Cuando formamos parte de un multiagent, podemos obtener un informe que muestra cómo la calidad de los datos evolucionó con el tiempo. Esto puede ser de interés cuando es importante monitorear la calidad de los datos e incluso la evolución del propio plan de validación. La tabla de informes, generada imprimiendo un objeto ptblank_multiagent o usando la función get_multiagent_report(), está, por defecto, organizada por el tiempo de interrogación y reconoce automáticamente qué pasos de validación son equivalentes entre interrogaciones.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_multiagent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Crear un objeto pointblank multiagent — create_multiagent","text":"","code":"create_multiagent(..., lang = NULL, locale = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_multiagent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Crear un objeto pointblank multiagent — create_multiagent","text":"... Uno o más objetos de agent pointblank. lang El idioma que se utilizará para cualquier informe que se generará partir del multiagente. De forma predeterminada, NULL creará texto en inglés (\"en\"). Otras opciones incluyen francés (\"fr\"), alemán (\"de\"), italiano (\"\"), español (\"es\"), portugués (\"pt\"), turco (\"tr\"), chino (\"zh\"), ruso (\"ru\"), polaco (\"pl\"), danés (\"da\"), sueco (\"sv\") y holandés (\"nl\"). locale Un ID de configuración regional opcional que se utilizará para formatear valores en las salidas de informes de acuerdo con las reglas de la configuración regional. Los ejemplos incluyen \"en_US\" para inglés (Estados Unidos) y \"fr_FR\" para francés (Francia); más simplemente, puede ser un identificador de idioma sin una designación de país, como \"es\" para español (España, igual que \"es_ES\").","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_multiagent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Crear un objeto pointblank multiagent — create_multiagent","text":"Un objeto ptblank_multiagent.","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_multiagent.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Crear un objeto pointblank multiagent — create_multiagent","text":"10-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_multiagent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Crear un objeto pointblank multiagent — create_multiagent","text":"","code":"if (interactive()) {  # Repasemos varios análisis teóricos de # la calidad de los datos de una tabla # extremadamente pequeña; esa tabla se # llama `small_table` y podemos # encontrarla como un conjunto de datos # en este paquete small_table  # Para establecer límites de falla y # condiciones de señal, designamos # umbrales de falla proporcionales a # los estados `warn`, `stop` y # `notify` usando `action_levels()` al <-    action_levels(     warn_at = 0.05,     stop_at = 0.10,     notify_at = 0.20   )  # Crearemos cuatro agentes diferentes # y tendremos pasos de validación # ligeramente diferentes en cada uno # de ellos; en el primero, `agent_1`, # se crean ocho pasos de validación # diferentes y el agente interrogará # a la `small_table` agent_1 <-   create_agent(     read_fn = ~ small_table,     label = \"Un ejemplo.\",     actions = al   ) %>%   col_vals_gt(     vars(date_time),     value = vars(date),     na_pass = TRUE   ) %>%   col_vals_gt(     vars(b),      value = vars(g),     na_pass = TRUE   ) %>%   rows_distinct() %>%   col_vals_equal(     vars(d),      value = vars(d),     na_pass = TRUE   ) %>%   col_vals_between(     vars(c),      left = vars(a), right = vars(d)   ) %>%   col_vals_not_between(     vars(c),     left = 10, right = 20,     na_pass = TRUE   ) %>%   rows_distinct(vars(d, e, f)) %>%   col_is_integer(vars(a)) %>%   interrogate()  # El segundo agente, `agent_2`, # conserva todos los pasos de `agent_1` # y agrega dos más (el último de los # cuales está inactivo) agent_2 <-    agent_1 %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b),      regex = \"[0-9]-[a-z]{3}-[0-9]{3}\",     active = FALSE   ) %>%   interrogate()  # El tercer agente, `agent_3`, agrega # un solo paso de validación, elimina # el quinto y desactiva el primero agent_3 <-    agent_2 %>%   col_vals_in_set(     vars(f),     set = c(\"low\", \"mid\", \"high\")   ) %>%   remove_steps(i = 5) %>%   deactivate_steps(i = 1) %>%   interrogate()  # El cuarto y último agente, `agent_4`, # reactiva los pasos 1 y 10, y elimina # el sexto paso agent_4 <-   agent_3 %>%   activate_steps(i = 1) %>%   activate_steps(i = 10) %>%   remove_steps(i = 6) %>%   interrogate()  # Si bien todos los agentes son # ligeramente diferentes entre sí, aún # podemos obtener un informe combinado # de ellos creando un objeto 'multiagent' multiagent <-   create_multiagent(     agent_1, agent_2, agent_3, agent_4   )  # Llamar a un objeto `multiagent` en # la consola imprime el informe # multiagente; pero podemos obtener un # objeto `gt_tbl` con la función # `get_multiagent_report()` report <- get_multiagent_report(multiagent)  class(report)  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/db_tbl.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtener una tabla de una base de datos — db_tbl","title":"Obtener una tabla de una base de datos — db_tbl","text":"Si su tabla de destino está en una base de datos, la función db_tbl() es una forma práctica de acceder ella. Esta función simplifica el proceso de obtener un objeto tbl_dbi, que generalmente implica una combinación de construir una conexión una base de datos y usar la función dplyr::tbl() con la conexión y el nombre de la tabla (o una referencia una tabla en un esquema). Puede usar db_tbl() como base para obtener una tabla de base de datos para el parámetro read_fn en create_agent() o create_informant(). Esto se puede hacer usando un ~ antes de la llamada db_tbl() (por ejemplo, read_fn = ~ db_tbl (...)). Otra gran opción es proporcionar una fórmula de preparación de tablas que involucre db_tbl() tbl_store() para que tenga acceso las tablas de la base de datos través de nombres únicos través de un almacén de tablas. El nombre de usuario y la contraseña se proporcionan través de variables de entorno. Si lo desea, estos se pueden proporcionar directamente encerrando esos valores en ().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/db_tbl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtener una tabla de una base de datos — db_tbl","text":"","code":"db_tbl(   table,   dbname,   dbtype,   host = NULL,   port = NULL,   user = NULL,   password = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/db_tbl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtener una tabla de una base de datos — db_tbl","text":"table El nombre de la tabla, o una referencia una tabla en un esquema (vector de dos elementos con los nombres de esquema y tabla). Alternativamente, esto se puede proporcionar como una tabla de datos para copiar en una conexión de base de datos en memoria. Esto solo funciona si: (1) el db es \"sqlite\" o \"duckdb\" , (2) el dbname fue elegido como \":memory:\", y (3) el data_tbl es un marco de datos o un objeto tibble. dbname El nombre de la base de datos. dbtype Ya sea una función de controlador apropiada (por ejemplo, RPostgres::Postgres()) o un nombre corto para el tipo de base de datos. Los nombres válidos son: \"postgresql\", \"postgres\", o \"pgsql\" (PostgreSQL, usando la función del controlador RPostgres::Postgres()); \"mysql\" (MySQL, usando RMySQL::MySQL()); \"duckdb\" (DuckDB, usando duckdb::duckdb()); y \"sqlite\" (SQLite, usando RSQLite::SQLite()). host, port El host de la base de datos y el número de puerto opcional. user, password Las variables de entorno utilizadas para acceder al nombre de usuario y la contraseña de la base de datos.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/db_tbl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtener una tabla de una base de datos — db_tbl","text":"Un objeto tbl_dbi.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/db_tbl.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Obtener una tabla de una base de datos — db_tbl","text":"1-6","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/db_tbl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtener una tabla de una base de datos — db_tbl","text":"","code":"# Puede usar una tabla de base de # datos en memoria y proporcionarle # una tabla en memoria también: small_table_duckdb <-    db_tbl(     table = small_table,     dbname = \":memory:\",     dbtype = \"duckdb\"   )  if (interactive()) {  # También es posible obtener un # archivo remoto y guardarlo en una # base de datos en memoria; use el # combo `file_tbl()` + `db_tbl()` all_revenue_large_duckdb <-   db_tbl(     table = file_tbl(       file = from_github(         file = \"all_revenue_large.rds\",         repo = \"rich-iannone/intendo\",         subdir = \"data-large\"       )     ),     dbname = \":memory:\",     dbtype = \"duckdb\"   )  # Para las bases de datos remotas, # es muy similar; aquí hay un ejemplo # que accede a la tabla `rna` (en la # base de datos pública de RNA Central) # usando `db_tbl()` rna_db_tbl <-    db_tbl(     table = \"rna\",     dbname = \"pfmegrnargs\",     dbtype = \"postgres\",      host = \"hh-pgsql-public.ebi.ac.uk\",     port = 5432,     user = I(\"reader\"),     password = I(\"NWDMCE5xdipIjRrp\")   )  # El uso de `I()` para el nombre de # usuario y la contraseña significa que # está pasando los valores reales pero, # normalmente, querrá usar los nombres # de las variables de entorno (envvars) # para acceder de forma segura a los # valores de nombre de usuario y # contraseña apropiados cuando se # conecte a una base de datos: example_db_tbl <-    db_tbl(     table = \"<table_name>\",     dbname = \"<database_name>\",     dbtype = \"<database_type_shortname>\",      host = \"<connection_url>\",     port = \"<connection_port>\",     user = \"<DB_USER_NAME>\",     password = \"<DB_PASSWORD>\"   )  # Las variables de entorno se pueden # crear editando el archivo de usuario # `.Renviron` y la función # `usethis::edit_r_environ()` hace que # esto sea bastante fácil de hacer  # El almacenamiento de fórmulas de # preparación de tablas en una tienda # de tablas facilita el trabajo con # tablas de base de datos en blanco; # aquí se explica cómo generar un # almacén de tablas con dos entradas # con nombre para la preparación de # la tabla tbls <-   tbl_store(     small_table_duck ~ db_tbl(       table = pointblank::small_table,       dbname = \":memory:\",       dbtype = \"duckdb\"     ),     small_high_duck ~ db_tbl(       table = pointblank::small_table,       dbname = \":memory:\",       dbtype = \"duckdb\"     ) %>%       dplyr::filter(f == \"high\")   )  # Ahora es fácil acceder a cualquiera # de estas tablas (la segunda es una # versión mutada) a través de la # función `tbl_get()` tbl_get(\"small_table_duck\", store = tbls) tbl_get(\"small_high_duck\", store = tbls)  # Las fórmulas de preparación de tablas # en `tbls` también podrían usarse en # funciones con el argumento `read_fn`; # esto es gracias a la función # `tbl_source()` agent <-    create_agent(     read_fn = ~ tbl_source(       \"small_table_duck\",       store = tbls     )   )  informant <-    create_informant(     read_fn = ~ tbl_source(       \"small_high_duck\",       store = tbls     )   )  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/deactivate_steps.html","id":null,"dir":"Reference","previous_headings":"","what":"Desactive uno o más de los pasos de validación de un agent — deactivate_steps","title":"Desactive uno o más de los pasos de validación de un agent — deactivate_steps","text":"Si fuera necesario desactivar uno o más pasos de validación después de la creación del plan de validación para un agent, la función deactivate_steps() será útil para ello. Esto tiene el mismo efecto que usar la opción active = FALSE (active es un argumento en todas las funciones de validación) para los pasos de validación seleccionados. Tenga en cuenta que esto edita directamente el paso de validación, eliminando cualquier función que pueda haber sido definida para si el paso debería estar activo o .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/deactivate_steps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Desactive uno o más de los pasos de validación de un agent — deactivate_steps","text":"","code":"deactivate_steps(agent, i = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/deactivate_steps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Desactive uno o más de los pasos de validación de un agent — deactivate_steps","text":"agent Un objeto de agente de clase ptblank_agent. El número de paso de validación, que se asigna cada paso de validación en el orden de definición.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/deactivate_steps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Desactive uno o más de los pasos de validación de un agent — deactivate_steps","text":"Un objeto ptblank_agent.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/deactivate_steps.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Desactive uno o más de los pasos de validación de un agent — deactivate_steps","text":"9-7","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/deactivate_steps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Desactive uno o más de los pasos de validación de un agent — deactivate_steps","text":"","code":"# Cree un agente que tenga el objeto # `small_table` como tabla de destino, # agregue algunos pasos de validación # y luego use `interrogate()` agent_1 <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\"   ) %>%   col_exists(vars(date)) %>%   col_vals_regex(     vars(b),     regex = \"[0-9]-[a-z]{3}-[0-9]\"   ) %>%   interrogate()    # El segundo paso de validación # se está reconsiderando ahora y # puede eliminarse gradualmente o # mejorarse; en el período # intermedio se decidió que el paso # debería desactivarse por ahora agent_2 <-   agent_1 %>%   deactivate_steps(i = 2) %>%   interrogate() #> ℹ Step 2 is not set as active. Skipping."},{"path":"https://rich-iannone.github.io/pointblank/es/reference/draft_validation.html","id":null,"dir":"Reference","previous_headings":"","what":"Redacte un archivo inicial pointblank validation .R / .Rmd con una tabla\nde datos — draft_validation","title":"Redacte un archivo inicial pointblank validation .R / .Rmd con una tabla\nde datos — draft_validation","text":"Genere un borrador del plan de validación en un nuevo archivo .R o .Rmd usando una tabla de datos de entrada. Con este flujo de trabajo, se escaneará la tabla de datos para conocer los datos de su columna y se escribirá un conjunto de pasos de validación de inicio (que constituyen un plan de validación). Es mejor utilizar un extracto de datos que contenga al menos 1000 filas y que esté relativamente libre de datos falsos. Una vez en el archivo, es posible modificar los pasos de validación para que se ajusten mejor las expectativas del dominio en particular. Si bien la inferencia de columna se utiliza para generar planes de validación razonables, es difícil inferir los valores aceptables sin experiencia en el dominio. Sin embargo, usar draft_validation() podría ayudarlo comenzar en el piso 10 para abordar los problemas de calidad de los datos y, en cualquier caso, es mejor que comenzar con una vista de editor de código vacía.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/draft_validation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Redacte un archivo inicial pointblank validation .R / .Rmd con una tabla\nde datos — draft_validation","text":"","code":"draft_validation(   tbl,   tbl_name = NULL,   file_name = tbl_name,   path = NULL,   lang = NULL,   output_type = c(\"R\", \"Rmd\"),   add_comments = TRUE,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/draft_validation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Redacte un archivo inicial pointblank validation .R / .Rmd con una tabla\nde datos — draft_validation","text":"tbl La tabla de entrada. Puede ser un marco de datos, tibble, un objeto tbl_dbi o un objeto tbl_spark. tbl_name Un nombre opcional para asignar al objeto de la tabla de entrada. Si se proporciona ningún valor, se generará un nombre en función de la información disponible. Este nombre de tabla se mostrará en el área de encabezado del informe del agente generado al imprimir el agent o llamar get_agent_report(). file_name Un nombre opcional para el archivo .R o .Rmd. Debe ser un nombre sin extensión. Por defecto, esto se toma del tbl_name pero si se proporciona nada para eso, el nombre contendrá el texto \"draft_validation_\" seguido de la fecha y hora actuales. path Aquí se puede especificar una ruta si se debe intentar colocar el archivo generado en el directorio de trabajo. lang El idioma que se utilizará al crear comentarios para los pasos de validación generados automáticamente. De forma predeterminada, NULL creará texto en inglés (\"en\"). Otras opciones incluyen francés (\"fr\"), alemán (\"de\"), italiano (\"\"), español (\"es\"), portugués (\"pt\"), turco (\"tr\"), chino (\"zh\"), ruso (\"ru\"), polaco (\"pl\"), danés (\"da\"), sueco (\"sv\" ) y holandés (\"nl\"). output_type Una opción para elegir qué tipo de salida se debe generar. De forma predeterminada, este es un script .R (\"R\") pero podría ser alternativamente un documento R Markdown (\"Rmd\"). add_comments ¿Debería haber comentarios que expliquen las características del plan de validación en el documento generado? De forma predeterminada, es TRUE. overwrite ¿Debería sobrescribirse un archivo con el mismo nombre? De forma predeterminada, es FALSE. quiet ¿Debería la función informar cuando se escribe el archivo? Por defecto, esto es FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/draft_validation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Redacte un archivo inicial pointblank validation .R / .Rmd con una tabla\nde datos — draft_validation","text":"Devuelve de forma invisible TRUE si el archivo se ha escrito.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/draft_validation.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Redacte un archivo inicial pointblank validation .R / .Rmd con una tabla\nde datos — draft_validation","text":"1-11","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/draft_validation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Redacte un archivo inicial pointblank validation .R / .Rmd con una tabla\nde datos — draft_validation","text":"","code":"if (interactive()) {  # Proyecto de plan de validación # para la tabla `dplyr::storms` draft_validation(tbl = dplyr::storms)  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/email_blast.html","id":null,"dir":"Reference","previous_headings":"","what":"Envíe un correo electrónico en un paso de validación o al final de un\ninterrogatorio — email_blast","title":"Envíe un correo electrónico en un paso de validación o al final de un\ninterrogatorio — email_blast","text":"email_blast() function useful sending email message explains result pointblank validation. powered blastula glue packages. function invoked part end_fns argument create_agent(). also possible invoke email_blast() part fns argument action_levels() function (.e., send multiple email messages granularity different validation steps exceeding failure thresholds). better get handle emailing email_blast(), analogous email_create() function can used pointblank agent object x-list obtained using get_agent_x_list() function.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/email_blast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Envíe un correo electrónico en un paso de validación o al final de un\ninterrogatorio — email_blast","text":"","code":"email_blast(   x,   to,   from,   credentials = NULL,   msg_subject = NULL,   msg_header = NULL,   msg_body = stock_msg_body(),   msg_footer = stock_msg_footer(),   send_condition = ~TRUE %in% x$notify )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/email_blast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Envíe un correo electrónico en un paso de validación o al final de un\ninterrogatorio — email_blast","text":"x reference x-list object prepared internally agent. version x-list generated via get_agent_x_list(<agent>) except version internally generated hence available internal evaluation context. , email addresses recipients sender. credentials credentials list object produced either blastula::creds(), blastula::creds_anonymous(), blastula::creds_key(), blastula::creds_file() functions. Please refer blastula documentation information use functions. msg_subject subject line email message. msg_header, msg_body, msg_footer Content header, body, footer components HTML email message. send_condition expression evaluate logical vector length 1. evaluated TRUE email sent, FALSE happen. expression can use x-list variables (e.g., x$notify, x$type, etc.) variables can explored using get_agent_x_list() function. default expression ~TRUE %% x$notify, results TRUE TRUE values x$notify logical vector (.e., validation step results 'notify' condition).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/email_blast.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Envíe un correo electrónico en un paso de validación o al final de un\ninterrogatorio — email_blast","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). example use email_blast() inside end_fns argument create_agent() expressed R code corresponding YAML representation.","code":"# Código R create_agent(   read_fn = ~ small_table,   tbl_name = \"small_table\",   label = \"Un ejemplo.\",   actions = al,   end_fns = list(     ~ email_blast(       x,       to = \"joe_public@example.com\",       from = \"pb_notif@example.com\",       msg_subject = \"Table Validation\",       credentials = blastula::creds_key(         id = \"smtp2go\"       ),     )   ) ) %>%   col_vals_gt(vars(a), 1) %>%   col_vals_lt(vars(a), 7)   # Representación YAML type: agent read_fn: ~small_table tbl_name: small_table label: Un ejemplo. lang: en locale: en actions:   warn_count: 1.0   notify_count: 2.0 end_fns: ~email_blast(x, to = \"joe_public@example.com\",    from = \"pb_notif@example.com\", msg_subject = \"Table Validation\",   credentials = blastula::creds_key(id = \"smtp2go\"),   ) embed_report: true steps:   - col_vals_gt:     columns: vars(a)     value: 1.0   - col_vals_lt:     columns: vars(a)     value: 7.0"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/email_blast.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Envíe un correo electrónico en un paso de validación o al final de un\ninterrogatorio — email_blast","text":"4-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/email_blast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Envíe un correo electrónico en un paso de validación o al final de un\ninterrogatorio — email_blast","text":"","code":"# Create an `action_levels()` list # with absolute values for the # `warn`, and `notify` states (with # thresholds of 1 and 2 'fail' units) al <-    action_levels(     warn_at = 1,     notify_at = 2   )    if (interactive()) {  # Validate that values in column # `a` from `small_tbl` are always > 1 # and that they are always < 7; first, # apply the `actions_levels()` # directive to `actions` and set up # an `email_blast()` as one of the # `end_fns` (by default, the email # will be sent if there is a single # 'notify' state across all # validation steps) agent <-   create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\",     actions = al,     end_fns = list(       ~ email_blast(         x,         to = \"joe_public@example.com\",         from = \"pb_notif@example.com\",         msg_subject = \"Table Validation\",         credentials = blastula::creds_key(           id = \"smtp2go\"         ),       )     )   ) %>%   col_vals_gt(vars(a), value = 1) %>%   col_vals_lt(vars(a), value = 7) %>%   interrogate()  }  # The above example was intentionally # not run because email credentials # aren't available and the `to` # and `from` email addresses are # nonexistent  # To get a blastula email object # instead of eagerly sending the # message, we can use the  # `email_create()` function email_object <-   create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\",     actions = al   ) %>%   col_vals_gt(vars(a), value = 5) %>%   col_vals_lt(vars(a), value = 7) %>%   interrogate() %>%   email_create()"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/email_create.html","id":null,"dir":"Reference","previous_headings":"","what":"Cree un objeto de correo electrónico a partir de un pointblank agent o\ninformant — email_create","title":"Cree un objeto de correo electrónico a partir de un pointblank agent o\ninformant — email_create","text":"email_create() function produces email message object sent using blastula package. x need either pointblank agent, agent x-list (produced agent get_agent_x_list() function), pointblank informant. cases, email message appear Viewer blastula email_message object returned.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/email_create.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cree un objeto de correo electrónico a partir de un pointblank agent o\ninformant — email_create","text":"","code":"email_create(   x,   msg_header = NULL,   msg_body = stock_msg_body(),   msg_footer = stock_msg_footer() )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/email_create.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cree un objeto de correo electrónico a partir de un pointblank agent o\ninformant — email_create","text":"x pointblank agent, agent x-list, pointblank informant. x-list object can created get_agent_x_list() function. recommended option = NULL used get_agent_x_list() supplying x-list x. Furthermore, option generate_report = TRUE used create_agent() agent report available within email. msg_header, msg_body, msg_footer Content header, body, footer components HTML email message.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/email_create.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cree un objeto de correo electrónico a partir de un pointblank agent o\ninformant — email_create","text":"blastulaemail_message object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/email_create.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Cree un objeto de correo electrónico a partir de un pointblank agent o\ninformant — email_create","text":"4-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/email_create.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cree un objeto de correo electrónico a partir de un pointblank agent o\ninformant — email_create","text":"","code":"if (interactive()) {  # Create an `action_levels()` list # with absolute values for the # `warn`, and `notify` states (with # thresholds of 1 and 2 'fail' units) al <-    action_levels(     warn_at = 1,     notify_at = 2   )  # In a workflow that involves an # `agent` object, we can make use of # the `end_fns` argument and # programmatically email the report # with the `email_blast()` function, # however, an alternate workflow is to # produce the email object and choose # to send outside of the pointblank API; # the `email_create()` function lets # us do this with an `agent` object email_object_1 <-   create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\",     actions = al   ) %>%   col_vals_gt(vars(a), value = 1) %>%   col_vals_lt(vars(a), value = 7) %>%   interrogate() %>%   email_create()  # We can view the HTML email just # by printing `email_object`; it # should appear in the Viewer  # The `email_create()` function can # also be used on an agent x-list to # get the same email message object email_object_2 <-   create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\",     actions = al   ) %>%   col_vals_gt(vars(a), value = 5) %>%   col_vals_lt(vars(b), value = 5) %>%   interrogate() %>%   get_agent_x_list() %>%   email_create()  # An information report that's # produced by the informant can # made into an email message object; # let's create an informant and use # `email_create()` email_object_3 <-   create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\"   ) %>%   info_tabular(     info = \"A simple table in the     *Examples* section of the function     called `email_create()`.\"   ) %>%   info_columns(     columns = vars(a),     info = \"Numbers. On the high side.\"   ) %>%   info_columns(     columns = vars(b),     info = \"Lower numbers. Zeroes, even.\"   ) %>%   incorporate() %>%   email_create()  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/export_report.html","id":null,"dir":"Reference","previous_headings":"","what":"Exportar un agent, informant, multiagent o escaneo de tabla a HTML — export_report","title":"Exportar un agent, informant, multiagent o escaneo de tabla a HTML — export_report","text":"agent, informant, multiagent, table scan object can easily written HTML export_report(). Furthermore, report objects agent, informant, multiagent (generated using get_agent_report(), get_informant_report(), get_multiagent_report()) can provided HTML export. HTML document written disk self-contained easily viewable web browser.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/export_report.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exportar un agent, informant, multiagent o escaneo de tabla a HTML — export_report","text":"","code":"export_report(x, filename, path = NULL, quiet = FALSE)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/export_report.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exportar un agent, informant, multiagent o escaneo de tabla a HTML — export_report","text":"x agent object class ptblank_agent, informant class ptblank_informant, multiagent class ptblank_multiagent, table scan class ptblank_tbl_scan, , customized reporting objects (ptblank_agent_report, ptblank_informant_report, ptblank_multiagent_report.wide, ptblank_multiagent_report.long). filename filename create disk HTML export object provided. recommended extension \".html\" included. path optional path file saved (automatically combined filename). quiet function inform file written? default FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/export_report.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exportar un agent, informant, multiagent o escaneo de tabla a HTML — export_report","text":"Invisibly returns TRUE file written.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/export_report.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Exportar un agent, informant, multiagent o escaneo de tabla a HTML — export_report","text":"9-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/export_report.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exportar un agent, informant, multiagent o escaneo de tabla a HTML — export_report","text":"","code":"if (interactive()) {  # A: Writing an agent report as HTML   # Let's go through the process of (1) # developing an agent with a validation # plan (to be used for the data quality # analysis of the `small_table` dataset), # (2) interrogating the agent with the # `interrogate()` function, and (3) writing # the agent and all its intel to a file  # Creating an `action_levels` object is a # common workflow step when creating a # pointblank agent; we designate failure # thresholds to the `warn`, `stop`, and # `notify` states using `action_levels()` al <-    action_levels(     warn_at = 0.10,     stop_at = 0.25,     notify_at = 0.35   )  # Now create a pointblank `agent` object # and give it the `al` object (which # serves as a default for all validation # steps which can be overridden); the # data will be referenced in a `read_fn` agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"`export_report()`\",     actions = al   )  # Then, as with any agent object, we # can add steps to the validation plan by # using as many validation functions as we # want; then, we `interrogate()` agent <-   agent %>%    col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b), regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5) %>%   interrogate()  # The agent report can be written to an # HTML file with `export_report()` export_report(   agent,   filename = \"agent-small_table.html\" )  # If you're consistently writing agent # reports when periodically checking data, # we could make use of `affix_date()` or # `affix_datetime()` depending on the # granularity you need; here's an example # that writes the file with the format: # 'agent-small_table-YYYY-mm-dd_HH-MM-SS.html' export_report(   agent,   filename = affix_datetime(     \"agent-small_table.html\"   ) )  # B: Writing an informant report as HTML  # Let's go through the process of (1) # creating an informant object that # minimally describes the `small_table` # dataset, (2) ensuring that data is # captured from the target table using # the `incorporate()` function, and (3) # writing the informant report to HTML  # Create a pointblank `informant` # object with `create_informant()` # and the `small_table` dataset; # `incorporate()` so that info snippets # are integrated into the text informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"`export_report()`\"   ) %>%   info_snippet(     snippet_name = \"high_a\",     fn = snip_highest(column = \"a\")   ) %>%   info_snippet(     snippet_name = \"low_a\",     fn = snip_lowest(column = \"a\")   ) %>%   info_columns(     columns = vars(a),     info = \"From {low_a} to {high_a}.\"   ) %>%   info_columns(     columns = starts_with(\"date\"),     info = \"Time-based values.\"   ) %>%   info_columns(     columns = \"date\",     info = \"The date part of `date_time`.\"   ) %>%   incorporate()  # The informant report can be written # to an HTML file with `export_report()`; # let's do this with `affix_date()` so # the filename has a datestamp export_report(   informant,   filename = affix_date(     \"informant-small_table.html\"   ) )  # C: Writing a table scan as HTML  # We can get an report that describes all # of the data in the `storms` dataset tbl_scan <- scan_data(tbl = dplyr::storms)  # The table scan object can be written # to an HTML file with `export_report()` export_report(   tbl_scan,   filename = \"tbl_scan-storms.html\" )  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/file_tbl.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtener una tabla de un archivo local o remoto — file_tbl","title":"Obtener una tabla de un archivo local o remoto — file_tbl","text":"target table file, stored either locally remotely, file_tbl() function can make possible access single function call. Compatible file types function : CSV (.csv), TSV (.tsv), RDA (.rda), RDS (.rds) files. function generates -memory tbl_dbl object, can used target table create_agent() create_informant(). ideal option data access file_tbl() using function read_fn parameter either aforementioned create_*() functions. can done using leading ~ (e.g,. read_fn = ~file_tbl(...)). remote data use case, can specify URL starting http://, https://, etc., ending file containing data table. data files available GitHub repository can use from_github() function specify name location table data repository.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/file_tbl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtener una tabla de un archivo local o remoto — file_tbl","text":"","code":"file_tbl(file, type = NULL, ..., keep = FALSE, verify = TRUE)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/file_tbl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtener una tabla de un archivo local o remoto — file_tbl","text":"file complete file path leading compatible data table either user system http://, https://, ftp://, ftps:// URL. file hosted GitHub repository, call from_github() function can used . type file type. normally inferred file extension default NULL indicate extension dictate type file reading performed internally. However, extension (valid extensions .csv, .tsv, .rda, .rds), can provide type either csv, tsv, rda, rds. ... Options passed readr's read_csv() read_tsv() function. functions arguments one used internally based file extension explicit value given type. keep case downloaded file, stored working directory (keep = TRUE) downloaded temporary directory? default, FALSE. verify TRUE (default) verification data object data.frame class carried .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/file_tbl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtener una tabla de un archivo local o remoto — file_tbl","text":"Un objeto tbl_df.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/file_tbl.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Obtener una tabla de un archivo local o remoto — file_tbl","text":"1-7","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/file_tbl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtener una tabla de un archivo local o remoto — file_tbl","text":"","code":"# A local CSV file can be obtained as # a tbl object by supplying a path to # the file and some CSV reading options # (the ones used by `readr::read_csv()`) # to the `file_tbl()` function; for # this example we could obtain a path # to a CSV file in the pointblank # package with `system.file()`: csv_path <-    system.file(     \"data_files\", \"small_table.csv\",     package = \"pointblank\"   )  # Then use that path in `file_tbl()` # with the option to specify the column # types in that CSV   tbl <-    file_tbl(     file = csv_path,     col_types = \"TDdcddlc\"   )    # Now that we have a `tbl` object that # is a tibble, it can be introduced to # `create_agent()` for validation agent <- create_agent(tbl = tbl)  # A different strategy is to provide # the data-reading function call # directly to `create_agent()`: agent <-    create_agent(     read_fn = ~ file_tbl(       file = system.file(         \"data_files\", \"small_table.csv\",         package = \"pointblank\"       ),       col_types = \"TDdcddlc\"     )   ) %>%   col_vals_gt(vars(a), value = 0)  # All of the file-reading instructions # are encapsulated in the `read_fn` so # the agent will always obtain the most # recent version of the dataset (and the # logic can be translated to YAML, for # later use)  if (interactive()) {  # A CSV can be obtained from a public # GitHub repo by using the `from_github()` # helper function; let's create an agent # a supply a table-prep formula that # gets the same CSV file from the GitHub # repository for the pointblank package  agent <-    create_agent(     read_fn = ~ file_tbl(       file = from_github(         file = \"inst/data_files/small_table.csv\",         repo = \"rich-iannone/pointblank\"       ),       col_types = \"TDdcddlc\"     )   ) %>%   col_vals_gt(vars(a), value = 0) %>%   interrogate()  # This interrogated the data that was # obtained from the remote source file, # and, there's nothing to clean up (by # default, the downloaded file goes into # a system temp directory)  # Storing table-prep formulas in a table # store makes it easier to work with # tabular data originating from files; # here's how to generate a table store # with two named entries for table # preparations tbls <-   tbl_store(     small_table_file ~ file_tbl(       file = system.file(         \"data_files\", \"small_table.csv\",         package = \"pointblank\"       ),       col_types = \"TDdcddlc\"     ),     small_high_file ~ file_tbl(       file = system.file(         \"data_files\", \"small_table.csv\",         package = \"pointblank\"       ),       col_types = \"TDdcddlc\"     ) %>%       dplyr::filter(f == \"high\")   )  # Now it's easy to access either of these # tables (the second is a mutated version) # via the `tbl_get()` function tbl_get(\"small_table_file\", store = tbls) tbl_get(\"small_high_file\", store = tbls)  # The table-prep formulas in `tbls` # could also be used in functions with # the `read_fn` argument; this is thanks # to the `tbl_source()` function agent <-    create_agent(     read_fn = ~ tbl_source(       \"small_table_file\",       store = tbls     )   )  informant <-    create_informant(     read_fn = ~ tbl_source(       \"small_high_file\",       store = tbls     )   )  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/from_github.html","id":null,"dir":"Reference","previous_headings":"","what":"Especificar un archivo para descargar desde GitHub — from_github","title":"Especificar un archivo para descargar desde GitHub — from_github","text":"from_github() function helpful generating valid URL points data file public GitHub repository. function can used file argument file_tbl() function anywhere else GitHub URLs raw user content needed.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/from_github.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Especificar un archivo para descargar desde GitHub — from_github","text":"","code":"from_github(file, repo, subdir = NULL, default_branch = \"main\")"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/from_github.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Especificar un archivo para descargar desde GitHub — from_github","text":"file name file target GitHub repository. can path leading including file. combined path given subdir. repo GitHub repository address format username/repo[/subdir][@ref|#pull|@*release]. subdir path string representing subdirectory GitHub repository. combined path components included file.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/from_github.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Especificar un archivo para descargar desde GitHub — from_github","text":"character vector length 1 contains URL.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/from_github.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Especificar un archivo para descargar desde GitHub — from_github","text":"13-6","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/from_github.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Especificar un archivo para descargar desde GitHub — from_github","text":"","code":"# A valid URL to a data file in GitHub can be # obtained from the HEAD of the default branch # from_github( #   file = \"inst/data_files/small_table.csv\", #   repo = \"rich-iannone/pointblank\" # )  # The path to the file location can be supplied # fully or partially to `subdir` # from_github( #   file = \"small_table.csv\", #   repo = \"rich-iannone/pointblank\", #   subdir = \"inst/data_files\" # )  # We can use the first call in combination with # `file_tbl()` and `create_agent()`; this # supplies a table-prep formula that gets # a CSV file from the GitHub repository for the # pointblank package  # agent <-  #   create_agent( #     read_fn = ~ file_tbl( #       file = from_github( #         file = \"inst/data_files/small_table.csv\", #         repo = \"rich-iannone/pointblank\" #       ), #       col_types = \"TDdcddlc\" #     ) #   ) %>% #   col_vals_gt(vars(a), 0) %>% #   interrogate()  # The `from_github()` helper function is # pretty powerful and can get at lots of # different files in a repository  # A data file from GitHub can be obtained from # a commit at release time # from_github( #   file = \"inst/extdata/small_table.csv\", #   repo = \"rich-iannone/pointblank@v0.2.1\" # )  # A file may also be obtained from a repo at the # point in time of a specific commit (partial or # full SHA-1 hash for the commit can be used) # from_github( #   file = \"data-raw/small_table.csv\", #   repo = \"rich-iannone/pointblank@e04a71\" # )  # A file may also be obtained from an # *open* pull request # from_github( #   file = \"data-raw/small_table.csv\", #   repo = \"rich-iannone/pointblank#248\" # )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/game_revenue.html","id":null,"dir":"Reference","previous_headings":"","what":"Una tabla con datos de ingresos del juego — game_revenue","title":"Una tabla con datos de ingresos del juego — game_revenue","text":"Esta tabla es un subconjunto de la tabla sj_all_revenue del paquete de datos intendo. Son las primeras 2000 filas de esa tabla donde los registros de ingresos van desde 2015-01-01 hasta 2015-01-21.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/game_revenue.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Una tabla con datos de ingresos del juego — game_revenue","text":"","code":"game_revenue"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/game_revenue.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Una tabla con datos de ingresos del juego — game_revenue","text":"tibble 2,000 rows 11 variables: player_id character column unique identifiers user/player. session_id character column contains unique identifiers player session. session_start date-time column indicates session (containing revenue event) started. time date-time column indicates exactly player purchase (revenue event) occurred. item_type character column provides class item purchased. item_name character column provides name item purchased. item_revenue numeric column revenue amounts per item purchased. session_duration numeric column states length session (minutes) purchase occurred. start_day Date column provides date first login player making purchase. acquisition character column provides method acquisition player. country character column provides probable country residence player.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/game_revenue.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Una tabla con datos de ingresos del juego — game_revenue","text":"14-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/game_revenue.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Una tabla con datos de ingresos del juego — game_revenue","text":"","code":"# Aquí hay un vistazo a los datos # disponibles en `game_revenue` dplyr::glimpse(game_revenue) #> Rows: 2,000 #> Columns: 11 #> $ player_id        <chr> \"ECPANOIXLZHF896\", \"ECPANOIXLZHF896\", \"ECPANOIXLZHF89… #> $ session_id       <chr> \"ECPANOIXLZHF896-eol2j8bs\", \"ECPANOIXLZHF896-eol2j8bs… #> $ session_start    <dttm> 2015-01-01 01:31:03, 2015-01-01 01:31:03, 2015-01-01… #> $ time             <dttm> 2015-01-01 01:31:27, 2015-01-01 01:36:57, 2015-01-01… #> $ item_type        <chr> \"iap\", \"iap\", \"iap\", \"ad\", \"ad\", \"ad\", \"ad\", \"ad\", \"a… #> $ item_name        <chr> \"offer2\", \"gems3\", \"gold7\", \"ad_20sec\", \"ad_5sec\", \"a… #> $ item_revenue     <dbl> 8.991, 22.491, 107.991, 0.760, 0.030, 0.070, 0.080, 1… #> $ session_duration <dbl> 16.3, 16.3, 16.3, 16.3, 35.2, 35.2, 35.2, 35.2, 35.2,… #> $ start_day        <date> 2015-01-01, 2015-01-01, 2015-01-01, 2015-01-01, 2015… #> $ acquisition      <chr> \"google\", \"google\", \"google\", \"google\", \"google\", \"go… #> $ country          <chr> \"Germany\", \"Germany\", \"Germany\", \"Germany\", \"Germany\"…"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/game_revenue_info.html","id":null,"dir":"Reference","previous_headings":"","what":"Una tabla con metadatos para el conjunto de datos game_revenue — game_revenue_info","title":"Una tabla con metadatos para el conjunto de datos game_revenue — game_revenue_info","text":"table contains metadata game_revenue table. first column (named column) provides column names game_revenue. second column (info) contains descriptions columns dataset. table correct format use info_columns_from_tbl() function.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/game_revenue_info.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Una tabla con metadatos para el conjunto de datos game_revenue — game_revenue_info","text":"","code":"game_revenue_info"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/game_revenue_info.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Una tabla con metadatos para el conjunto de datos game_revenue — game_revenue_info","text":"tibble 11 rows 2 variables: column character column unique identifiers user/player. info character column contains unique identifiers player session.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/game_revenue_info.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Una tabla con metadatos para el conjunto de datos game_revenue — game_revenue_info","text":"14-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/game_revenue_info.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Una tabla con metadatos para el conjunto de datos game_revenue — game_revenue_info","text":"","code":"# Here is a glimpse at the data # available in `game_revenue_info` dplyr::glimpse(game_revenue_info) #> Rows: 11 #> Columns: 2 #> $ column <chr> \"player_id\", \"session_id\", \"session_start\", \"time\", \"item_type\"… #> $ info   <chr> \"A `character` column with unique identifiers for each user/pla…"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_agent_report.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtenga un informe resumido de una agent — get_agent_report","title":"Obtenga un informe resumido de una agent — get_agent_report","text":"can get informative summary table agent using get_agent_report() function. table can provided two substantially different forms: gt based display table (default), , tibble. amount fields intel different depending whether agent performed interrogation (interrogate() function). Basically, interrogate() called, agent contain just validation plan (however many rows depends many validation functions supplied part plan). Post-interrogation, information passing failing test units provided, along indicators whether certain failure states entered (provided set actions). display table variant agent report, default form, following columns: (unlabeled): validation step number STEP: name validation function used validation step COLUMNS: names target columns used validation step (applicable) VALUES: values used validation step, applicable; literal values, column names, expression, set sub-validations (conjointly() validation step), etc. TBL: indicates whether preconditions apply interrogation; , script '' stands 'identity' , , right-facing arrow appears EVAL: character value denotes result validation step functions' evaluation interrogation N: total number test units validation step PASS: number test units received pass FAIL: fraction test units received pass W, S, N: indicators show whether warn, stop, notify states entered; unset states appear dashes, states set thresholds appear unfilled circles entered filled thresholds exceeded (colors W, S, N amber, red, blue) EXT: column provides buttons data extracts validation step failed rows available (CSV files) small version display table (obtained using size = \"small\") omits COLUMNS, TBL, EXT columns. width small table 575px; standard table 875px wide. choosing get tibble (display_table = FALSE), following columns: : validation step number type: name validation function used validation step columns: names target columns used validation step (applicable) values: values used validation step, applicable; conjointly() validation step, listing sub-validations precon: indicates whether preconditions apply interrogation , , number statements used active: logical value indicates whether validation step set \"active\" interrogation eval: character value denotes result validation step functions' evaluation interrogation units: total number test units validation step n_pass: number test units received pass f_pass: fraction test units received pass W, S, N: logical value stating whether warn, stop, notify states entered extract: logical value indicates whether data extract available validation step","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_agent_report.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtenga un informe resumido de una agent — get_agent_report","text":"","code":"get_agent_report(   agent,   arrange_by = c(\"i\", \"severity\"),   keep = c(\"all\", \"fail_states\"),   display_table = TRUE,   size = \"standard\",   title = \":default:\",   lang = NULL,   locale = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_agent_report.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtenga un informe resumido de una agent — get_agent_report","text":"agent Un objeto de agente de clase ptblank_agent. arrange_by choice arrange report table rows validation step number (\"\", default), , arrange descending order severity failure state (\"severity\"). keep option keep \"\" report's table rows (default), , keep rows reflect one \"fail_states\". display_table display table generated? TRUE (default), gt package installed, display table report shown Viewer. FALSE, gt available, tibble returned. size size display table, can either \"standard\" (default) \"small\". applies display table (display_table = TRUE). title Options customizing title report. default keyword \":default:\" produces generic title text refers pointblank package language governed lang option. Another keyword option \":tbl_name:\", presents name table title report. title wanted, \":none:\" keyword option can used. Aside keyword options, text can provided title glue::glue() calls can used construct text string. providing text, interpreted Markdown text transformed internally HTML. circumvent transformation, use text () explicitly state supplied text transformed. lang language use automatic creation briefs (short descriptions validation step) agent report (summary table provides validation plan results interrogation. De forma predeterminada, NULL creará texto en inglés (\"en\"). Otras opciones incluyen francés (\"fr\"), alemán (\"de\"), italiano (\"\"), español (\"es\"), portugués (\"pt\"), turco (\"tr\"), chino (\"zh\"), ruso (\"ru\"), polaco (\"pl\"), danés (\"da\"), sueco (\"sv\" ) y holandés (\"nl\"). lang option override previously set language setting (e.g., create_agent() call). locale optional locale ID use formatting values agent report summary table according locale's rules. Examples include \"en_US\" English (United States) \"fr_FR\" French (France); simply, can language identifier without country designation, like \"es\" Spanish (Spain, \"es_ES\"). locale option override previously set locale value (e.g., create_agent() call).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_agent_report.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtenga un informe resumido de una agent — get_agent_report","text":"gt table object display_table = TRUE tibble display_table = FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_agent_report.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Obtenga un informe resumido de una agent — get_agent_report","text":"6-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_agent_report.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtenga un informe resumido de una agent — get_agent_report","text":"","code":"# Create a simple table with a # column of numerical values tbl <-    dplyr::tibble(a = c(5, 7, 8, 5))  # Validate that values in column # `a` are always greater than 4 agent <-   create_agent(tbl = tbl) %>%   col_vals_gt(vars(a), value = 4) %>%   interrogate()  # Get a tibble-based report from the # agent by using `get_agent_report()` # with `display_table = FALSE` agent %>%   get_agent_report(display_table = FALSE) #> # A tibble: 1 × 14 #>       i type  columns values precon active eval  units n_pass f_pass W     S     #>   <int> <chr> <chr>   <chr>  <chr>  <lgl>  <chr> <dbl>  <dbl>  <dbl> <lgl> <lgl> #> 1     1 col_… a       4      NA     TRUE   OK        4      4      1 NA    NA    #> # … with 2 more variables: N <lgl>, extract <int>    # View a the report by printing the # `agent` object anytime, but, return a # gt table object by using this with # `display_table = TRUE` (the default) report <- get_agent_report(agent) class(report) #> [1] \"ptblank_agent_report\" \"gt_tbl\"               \"list\"                  # What can you do with the report? # Print it from an R Markdown code, # use it in an email, put it in a # webpage, or further modify it with # the **gt** package  # The agent report as a **gt** display # table comes in two sizes: \"standard\" # (the default) and \"small\" small_report <-    get_agent_report(     agent = agent,     size = \"small\"   )  class(small_report) #> [1] \"ptblank_agent_report\" \"gt_tbl\"               \"list\"                  # The standard report is 875px wide # the small one is 575px wide"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_agent_x_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtenga la x-list del agente — get_agent_x_list","title":"Obtenga la x-list del agente — get_agent_x_list","text":"agent's x-list record information agent possesses given time. x-list contain complete information interrogation taken place (, data largely reflects validation plan). x-list can constrained particular validation step (supplying step number argument), , can get information validation steps leaving unspecified. x-list indeed R list object contains veritable cornucopia information. x-list obtained specified validation step, following components available: time_start: time interrogation began (POSIXct [0 1]) time_end: time interrogation ended (POSIXct [0 1]) label: optional label given agent (chr [1]) tbl_name: name table object, available (chr [1]) tbl_src: type table used validation (chr [1]) tbl_src_details: table database table, provides details DB table (chr [1]) tbl: table object col_names: table's column names (chr [ncol(tbl)]) col_types: table's column types (chr [ncol(tbl)]) : validation step index (int [1]) type: type validation, value validation function name (chr [1]) columns: columns specified validation function (chr [variable length]) values: values specified validation function (mixed types [variable length]) briefs: brief validation step specified lang (chr [1]) eval_error, eval_warning: indicates whether evaluation step function, interrogation, resulted error warning (lgl [1]) capture_stack: list captured errors warnings step-function evaluation interrogation time (list [1]) n: number test units validation step (num [1]) n_passed, n_failed: number passing failing test units validation step (num [1]) f_passed: fraction passing test units validation step, n_passed / n (num [1]) f_failed: fraction failing test units validation step, n_failed / n (num [1]) warn, stop, notify: logical value indicating whether level failing test units caused corresponding conditions entered (lgl [1]) lang: two-letter language code indicates language used briefs, agent report, reporting generated scan_data() function (chr [1]) unspecified (.e., constrained specific validation step) certain length-one components x-list expanded total number validation steps (: , type, columns, values, briefs, eval_error, eval_warning, capture_stack, n, n_passed, n_failed, f_passed, f_failed, warn, stop, notify). x-list also additional components NULL, : report_object: gt table object, also presented default print method ptblank_agent email_object: blastula email_message object default set components report_html: HTML source report_object, provided length-one character vector report_html_small: HTML source narrower, condensed version report_object, provided length-one character vector; HTML inlined styles, making suitable email message bodies","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_agent_x_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtenga la x-list del agente — get_agent_x_list","text":"","code":"get_agent_x_list(agent, i = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_agent_x_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtenga la x-list del agente — get_agent_x_list","text":"agent Un objeto de agente de clase ptblank_agent. validation step number, assigned validation step order invocation. NULL (default), x-list provide information validation steps. valid step number provided x-list information pertaining step.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_agent_x_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtenga la x-list del agente — get_agent_x_list","text":"Un objeto list.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_agent_x_list.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Obtenga la x-list del agente — get_agent_x_list","text":"8-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_agent_x_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtenga la x-list del agente — get_agent_x_list","text":"","code":"# Create a simple data frame with # a column of numerical values tbl <- dplyr::tibble(a = c(5, 7, 8, 5))  # Create an `action_levels()` list # with fractional values for the # `warn`, `stop`, and `notify` states al <-   action_levels(     warn_at = 0.2,     stop_at = 0.8,     notify_at = 0.345   )  # Create an agent (giving it the # `tbl` and the `al` objects), # supply two validation step # functions, then interrogate agent <-   create_agent(     tbl = tbl,     actions = al   ) %>%   col_vals_gt(vars(a), value = 7) %>%   col_is_numeric(vars(a)) %>%   interrogate()    # Get the agent x-list x <- get_agent_x_list(agent)  # Print the x-list object `x` x #> ── The x-list for `tbl` ─────────────────────────────────────────── ALL STEPS ── #> $time_start $time_end (POSIXct [1]) #> $label $tbl_name $tbl_src $tbl_src_details (chr [1]) #> $tbl (tbl_df, tbl, and data.frame) #> $col_names $col_types (chr [1]) #> $i $type $columns $values $label $briefs (mixed [2]) #> $eval_error $eval_warning (lgl [2]) #> $capture_stack (list [2]) #> $n $n_passed $n_failed $f_passed $f_failed (num [2]) #> $warn $stop $notify (lgl [2]) #> $validation_set (tbl_df [2, 35]) #> $lang (chr [1]) #> $report_object (gt_tbl) #> $email_object (blastula_message) #> $report_html $report_html_small (chr [1]) #> ────────────────────────────────────────────────────────────────────────────────  # Get the `f_passed` component # of the x-list x$f_passed #> [1] 0.25 1.00"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_data_extracts.html","id":null,"dir":"Reference","previous_headings":"","what":"Recopile extractos de datos de un paso de validación — get_data_extracts","title":"Recopile extractos de datos de un paso de validación — get_data_extracts","text":"agent-based workflow (.e., initiating create_agent()), interrogation interrogate(), can extract row data pass row-based validation steps get_data_extracts() function. one discrete extract per row-based validation step amount data available particular extract depends fraction test units pass validation step level sampling explicit collection set units. extracts can collected programmatically get_data_extracts() may also downloaded CSV files HTML report generated agent's print method use get_agent_report(). availability data extracts row-based validation step depends whether extract_failed set TRUE within interrogate() call (default). amount fail rows extracted depends collection parameters interrogate(), default behavior collect first 5000 fail rows. Row-based validation steps based validation functions form col_vals_*() also include conjointly() rows_distinct(). functions combined set validation functions can yield data extracts.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_data_extracts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recopile extractos de datos de un paso de validación — get_data_extracts","text":"","code":"get_data_extracts(agent, i = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_data_extracts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recopile extractos de datos de un paso de validación — get_data_extracts","text":"agent Un objeto de agente de clase ptblank_agent. interrogate() called , validation steps carried sample rows non-passing validations potentially available object. validation step number, assigned validation step pointblank order definition. NULL (default), data extract tables provided list object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_data_extracts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recopile extractos de datos de un paso de validación — get_data_extracts","text":"list tables provided, , standalone table given.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_data_extracts.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Recopile extractos de datos de un paso de validación — get_data_extracts","text":"8-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_data_extracts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Recopile extractos de datos de un paso de validación — get_data_extracts","text":"","code":"# Create a series of two validation # steps focused on testing row values # for part of the `small_table` object; # `interrogate()` immediately agent <-   create_agent(     read_fn = ~ small_table %>%       dplyr::select(a:f),     label = \"`get_data_extracts()`\"   ) %>%   col_vals_gt(vars(d), value = 1000) %>%   col_vals_between(     vars(c),     left = vars(a), right = vars(d),     na_pass = TRUE   ) %>%   interrogate()  # Using `get_data_extracts()` with its # defaults returns of a list of tables, # where each table is named after the # validation step that has an extract # available agent %>% get_data_extracts() #> $`1` #> # A tibble: 6 × 6 #>       a b             c     d e     f     #>   <int> <chr>     <dbl> <dbl> <lgl> <chr> #> 1     8 3-ldm-038     7  284. TRUE  low   #> 2     7 1-knw-093     3  843. TRUE  high  #> 3     3 5-bce-642     9  838. FALSE high  #> 4     3 5-bce-642     9  838. FALSE high  #> 5     4 2-dmx-010     7  834. TRUE  low   #> 6     2 7-dmx-010     8  108. FALSE low   #>  #> $`2` #> # A tibble: 4 × 6 #>       a b             c     d e     f     #>   <int> <chr>     <dbl> <dbl> <lgl> <chr> #> 1     6 8-kdg-938     3 2343. TRUE  high  #> 2     8 3-ldm-038     7  284. TRUE  low   #> 3     7 1-knw-093     3  843. TRUE  high  #> 4     4 5-boe-639     2 1036. FALSE low   #>   # We can get an extract for a specific # step by specifying it in the `i` # argument; let's get the failing rows # from the first validation step # (`col_vals_gt`) agent %>% get_data_extracts(i = 1) #> # A tibble: 6 × 6 #>       a b             c     d e     f     #>   <int> <chr>     <dbl> <dbl> <lgl> <chr> #> 1     8 3-ldm-038     7  284. TRUE  low   #> 2     7 1-knw-093     3  843. TRUE  high  #> 3     3 5-bce-642     9  838. FALSE high  #> 4     3 5-bce-642     9  838. FALSE high  #> 5     4 2-dmx-010     7  834. TRUE  low   #> 6     2 7-dmx-010     8  108. FALSE low"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_informant_report.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtener un informe de información de la tabla de un objeto informant — get_informant_report","title":"Obtener un informe de información de la tabla de un objeto informant — get_informant_report","text":"can get table information report informant object generated create_informant() function. report provided gt based display table. amount information shown depends extent added via use info_*() functions direct editing pointblank YAML file (informant can written pointblank YAML yaml_write(informant = <informant>, ...)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_informant_report.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtener un informe de información de la tabla de un objeto informant — get_informant_report","text":"","code":"get_informant_report(   informant,   size = \"standard\",   title = \":default:\",   lang = NULL,   locale = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_informant_report.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtener un informe de información de la tabla de un objeto informant — get_informant_report","text":"informant informant object class ptblank_informant. size size display table, can either \"standard\" (default, width 875px) \"small\" (width 575px). title Options customizing title report. default keyword \":default:\" produces generic title text refers pointblank package language governed lang option. Another keyword option \":tbl_name:\", presents name table title report. title wanted, \":none:\" keyword option can used. Aside keyword options, text can provided title glue::glue() calls can used construct text string. providing text, interpreted Markdown text transformed internally HTML. circumvent transformation, use text () explicitly state supplied text transformed. lang language use information report (summary table provides validation plan results interrogation. De forma predeterminada, NULL creará texto en inglés (\"en\"). Otras opciones incluyen francés (\"fr\"), alemán (\"de\"), italiano (\"\"), español (\"es\"), portugués (\"pt\"), turco (\"tr\"), chino (\"zh\"), ruso (\"ru\"), polaco (\"pl\"), danés (\"da\"), sueco (\"sv\" ) y holandés (\"nl\"). lang option override previously set language setting (e.g., create_agent() call). locale optional locale ID use formatting values information report summary table according locale's rules. Examples include \"en_US\" English (United States) \"fr_FR\" French (France); simply, can language identifier without country designation, like \"es\" Spanish (Spain, \"es_ES\"). locale option override previously set locale value (e.g., create_agent() call).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_informant_report.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtener un informe de información de la tabla de un objeto informant — get_informant_report","text":"gt table object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_informant_report.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Obtener un informe de información de la tabla de un objeto informant — get_informant_report","text":"7-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_informant_report.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtener un informe de información de la tabla de un objeto informant — get_informant_report","text":"","code":"# Generate an informant object using # the `small_table` dataset informant <- create_informant(small_table)  # This function creates some information # without any extra help by profiling # the supplied table object; it adds # the sections 'table' and columns' and # we can print the object to see the # table information report  # Alternatively, we can get the same report # by using `get_informant_report()` report <- get_informant_report(informant) class(report) #> [1] \"ptblank_informant_report\" \"gt_tbl\"                   #> [3] \"list\""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_multiagent_report.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtenga un informe resumido utilizando varios agentes — get_multiagent_report","title":"Obtenga un informe resumido utilizando varios agentes — get_multiagent_report","text":"can get informative summary table collective agents using get_multiagent_report() function. Information multiple agent can provided three forms: (1) Long Display (stacked reports), (2) Wide Display (comparison report), (3) tibble packed columns.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_multiagent_report.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtenga un informe resumido utilizando varios agentes — get_multiagent_report","text":"","code":"get_multiagent_report(   multiagent,   display_table = TRUE,   display_mode = c(\"long\", \"wide\"),   title = \":default:\",   lang = NULL,   locale = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_multiagent_report.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtenga un informe resumido utilizando varios agentes — get_multiagent_report","text":"multiagent multiagent object class ptblank_multiagent. display_table display table generated? TRUE (default) display table report shown Viewer. FALSE tibble returned. display_mode getting display table, agent data presented \"long\" \"wide\" form? default \"long\" comparing multiple runs target table might preferable choose \"wide\". title Options customizing title report display_table = TRUE. default keyword \":default:\" produces generic title text. title wanted, \":none:\" keyword option can used. Another keyword option \":tbl_name:\", presents name table title report (can used display_mode = \"long\"). Aside keyword options, text can provided title glue::glue() calls can used construct text string. providing text, interpreted Markdown text transformed internally HTML. circumvent transformation, use text () explicitly state supplied text transformed. lang language use long wide report forms. De forma predeterminada, NULL creará texto en inglés (\"en\"). Otras opciones incluyen francés (\"fr\"), alemán (\"de\"), italiano (\"\"), español (\"es\"), portugués (\"pt\"), turco (\"tr\"), chino (\"zh\"), ruso (\"ru\"), polaco (\"pl\"), danés (\"da\"), sueco (\"sv\" ) y holandés (\"nl\"). locale optional locale ID use formatting values long wide report forms (according locale's rules). Examples include \"en_US\" English (United States) \"fr_FR\" French (France); simply, can language identifier without country designation, like \"es\" Spanish (Spain, \"es_ES\"). locale option override previously set locale values.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_multiagent_report.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtenga un informe resumido utilizando varios agentes — get_multiagent_report","text":"gt table object display_table = TRUE tibble display_table = FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_multiagent_report.html","id":"the-long-display","dir":"Reference","previous_headings":"","what":"The Long Display","title":"Obtenga un informe resumido utilizando varios agentes — get_multiagent_report","text":"displayed \"long\" multiagent report stack individual agent reports single document order agents multiagent object. validation plan (possibly interrogation info) provided output equivalent calling get_agent_report() agents within multiagent object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_multiagent_report.html","id":"the-wide-display","dir":"Reference","previous_headings":"","what":"The Wide Display","title":"Obtenga un informe resumido utilizando varios agentes — get_multiagent_report","text":"displayed \"wide\" multiagent report show data individual agents columns, rows standing validation steps common across agents. validation step represented icon (standing name validation function) associated SHA1 hash. highly trustworthy way ascertaining validation steps effectively identical across interrogations. way organizing report beneficial different agents may used different steps want track validation results validation step change target table (.e., new rows added, existing rows updated, etc.). single table display mode following columns: STEP: SHA1 hash validation step, possibly shared among several interrogations. subsequent columns: column beyond STEP represents separate interrogation agent object. time stamp completion interrogation shown column label.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_multiagent_report.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Obtenga un informe resumido utilizando varios agentes — get_multiagent_report","text":"10-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_multiagent_report.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtenga un informe resumido utilizando varios agentes — get_multiagent_report","text":"","code":"if (interactive()) {  # Let's walk through several theoretical # data quality analyses of an extremely # small table; that table is called # `small_table` and we can find it as a # dataset in this package small_table  # To set failure limits and signal # conditions, we designate proportional # failure thresholds to the `warn`, `stop`, # and `notify` states using `action_levels()` al <-    action_levels(     warn_at = 0.05,     stop_at = 0.10,     notify_at = 0.20   )  # We will create four different agents # and have slightly different validation # steps in each of them; in the first, # `agent_1`, eight different validation # steps are created and the agent will # interrogate the `small_table` agent_1 <-   create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"`get_multiagent_report()`\",     actions = al   ) %>%   col_vals_gt(     vars(date_time),     value = vars(date),     na_pass = TRUE   ) %>%   col_vals_gt(     vars(b),      value = vars(g),     na_pass = TRUE   ) %>%   rows_distinct() %>%   col_vals_equal(     vars(d),      value = vars(d),     na_pass = TRUE   ) %>%   col_vals_between(     vars(c),      left = vars(a), right = vars(d)   ) %>%   col_vals_not_between(     vars(c),     left = 10, right = 20,     na_pass = TRUE   ) %>%   rows_distinct(vars(d, e, f)) %>%   col_is_integer(vars(a)) %>%   interrogate()  # The second agent, `agent_2`, retains # all of the steps of `agent_1` and adds # two more (the last of which is inactive) agent_2 <-    agent_1 %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b),      regex = \"[0-9]-[a-z]{3}-[0-9]{3}\",     active = FALSE   ) %>%   interrogate()  # The third agent, `agent_3`, adds a single # validation step, removes the fifth one, # and deactivates the first agent_3 <-    agent_2 %>%   col_vals_in_set(     vars(f),     set = c(\"low\", \"mid\", \"high\")   ) %>%   remove_steps(i = 5) %>%   deactivate_steps(i = 1) %>%   interrogate()  # The fourth and final agent, `agent_4`, # reactivates steps 1 and 10, and removes # the sixth step agent_4 <-   agent_3 %>%   activate_steps(i = 1) %>%   activate_steps(i = 10) %>%   remove_steps(i = 6) %>%   interrogate()  # While all the agents are slightly # different from each other, we can still # get a combined report of them by # creating a 'multiagent' multiagent <-   create_multiagent(     agent_1, agent_2, agent_3, agent_4   )  # Calling `multiagent` in the console # prints the multiagent report; but we # can use some non-default option with # the `get_multiagent_report()` function  # By default, `get_multiagent_report()` # gives you a tall report with agent # reports being stacked report_1 <-    get_multiagent_report(multiagent)    # We can modify the title with that's # more suitable or use a keyword like # `:tbl_name:` to give us the target # table name in each section report_2 <-    get_multiagent_report(     multiagent,     title = \":tbl_name:\"   )  # We can opt for a wide display of # the reporting info, and this is # great when reporting on multiple # validations of the same target # table report_3 <-    get_multiagent_report(     multiagent,     display_mode = \"wide\"   ) }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_sundered_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Divida los datos, dividiéndolos en partes de 'pasa' y 'falla' — get_sundered_data","title":"Divida los datos, dividiéndolos en partes de 'pasa' y 'falla' — get_sundered_data","text":"Validation data one thing , sometimes, want use best part input dataset something else. get_sundered_data() function works agent object intel (.e., post interrogate()) gets either 'pass' data piece (rows failing test units across row-based validation functions), , 'fail' data piece (rows least one failing test unit across series validations). final option, can emit data new column (called .pb_combined) labels row passing failing across validation steps. labels \"pass\" \"fail\" default values can easily customized.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_sundered_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Divida los datos, dividiéndolos en partes de 'pasa' y 'falla' — get_sundered_data","text":"","code":"get_sundered_data(   agent,   type = c(\"pass\", \"fail\", \"combined\"),   pass_fail = c(\"pass\", \"fail\"),   id_cols = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_sundered_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Divida los datos, dividiéndolos en partes de 'pasa' y 'falla' — get_sundered_data","text":"agent Un objeto de agente de clase ptblank_agent. interrogate() called , validation steps actually carried . type desired piece data resulting splitting. Options returning single table \"pass\" (default) \"fail\". options return single table , \"pass\" case, rows passed across validation steps (.e., failing test units part row validation step), , complementary set rows \"fail\" case. Providing NULL returns split data tables list (names \"pass\" \"fail\"). option \"combined\" applies categorical (pass/fail) label (settable pass_fail argument) new .pb_combined flag column. case ordering rows fully retained input table. pass_fail vector encoding flag column 'pass' 'fail' values type = \"combined\". default c(\"pass\", \"fail\") options c(TRUE, FALSE), c(1, 0), c(1L, 0L). id_cols optional specification one identifying columns. taken together, can count single column grouping columns distinguish rows. table undergoing validation data frame tibble, columns need specified id_cols.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_sundered_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Divida los datos, dividiéndolos en partes de 'pasa' y 'falla' — get_sundered_data","text":"list table objects type NULL, , single table type given.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_sundered_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Divida los datos, dividiéndolos en partes de 'pasa' y 'falla' — get_sundered_data","text":"caveats sundering. validation steps considered splitting row-based variety (e.g., col_vals_*() functions conjointly(), rows_distinct()). Furthermore, validation steps experienced evaluation issues interrogation considered, , validation steps active = FALSE disregarded. collection validation steps fulfill requirements sundering termed -consideration validation steps. using preconditions validation steps, must ensure -consideration validation steps use specified preconditions function. Put another way, split target table using collection -consideration validation steps use different forms input table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_sundered_data.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Divida los datos, dividiéndolos en partes de 'pasa' y 'falla' — get_sundered_data","text":"8-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_sundered_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Divida los datos, dividiéndolos en partes de 'pasa' y 'falla' — get_sundered_data","text":"","code":"# Create a series of two validation # steps focused on testing row values # for part of the `small_table` object; # `interrogate()` immediately agent <-   create_agent(     read_fn = ~ small_table %>%       dplyr::select(a:f),     label = \"`get_sundered_data()`\"   ) %>%   col_vals_gt(vars(d), value = 1000) %>%   col_vals_between(     vars(c),     left = vars(a), right = vars(d),     na_pass = TRUE   ) %>%   interrogate()  # Get the sundered data piece that # contains only rows that passed both # validation steps (the default piece); # this yields 5 of 13 total rows agent %>% get_sundered_data() #> # A tibble: 5 × 6 #>       a b             c      d e     f     #>   <int> <chr>     <dbl>  <dbl> <lgl> <chr> #> 1     2 1-bcd-345     3  3423. TRUE  high  #> 2     3 5-egh-163     8 10000. TRUE  low   #> 3     2 5-jdo-903    NA  3892. FALSE mid   #> 4     4 2-dhe-923     4  3291. TRUE  mid   #> 5     1 3-dka-303    NA  2230. TRUE  high   # Get the complementary data piece: # all of those rows that failed either # of the two validation steps; # this yields 8 of 13 total rows agent %>%   get_sundered_data(type = \"fail\") #> # A tibble: 8 × 6 #>       a b             c     d e     f     #>   <int> <chr>     <dbl> <dbl> <lgl> <chr> #> 1     6 8-kdg-938     3 2343. TRUE  high  #> 2     8 3-ldm-038     7  284. TRUE  low   #> 3     7 1-knw-093     3  843. TRUE  high  #> 4     4 5-boe-639     2 1036. FALSE low   #> 5     3 5-bce-642     9  838. FALSE high  #> 6     3 5-bce-642     9  838. FALSE high  #> 7     4 2-dmx-010     7  834. TRUE  low   #> 8     2 7-dmx-010     8  108. FALSE low      # We can get all of the input data # returned with a flag column (called # `.pb_combined`); this is done by # using `type = \"combined\"` and that # rightmost column will contain `\"pass\"` # and `\"fail\"` values agent %>%   get_sundered_data(type = \"combined\") #> # A tibble: 13 × 7 #>        a b             c      d e     f     .pb_combined #>    <int> <chr>     <dbl>  <dbl> <lgl> <chr> <chr>        #>  1     2 1-bcd-345     3  3423. TRUE  high  pass         #>  2     3 5-egh-163     8 10000. TRUE  low   pass         #>  3     6 8-kdg-938     3  2343. TRUE  high  fail         #>  4     2 5-jdo-903    NA  3892. FALSE mid   pass         #>  5     8 3-ldm-038     7   284. TRUE  low   fail         #>  6     4 2-dhe-923     4  3291. TRUE  mid   pass         #>  7     7 1-knw-093     3   843. TRUE  high  fail         #>  8     4 5-boe-639     2  1036. FALSE low   fail         #>  9     3 5-bce-642     9   838. FALSE high  fail         #> 10     3 5-bce-642     9   838. FALSE high  fail         #> 11     4 2-dmx-010     7   834. TRUE  low   fail         #> 12     2 7-dmx-010     8   108. FALSE low   fail         #> 13     1 3-dka-303    NA  2230. TRUE  high  pass          # We can change the `\"pass\"` or `\"fail\"` # text values to another type of coding # with the `pass_fail` argument; one # possibility is TRUE/FALSE agent %>%   get_sundered_data(     type = \"combined\",     pass_fail = c(TRUE, FALSE)   ) #> # A tibble: 13 × 7 #>        a b             c      d e     f     .pb_combined #>    <int> <chr>     <dbl>  <dbl> <lgl> <chr> <lgl>        #>  1     2 1-bcd-345     3  3423. TRUE  high  TRUE         #>  2     3 5-egh-163     8 10000. TRUE  low   TRUE         #>  3     6 8-kdg-938     3  2343. TRUE  high  FALSE        #>  4     2 5-jdo-903    NA  3892. FALSE mid   TRUE         #>  5     8 3-ldm-038     7   284. TRUE  low   FALSE        #>  6     4 2-dhe-923     4  3291. TRUE  mid   TRUE         #>  7     7 1-knw-093     3   843. TRUE  high  FALSE        #>  8     4 5-boe-639     2  1036. FALSE low   FALSE        #>  9     3 5-bce-642     9   838. FALSE high  FALSE        #> 10     3 5-bce-642     9   838. FALSE high  FALSE        #> 11     4 2-dmx-010     7   834. TRUE  low   FALSE        #> 12     2 7-dmx-010     8   108. FALSE low   FALSE        #> 13     1 3-dka-303    NA  2230. TRUE  high  TRUE          # ...and using `0` and `1` might be # worthwhile in some situations agent %>%   get_sundered_data(     type = \"combined\",     pass_fail = 0:1   ) #> # A tibble: 13 × 7 #>        a b             c      d e     f     .pb_combined #>    <int> <chr>     <dbl>  <dbl> <lgl> <chr>        <int> #>  1     2 1-bcd-345     3  3423. TRUE  high             0 #>  2     3 5-egh-163     8 10000. TRUE  low              0 #>  3     6 8-kdg-938     3  2343. TRUE  high             1 #>  4     2 5-jdo-903    NA  3892. FALSE mid              0 #>  5     8 3-ldm-038     7   284. TRUE  low              1 #>  6     4 2-dhe-923     4  3291. TRUE  mid              0 #>  7     7 1-knw-093     3   843. TRUE  high             1 #>  8     4 5-boe-639     2  1036. FALSE low              1 #>  9     3 5-bce-642     9   838. FALSE high             1 #> 10     3 5-bce-642     9   838. FALSE high             1 #> 11     4 2-dmx-010     7   834. TRUE  low              1 #> 12     2 7-dmx-010     8   108. FALSE low              1 #> 13     1 3-dka-303    NA  2230. TRUE  high             0"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_tt_param.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtener un valor de parámetro de una tabla de resumen — get_tt_param","title":"Obtener un valor de parámetro de una tabla de resumen — get_tt_param","text":"get_tt_param() function can help obtain single parameter value summary table generated tt_*() functions tt_summary_stats(), tt_string_info(), tt_tbl_dims(), tt_tbl_colnames(). following parameters used depending input tbl: tt_summary_stats(): \"min\", \"p05\", \"q_1\", \"med\", \"q_3\", \"p95\", \"max\", \"iqr\", \"range\" tt_string_info(): \"length_mean\", \"length_min\", \"length_max\" tt_tbl_dims(): \"rows\", \"columns\" tt_tbl_colnames(): integer present .param. column tt_summary_stats() tt_string_info() functions generate summary tables columns mirror numeric character columns input tables, respectively. reason, column name must supplied column argument get_tt_param().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_tt_param.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtener un valor de parámetro de una tabla de resumen — get_tt_param","text":"","code":"get_tt_param(tbl, param, column = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_tt_param.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtener un valor de parámetro de una tabla de resumen — get_tt_param","text":"tbl summary table generated either tt_summary_stats(), tt_string_info(), tt_tbl_dims(), tt_tbl_colnames() functions. param parameter name associated value gotten. parameter names always available first column (.param.) summary table obtained tt_summary_stats(), tt_string_info(), tt_tbl_dims(), tt_tbl_colnames(). column column summary table data value obtained. must supplied summary tables generated tt_summary_stats() tt_string_info() (tt_tbl_dims() tt_tbl_colnames() functions always generate two-column summary table).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_tt_param.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Obtener un valor de parámetro de una tabla de resumen — get_tt_param","text":"12-7","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_tt_param.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtener un valor de parámetro de una tabla de resumen — get_tt_param","text":"","code":"# Get summary statistics for the # first quarter of the `game_revenue` # dataset that's included in the package stat_tbl <-    game_revenue %>%   tt_time_slice(slice_point = 0.25) %>%   tt_summary_stats()  # Based on player behavior for the first # quarter of the year, test whether the # maximum session duration during the # rest of the year is never higher game_revenue %>%   tt_time_slice(     slice_point = 0.25,     keep = \"right\"   ) %>%   test_col_vals_lte(     columns = vars(session_duration),      value = get_tt_param(       tbl = stat_tbl,       param = \"max\",       column = \"session_duration\"     )   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/has_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Determinar si existen una o más columnas en una tabla — has_columns","title":"Determinar si existen una o más columnas en una tabla — has_columns","text":"utility function can help easily determine whether column specified name present table object. function works well enough table object can also used part formula validation function's active argument. Using active = ~ . %>% has_columns(\"column_1\") means validation step inactive target table contain column named column_1. can also use multiple columns vars() active = ~ . %>% has_columns(vars(column_1, column_2)) validation step make inactive interrogate() time unless columns column_1 column_2 present.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/has_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determinar si existen una o más columnas en una tabla — has_columns","text":"","code":"has_columns(x, columns)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/has_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determinar si existen una o más columnas en una tabla — has_columns","text":"x table object. columns One column names checked existence table x.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/has_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determinar si existen una o más columnas en una tabla — has_columns","text":"length-1 logical vector.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/has_columns.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Determinar si existen una o más columnas en una tabla — has_columns","text":"13-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/has_columns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determinar si existen una o más columnas en una tabla — has_columns","text":"","code":"# The `small_table` dataset in the # package has the columns `date_time`, # `date`, and the `a` through `f` # columns small_table #> # A tibble: 13 × 8 #>    date_time           date           a b             c      d e     f     #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high   # With `has_columns()` we can check for # column existence by using it directly # with the table; a column name can be # verified as present by using it in # double quotes small_table %>% has_columns(\"date\") #> [1] TRUE  # Multiple column names can be supplied; # this is `TRUE` because both columns are # present in `small_table` small_table %>% has_columns(c(\"a\", \"b\")) #> [1] TRUE  # It's possible to supply column names # in `vars()` as well small_table %>% has_columns(vars(a, b)) #> [1] TRUE  # Because column `h` isn't present, this # returns `FALSE` (all specified columns # need to be present to obtain `TRUE`) small_table %>% has_columns(vars(a, h)) #> [1] FALSE  # The `has_columns()` function can be # useful in expressions that involve the # target table, especially if it is # uncertain that the table will contain # a column that's involved in a validation  # In the following agent-based validation, # the first two steps will be 'active' # because all columns checked for in the # expressions are present; the third step # is inactive because column `j` isn't # there (without the `active` statement we # would get an evaluation failure in the # agent report) agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\"   ) %>%   col_vals_gt(     vars(c), value = vars(a),     active = ~ . %>% has_columns(vars(a, c))   ) %>%   col_vals_lt(     vars(h), value = vars(d),     preconditions = ~ . %>% dplyr::mutate(h = d - a),     active = ~ . %>% has_columns(vars(a, d))   ) %>%   col_is_character(     vars(j),     active = ~ . %>% has_columns(\"j\")   ) %>%   interrogate()  #> ℹ Step 3 is not set as active. Skipping."},{"path":"https://rich-iannone.github.io/pointblank/es/reference/incorporate.html","id":null,"dir":"Reference","previous_headings":"","what":"Dado un objeto informant, actualice e incorpore fragmentos de tabla — incorporate","title":"Dado un objeto informant, actualice e incorpore fragmentos de tabla — incorporate","text":"informant object number snippets available (using info_snippet()) strings use (using info_*() functions {<snippet_name>} text elements), process incorporating aspects table info text can occur using incorporate() function. , information fully updated (getting current state table dimensions, re-rendering info text, etc.) can print informant object use get_informant_report() function see information report.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/incorporate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dado un objeto informant, actualice e incorpore fragmentos de tabla — incorporate","text":"","code":"incorporate(informant)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/incorporate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dado un objeto informant, actualice e incorpore fragmentos de tabla — incorporate","text":"informant informant object class ptblank_informant.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/incorporate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dado un objeto informant, actualice e incorpore fragmentos de tabla — incorporate","text":"Un objeto ptblank_informant.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/incorporate.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Dado un objeto informant, actualice e incorpore fragmentos de tabla — incorporate","text":"7-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/incorporate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dado un objeto informant, actualice e incorpore fragmentos de tabla — incorporate","text":"","code":"if (interactive()) {  # Take the `small_table` and # assign it to `test_table`; we'll # modify it later test_table <- small_table  # Generate an informant object, add # two snippets with `info_snippet()`, # add information with some other # `info_*()` functions and then # `incorporate()` the snippets into # the info text informant <-    create_informant(     read_fn = ~ test_table,     tbl_name = \"test_table\"   ) %>%   info_snippet(     snippet_name = \"row_count\",     fn = ~ . %>% nrow()   ) %>%   info_snippet(     snippet_name = \"col_count\",     fn = ~ . %>% ncol()   ) %>%   info_columns(     columns = vars(a),     info = \"In the range of 1 to 10. (SIMPLE)\"   ) %>%   info_columns(     columns = starts_with(\"date\"),     info = \"Time-based values (e.g., `Sys.time()`).\"   ) %>%   info_columns(     columns = \"date\",     info = \"The date part of `date_time`. (CALC)\"   ) %>%   info_section(     section_name = \"rows\",     row_count = \"There are {row_count} rows available.\"   ) %>%   incorporate()  # We can print the `informant` object # to see the information report  # Let's modify `test_table` to give # it more rows and an extra column test_table <-    dplyr::bind_rows(test_table, test_table) %>%   dplyr::mutate(h = a + c)  # Using `incorporate()` will cause # the snippets to be reprocessed, and, # the strings to be updated informant <-   informant %>% incorporate()    # When printed again, we'll see that the # row and column counts in the header # have been updated to reflect the # changed `test_table`  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Agregar información que se centre en aspectos de las columnas de una tabla de\ndatos — info_columns","title":"Agregar información que se centre en aspectos de las columnas de una tabla de\ndatos — info_columns","text":"Upon creation informant object (create_informant() function), two sections containing properties: (1) 'table' (2) 'columns'. 'columns' section initialized table's column names types (_type). Beyond , useful provide details nature column can info_columns() function. single column (multiple columns) targeted, series named arguments (form entry_name = \"*info text*.\") serves additional information column columns.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Agregar información que se centre en aspectos de las columnas de una tabla de\ndatos — info_columns","text":"","code":"info_columns(x, columns, ..., .add = TRUE)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Agregar información que se centre en aspectos de las columnas de una tabla de\ndatos — info_columns","text":"x informant object class ptblank_informant. columns column set columns focus . Can defined column name quotes (e.g., \"<column_name>\"), one column names vars() (e.g., vars(<column_name>)), select helper (e.g., starts_with(\"date\")). ... Information entries series named arguments. names refer subsection titles within COLUMN -> <COLUMN_NAME> RHS contains info text (informational text can written Markdown styled Text Tricks). .add new text added existing text? TRUE default; setting FALSE replaces existing text property.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Agregar información que se centre en aspectos de las columnas de una tabla de\ndatos — info_columns","text":"Un objeto ptblank_informant.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns.html","id":"info-text","dir":"Reference","previous_headings":"","what":"Info Text","title":"Agregar información que se centre en aspectos de las columnas de una tabla de\ndatos — info_columns","text":"info text used info_*() functions readily accepts Markdown formatting, , Text Tricks can used spice presentation. Markdown links written < link url > [ link text ]( link url ) get nicely-styled links. dates expressed ISO-8601 standard parentheses, \"(2004-12-01)\", styled font variation (monospaced) underlined purple. Spans text can converted label-style text using: (1) double parentheses around text rectangular border ((label text)), (2) triple parentheses around text rounded-rectangular border like (((label text))). CSS style rules can applied spans info text following form: [[ info text ]]<< CSS style rules >> example practice suppose like change color text red make font appear somewhat thinner. variation following might used: \"[[factor]]<<color: red; font-weight: 300;>> value.\" quite CSS style rules can used great effect. might like: color: <color value>; (text color) background-color: <color value>; (text's background color) text-decoration: (overline | line-| underline); text-transform: (uppercase | lowercase | capitalize); letter-spacing: <+/- length value>; word-spacing: <+/- length value>; font-style: (normal | italic | oblique); font-weight: (normal | bold | 100-900); font-variant: (normal | bold | 100-900); border: <color value> <length value> (solid | dashed | dotted); examples, 'length value' refers CSS length can expressed different units measure (e.g., 12px, 1em, etc.). lengths can expressed positive negative values (e.g., letter-spacing). Color values can expressed ways, common form hexadecimal color values CSS color names.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Agregar información que se centre en aspectos de las columnas de una tabla de\ndatos — info_columns","text":"pointblank informant can written YAML yaml_write() resulting YAML can used regenerate informant (yaml_read_informant()) perform 'incorporate' action using target table (via yaml_informant_incorporate()). way information table columns represented YAML works like : info text goes subsections YAML keys named columns, part top-level columns key. example several calls info_columns() expressed R code result corresponds YAML representation. Subsections represented column names automatically generated creating informant. Within , can multiple subsections used holding info text column. subsections used across different columns needn't either, commonality enforced presence _type key (automatically updated every incorporate() invocation). safest use single quotation marks around info text directly editing YAML file. Note Markdown formatting info snippet placeholders (shown {snippet_1}, see info_snippet() information) preserved YAML. Markdown HTML conversion done printing informant (invoking get_informant_report() informant) processing snippets (generation insertion) done using incorporate() function. Thus, source text always maintained YAML representation never written processed form.","code":"# Código R informant %>%    info_columns(     columns = \"date_time\",     info = \"*info text* 1.\"   ) %>%   info_columns(     columns = \"date\",     info = \"*info text* 2.\"   ) %>%   info_columns(     columns = \"item_count\",     info = \"*info text* 3. Statistics: {snippet_1}.\"   ) %>%   info_columns(     columns = vars(date, date_time),     info = \"UTC time.\"   )  # Representación YAML columns:   date_time:     _type: POSIXct, POSIXt     info: '*info text* 1. UTC time.'   date:     _type: Date     info: '*info text* 2. UTC time.'   item_count:     _type: integer     info: '*info text* 3. Statistics: {snippet_1}.'"},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Agregar información que se centre en aspectos de las columnas de una tabla de\ndatos — info_columns","text":"3-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Agregar información que se centre en aspectos de las columnas de una tabla de\ndatos — info_columns","text":"","code":"# Create a pointblank `informant` # object with `create_informant()`; # we specify a `read_fn` with the # `~` followed by a statement that # gets the `small_table` dataset informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\"   )  # We can add *info text* to describe # the columns in the table with multiple # `info_columns()` calls; the *info text* # calls are additive to existing content # in subsections informant <-   informant %>%   info_columns(     columns = vars(a),     info = \"In the range of 1 to 10. (SIMPLE)\"   ) %>%   info_columns(     columns = starts_with(\"date\"),     info = \"Time-based values (e.g., `Sys.time()`).\"   ) %>%   info_columns(     columns = \"date\",     info = \"The date part of `date_time`. (CALC)\"   )  # Upon printing the `informant` object, we see # the additions made to the 'Columns' section  if (interactive()) {  # The `informant` object can be written to # a YAML file with the `yaml_write()` # function; then, information can # be directly edited or modified yaml_write(   informant = informant,   filename = \"informant.yml\" )  # The YAML file can then be read back # into an informant object with the # `yaml_read_informant()` function informant <-   yaml_read_informant(     filename = \"informant.yml\"   )  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns_from_tbl.html","id":null,"dir":"Reference","previous_headings":"","what":"Agregar información de columna de otra tabla de datos — info_columns_from_tbl","title":"Agregar información de columna de otra tabla de datos — info_columns_from_tbl","text":"info_columns_from_tbl() function wrapper around info_columns() function useful wish apply info text columns information already exists data frame (form can readily coaxed data frame). form input tbl (one contains column metadata) basic requirements: data frame must two columns columns must class character first column contain column names second contain info text column matches across tables (.e., tbl target table informant) new entry \"info\" property. Empty missing info text pruned tbl.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns_from_tbl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Agregar información de columna de otra tabla de datos — info_columns_from_tbl","text":"","code":"info_columns_from_tbl(x, tbl, .add = TRUE)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns_from_tbl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Agregar información de columna de otra tabla de datos — info_columns_from_tbl","text":"x informant object class ptblank_informant. tbl two-column data frame contains metadata target table informant object. .add new text added existing text? TRUE default; setting FALSE replaces existing text \"info\" property.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns_from_tbl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Agregar información de columna de otra tabla de datos — info_columns_from_tbl","text":"Un objeto ptblank_informant.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns_from_tbl.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Agregar información de columna de otra tabla de datos — info_columns_from_tbl","text":"3-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns_from_tbl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Agregar información de columna de otra tabla de datos — info_columns_from_tbl","text":"","code":"# Create a pointblank `informant` # object with `create_informant()`; # we specify a `read_fn` with the # `~` followed by a statement that # gets the `game_revenue` dataset informant <-    create_informant(     read_fn = ~ game_revenue,     tbl_name = \"game_revenue\",     label = \"Un ejemplo.\"   )  # We can add *info text* to describe # the columns in the table by using # information in another table; the # `info_columns_from_tbl()` takes a # table object where the first column # has the column names and the second # contains the *info text* (the # `game_revenue_info` dataset contains # metadata for `game_revenue`) informant <-   informant %>%   info_columns_from_tbl(     tbl = game_revenue_info   )  # We can continue to add more *info # text* since the process is additive; # the `info_columns_from_tbl()` # function populates the `info` # subsection informant <-   informant %>%   info_columns(     columns = \"item_revenue\",     info = \"Revenue reported in USD.\"   ) %>%   info_columns(     columns = \"acquisition\",     `top list` = \"{top5_aq}\"   ) %>%   info_snippet(     snippet_name = \"top5_aq\",     fn = snip_list(column = \"acquisition\")   ) %>%   incorporate() #>  #> ── Incorporation Started - there is a single snippet to process ──────────────── #> ✔ Information gathered. #> ✔ Snippets processed. #> ✔ Information built. #>  #> ── Incorporation Completed ─────────────────────────────────────────────────────"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_section.html","id":null,"dir":"Reference","previous_headings":"","what":"Agregue información que se centre en algún aspecto clave de la tabla de datos — info_section","title":"Agregue información que se centre en algún aspecto clave de la tabla de datos — info_section","text":"info_tabular() info_columns() functions allow us add/modify info text specific sections, info_section() makes possible add sections choosing information make sense sections. Define section_name provide series named arguments (form entry_name = \"*info text*.\") build informational content section.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_section.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Agregue información que se centre en algún aspecto clave de la tabla de datos — info_section","text":"","code":"info_section(x, section_name, ...)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_section.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Agregue información que se centre en algún aspecto clave de la tabla de datos — info_section","text":"x informant object class ptblank_informant. section_name name section information pertains. ... Information entries series named arguments. names refer subsection titles within section defined section_name RHS info text (informational text can written Markdown styled Text Tricks).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_section.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Agregue información que se centre en algún aspecto clave de la tabla de datos — info_section","text":"Un objeto ptblank_informant.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_section.html","id":"info-text","dir":"Reference","previous_headings":"","what":"Info Text","title":"Agregue información que se centre en algún aspecto clave de la tabla de datos — info_section","text":"info text used info_*() functions readily accepts Markdown formatting, , Text Tricks can used spice presentation. Markdown links written < link url > [ link text ]( link url ) get nicely-styled links. dates expressed ISO-8601 standard parentheses, \"(2004-12-01)\", styled font variation (monospaced) underlined purple. Spans text can converted label-style text using: (1) double parentheses around text rectangular border ((label text)), (2) triple parentheses around text rounded-rectangular border like (((label text))). CSS style rules can applied spans info text following form: [[ info text ]]<< CSS style rules >> example practice suppose like change color text red make font appear somewhat thinner. variation following might used: \"[[factor]]<<color: red; font-weight: 300;>> value.\" quite CSS style rules can used great effect. might like: color: <color value>; (text color) background-color: <color value>; (text's background color) text-decoration: (overline | line-| underline); text-transform: (uppercase | lowercase | capitalize); letter-spacing: <+/- length value>; word-spacing: <+/- length value>; font-style: (normal | italic | oblique); font-weight: (normal | bold | 100-900); font-variant: (normal | bold | 100-900); border: <color value> <length value> (solid | dashed | dotted); examples, 'length value' refers CSS length can expressed different units measure (e.g., 12px, 1em, etc.). lengths can expressed positive negative values (e.g., letter-spacing). Color values can expressed ways, common form hexadecimal color values CSS color names.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_section.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Agregue información que se centre en algún aspecto clave de la tabla de datos — info_section","text":"pointblank informant can written YAML yaml_write() resulting YAML can used regenerate informant (yaml_read_informant()) perform 'incorporate' action using target table (via yaml_informant_incorporate()). Extra sections (.e., neither table columns sections) can generated filled info text using one calls info_section(). expressed R code YAML representation. Subsections represented column names automatically generated creating informant. Within top-level sections (.e., History Additional Notes) can multiple subsections used holding info text. safest use single quotation marks around info text directly editing YAML file. Note Markdown formatting info snippet placeholders (shown {snippet}, see info_snippet() information) preserved YAML. Markdown HTML conversion done printing informant (invoking get_informant_report() informant) processing snippets (generation insertion) done using incorporate() function. Thus, source text always maintained YAML representation never written processed form.","code":"# Código R informant %>%    info_section(     section_name = \"History\",     Changes = \" - Change 1 - Change 2 - Change 3\",     `Last Update` = \"(2020-10-23) at 3:28 PM.\"   ) %>%   info_section(     section_name = \"Additional Notes\",     `Notes 1` = \"Notes with a {snippet}.\",     `Notes 2` = \"**Bold notes**.\"   )  # Representación YAML History:   Changes: |2-        - Change 1     - Change 2     - Change 3   Last Update: (2020-10-23) at 3:28 PM. Additional Notes:   Notes 1: Notes with a {snippet}.   Notes 2: '**Bold notes**.'"},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_section.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Agregue información que se centre en algún aspecto clave de la tabla de datos — info_section","text":"3-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_section.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Agregue información que se centre en algún aspecto clave de la tabla de datos — info_section","text":"","code":"# Create a pointblank `informant` # object with `create_informant()`; # we specify a `read_fn` with the # `~` followed by a statement that # gets the `small_table` dataset informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\"   )  # The `informant` object has the 'table' # and 'columns' sections; we can create # entirely different sections with their # own properties using `info_section()`  # We can add *info text* to sections # entirely different than `table` and # `columns` with `info_section()` informant <-   informant %>%   info_section(     section_name = \"Notes\",     creation = \"Dataset generated on (2020-01-15).\",     usage = \"`small_table %>% dplyr::glimpse()`\"   ) %>%   incorporate() #>  #> ── Incorporation Started ─────────────────────────────────────────────────────── #> ✔ Information gathered. #> ✔ Information built. #>  #> ── Incorporation Completed ─────────────────────────────────────────────────────  # Upon printing the `informant` object, we see # the addition of the 'Notes' section and its # own information  if (interactive()) {  # The `informant` object can be written to # a YAML file with the `yaml_write()` # function; then, information can # be directly edited or modified yaml_write(   informant = informant,   filename = \"informant.yml\" )  # The YAML file can then be read back # into an informant object with the # `yaml_read_informant()` function informant <-   yaml_read_informant(     filename = \"informant.yml\"   )  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_snippet.html","id":null,"dir":"Reference","previous_headings":"","what":"Genere un 'snippet' de texto útil a partir de la tabla de destino — info_snippet","title":"Genere un 'snippet' de texto útil a partir de la tabla de destino — info_snippet","text":"Getting little snippets information table goes hand--hand mixing bits info table info. Call info_snippet() define snippet get target table. snippet definition supplied either formula, , pointblank-supplied snip_*() function. long know interact table extract information, can easily define snippets informant object. snippets defined, can insert info text defined info_*() functions (info_tabular(), info_columns(), info_section()). Use curly braces just snippet_name inside (e.g., \"column {n_cat} categories.\").","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_snippet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Genere un 'snippet' de texto útil a partir de la tabla de destino — info_snippet","text":"","code":"info_snippet(x, snippet_name, fn)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_snippet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Genere un 'snippet' de texto útil a partir de la tabla de destino — info_snippet","text":"x informant object class ptblank_informant. snippet_name name snippet, used interpolating result snippet formula info text defined info_*() function. fn formula obtains snippet data target table. best use leading dot (.) stands table use pipes construct series operations performed table (e.g., ~ . %>% dplyr::pull(column_2) %>% max(na.rm = TRUE)). long result length-1 vector, 'll likely valid insertion info text. Alternatively, snip_*() function can used (functions always return formula suitable types data sources).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_snippet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Genere un 'snippet' de texto útil a partir de la tabla de destino — info_snippet","text":"Un objeto ptblank_informant.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_snippet.html","id":"snip-functions-provided-in-pointblank","dir":"Reference","previous_headings":"","what":"Snip functions provided in pointblank","title":"Genere un 'snippet' de texto útil a partir de la tabla de destino — info_snippet","text":"convenience, several snip_*() functions provided package work column data informant's target table. : snip_list(): get list column categories snip_stats(): get inline statistical summary snip_lowest(): get lowest value column snip_highest() : get highest value column understood target table , column functions necessary obtaining resultant text.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_snippet.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Genere un 'snippet' de texto útil a partir de la tabla de destino — info_snippet","text":"pointblank informant can written YAML yaml_write() resulting YAML can used regenerate informant (yaml_read_informant()) perform 'incorporate' action using target table (via yaml_informant_incorporate()). Snippets stored YAML representation expressed R code YAML output (showing meta_snippets columns keys demonstrate relationship ).","code":"# Código R informant %>%    info_columns(     columns = \"date_time\",     `Latest Date` = \"The latest date is {latest_date}.\"   ) %>%   info_snippet(     snippet_name = \"latest_date\",     fn = ~ . %>% dplyr::pull(date) %>% max(na.rm = TRUE)   ) %>%   incorporate()  # Representación YAML meta_snippets:   latest_date: ~. %>% dplyr::pull(date) %>% max(na.rm = TRUE) ... columns:   date_time:     _type: POSIXct, POSIXt     Latest Date: The latest date is {latest_date}.   date:     _type: Date   item_count:     _type: integer"},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_snippet.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Genere un 'snippet' de texto útil a partir de la tabla de destino — info_snippet","text":"3-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_snippet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Genere un 'snippet' de texto útil a partir de la tabla de destino — info_snippet","text":"","code":"# Take the `small_table` and # assign it to `test_table`; we'll # modify it later test_table <- small_table  # Generate an informant object, add # two snippets with `info_snippet()`, # add information with some other # `info_*()` functions and then # `incorporate()` the snippets into # the info text informant <-    create_informant(     read_fn = ~ test_table,     tbl_name = \"test_table\",     label = \"Un ejemplo.\"   ) %>%   info_snippet(     snippet_name = \"row_count\",     fn = ~ . %>% nrow()   ) %>%   info_snippet(     snippet_name = \"max_a\",     fn = snip_highest(column = \"a\")   ) %>%   info_columns(     columns = vars(a),     info = \"In the range of 1 to {max_a}. (SIMPLE)\"   ) %>%   info_columns(     columns = starts_with(\"date\"),     info = \"Time-based values (e.g., `Sys.time()`).\"   ) %>%   info_columns(     columns = \"date\",     info = \"The date part of `date_time`. (CALC)\"   ) %>%   info_section(     section_name = \"rows\",     row_count = \"There are {row_count} rows available.\"   ) %>%   incorporate() #> Error in rlang::eval_tidy(., env = caller_env(n = 1)): object 'test_table' not found  # We can print the `informant` object # to see the information report  # Let's modify `test_table` to give # it more rows and an extra column test_table <-    dplyr::bind_rows(test_table, test_table) %>%   dplyr::mutate(h = a + c)  # Using `incorporate()` will cause # the snippets to be reprocessed, and, # the info text to be updated informant <-   informant %>% incorporate() #> Error in incorporate(.): object 'informant' not found"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_tabular.html","id":null,"dir":"Reference","previous_headings":"","what":"Agregue información que se centre en aspectos de la tabla de datos en su\nconjunto — info_tabular","title":"Agregue información que se centre en aspectos de la tabla de datos en su\nconjunto — info_tabular","text":"informant object created create_informant() function, two starter sections: (1) 'table' (2) 'columns'. 'table' section contain properties upon creation, supplied table name (name) table dimensions (_columns _rows). can add table-based properties info_tabular() function. providing series named arguments (form entry_name = \"*info text*.\"), can add information makes sense describing table whole.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_tabular.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Agregue información que se centre en aspectos de la tabla de datos en su\nconjunto — info_tabular","text":"","code":"info_tabular(x, ...)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_tabular.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Agregue información que se centre en aspectos de la tabla de datos en su\nconjunto — info_tabular","text":"x informant object class ptblank_informant. ... Information entries series named arguments. names refer subsection titles within TABLE section RHS info text (informational text can written Markdown styled Text Tricks).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_tabular.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Agregue información que se centre en aspectos de la tabla de datos en su\nconjunto — info_tabular","text":"Un objeto ptblank_informant.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_tabular.html","id":"info-text","dir":"Reference","previous_headings":"","what":"Info Text","title":"Agregue información que se centre en aspectos de la tabla de datos en su\nconjunto — info_tabular","text":"info text used info_*() functions readily accepts Markdown formatting, , Text Tricks can used spice presentation. Markdown links written < link url > [ link text ]( link url ) get nicely-styled links. dates expressed ISO-8601 standard parentheses, \"(2004-12-01)\", styled font variation (monospaced) underlined purple. Spans text can converted label-style text using: (1) double parentheses around text rectangular border ((label text)), (2) triple parentheses around text rounded-rectangular border like (((label text))). CSS style rules can applied spans info text following form: [[ info text ]]<< CSS style rules >> example practice suppose like change color text red make font appear somewhat thinner. variation following might used: \"[[factor]]<<color: red; font-weight: 300;>> value.\" quite CSS style rules can used great effect. might like: color: <color value>; (text color) background-color: <color value>; (text's background color) text-decoration: (overline | line-| underline); text-transform: (uppercase | lowercase | capitalize); letter-spacing: <+/- length value>; word-spacing: <+/- length value>; font-style: (normal | italic | oblique); font-weight: (normal | bold | 100-900); font-variant: (normal | bold | 100-900); border: <color value> <length value> (solid | dashed | dotted); examples, 'length value' refers CSS length can expressed different units measure (e.g., 12px, 1em, etc.). lengths can expressed positive negative values (e.g., letter-spacing). Color values can expressed ways, common form hexadecimal color values CSS color names.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_tabular.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Agregue información que se centre en aspectos de la tabla de datos en su\nconjunto — info_tabular","text":"pointblank informant can written YAML yaml_write() resulting YAML can used regenerate informant (yaml_read_informant()) perform 'incorporate' action using target table (via yaml_informant_incorporate()). info_tabular() represented YAML, info text goes subsections top-level table key. example call info_tabular() expressed R code corresponding YAML representation. Subsection titles defined info_tabular() can set backticks syntactically correct argument name without (e.g., using spaces, hyphens, etc.). safest use single quotation marks around info text directly editing YAML file. Note Markdown formatting info snippet placeholders (shown {snippet_1}, see info_snippet() information) preserved YAML. Markdown HTML conversion done printing informant (invoking get_informant_report() informant) processing snippets (generation insertion) done using incorporate() function. Thus, source text always maintained YAML representation never written processed form.","code":"# Código R informant %>%    info_tabular(     section_1 = \"*info text* 1.\",     `section 2` = \"*info text* 2 and {snippet_1}\"   )  # Representación YAML table:   _columns: 23   _rows: 205.0   _type: tbl_df   section_1: '*info text* 1.'   section 2: '*info text* 2 and {snippet_1}'"},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_tabular.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Agregue información que se centre en aspectos de la tabla de datos en su\nconjunto — info_tabular","text":"3-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_tabular.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Agregue información que se centre en aspectos de la tabla de datos en su\nconjunto — info_tabular","text":"","code":"# Create a pointblank `informant` # object with `create_informant()`; # we specify a `read_fn` with the # `~` followed by a statement that # gets the `small_table` dataset informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\"   )  # We can add *info text* to describe # the table with `info_tabular()` informant <-   informant %>%   info_tabular(     `Row Definition` = \"A row has randomized values.\",     Source = c(       \"- From the **pointblank** package.\",       \"- [https://rich-iannone.github.io/pointblank/]()\"      )    )  # Upon printing the `informant` object, we see # the additions made to the 'Table' section  if (interactive()) {  # The `informant` object can be written to # a YAML file with the `yaml_write()` # function; then information can # be directly edited or modified yaml_write(   informant = informant,   filename = \"informant.yml\" )  # The YAML file can then be read back # into an informant object with the # `yaml_read_informant()` function informant <-   yaml_read_informant(     filename = \"informant.yml\"   )  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/interrogate.html","id":null,"dir":"Reference","previous_headings":"","what":"Dado un agente que tiene un plan de validación, realice un interrogatorio — interrogate","title":"Dado un agente que tiene un plan de validación, realice un interrogatorio — interrogate","text":"agent information (.e., validation plan series validation steps), interrogation process can occur according plan. , agent gathered intel, can use functions like get_agent_report() all_passed() understand interrogation went .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/interrogate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dado un agente que tiene un plan de validación, realice un interrogatorio — interrogate","text":"","code":"interrogate(   agent,   extract_failed = TRUE,   get_first_n = NULL,   sample_n = NULL,   sample_frac = NULL,   sample_limit = 5000 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/interrogate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dado un agente que tiene un plan de validación, realice un interrogatorio — interrogate","text":"agent agent object class ptblank_agent created create_agent(). extract_failed option collect rows pass particular validation step. default TRUE options allow fine control rows collected. get_first_n option collect non-passing rows chosen, option collect first n rows . Supply number rows extract top non-passing rows table (ordering data original table retained). sample_n option collect non-passing rows chosen, option allows sampling n rows. Supply number rows sample non-passing rows table. n greater number non-passing rows, rows returned. sample_frac option collect non-passing rows chosen, option allows sampling fraction rows. Provide number range 0 1. number rows return may extremely large (especially querying remote databases), however, sample_limit option apply hard limit returned rows. sample_limit value limits possible number rows returned sampling non-passing rows using sample_frac option.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/interrogate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dado un agente que tiene un plan de validación, realice un interrogatorio — interrogate","text":"Un objeto ptblank_agent.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/interrogate.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Dado un agente que tiene un plan de validación, realice un interrogatorio — interrogate","text":"6-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/interrogate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dado un agente que tiene un plan de validación, realice un interrogatorio — interrogate","text":"","code":"if (interactive()) {  # Create a simple table with two # columns of numerical values tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5, 8, 7),     b = c(7, 1, 0, 0, 0, 3)   )  # Validate that values in column # `a` from `tbl` are always > 5, # using `interrogate()` carries out # the validation plan and completes # the whole process agent <-   create_agent(tbl = tbl) %>%   col_vals_gt(vars(a), value = 5) %>%   interrogate()  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/log4r_step.html","id":null,"dir":"Reference","previous_headings":"","what":"Habilite el registro de condiciones de falla en el nivel del paso de\nvalidación — log4r_step","title":"Habilite el registro de condiciones de falla en el nivel del paso de\nvalidación — log4r_step","text":"log4r_step() function can used action action_levels() function (list component fns list). Place call function every failure condition produce log (.e., warn, stop, notify). failure condition highest severity given validation step produce log entry (skipping failure conditions lower severity) long call log4r_step() present.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/log4r_step.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Habilite el registro de condiciones de falla en el nivel del paso de\nvalidación — log4r_step","text":"","code":"log4r_step(x, message = NULL, append_to = \"pb_log_file\")"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/log4r_step.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Habilite el registro de condiciones de falla en el nivel del paso de\nvalidación — log4r_step","text":"x reference x-list object prepared agent. version x-list generated via get_agent_x_list(<agent>, = <step>) except version internally generated hence available internal evaluation context. message message use log entry. provided, default glue string used messaging. dynamic since internal glue::glue() call occurs environment x, x-list constrained validation step. default message, used message = NULL glue string \"Step {x$} exceeded {level} failure threshold (f_failed = {x$f_failed}) ['{x$type}']\". can seen, custom message can crafted uses elements x-list {x$<component>} construction. append_to file log entries warn level appended. can alternatively one log4r appenders.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/log4r_step.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Habilite el registro de condiciones de falla en el nivel del paso de\nvalidación — log4r_step","text":"5-1","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::[\\%>\\%][magrittr::\\%>\\%] details.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.action_levels.html","id":null,"dir":"Reference","previous_headings":"","what":"Imprime el objeto action_levels — print.action_levels","title":"Imprime el objeto action_levels — print.action_levels","text":"function allow action_levels nicely printed.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.action_levels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Imprime el objeto action_levels — print.action_levels","text":"","code":"# S3 method for action_levels print(x, ...)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.action_levels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Imprime el objeto action_levels — print.action_levels","text":"x object class action_levels. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_agent.html","id":null,"dir":"Reference","previous_headings":"","what":"Imprime el objeto ptblank_agent — print.ptblank_agent","title":"Imprime el objeto ptblank_agent — print.ptblank_agent","text":"function allow agent object print useful HTML-based report.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_agent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Imprime el objeto ptblank_agent — print.ptblank_agent","text":"","code":"# S3 method for ptblank_agent print(x, view = interactive(), ...)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_agent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Imprime el objeto ptblank_agent — print.ptblank_agent","text":"x object class ptblank_agent. view value print()s browse argument. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_informant.html","id":null,"dir":"Reference","previous_headings":"","what":"Imprime el objeto  ptblank_informant — print.ptblank_informant","title":"Imprime el objeto  ptblank_informant — print.ptblank_informant","text":"function allow informant object print useful HTML-based report.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_informant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Imprime el objeto  ptblank_informant — print.ptblank_informant","text":"","code":"# S3 method for ptblank_informant print(x, view = interactive(), ...)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_informant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Imprime el objeto  ptblank_informant — print.ptblank_informant","text":"x informant object class ptblank_informant. view value print()s browse argument. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_multiagent.html","id":null,"dir":"Reference","previous_headings":"","what":"Imprime el objeto ptblank_multiagent — print.ptblank_multiagent","title":"Imprime el objeto ptblank_multiagent — print.ptblank_multiagent","text":"function allow multiagent object print useful HTML-based report.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_multiagent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Imprime el objeto ptblank_multiagent — print.ptblank_multiagent","text":"","code":"# S3 method for ptblank_multiagent print(x, view = interactive(), ...)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_multiagent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Imprime el objeto ptblank_multiagent — print.ptblank_multiagent","text":"x object class ptblank_multiagent. view value print()s browse argument. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_multiagent_report.long.html","id":null,"dir":"Reference","previous_headings":"","what":"Imprime el objeto ptblank_multiagent_report.long — print.ptblank_multiagent_report.long","title":"Imprime el objeto ptblank_multiagent_report.long — print.ptblank_multiagent_report.long","text":"function print ptblank_multiagent_report.long object, HTML-based report.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_multiagent_report.long.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Imprime el objeto ptblank_multiagent_report.long — print.ptblank_multiagent_report.long","text":"","code":"# S3 method for ptblank_multiagent_report.long print(x, view = interactive(), ...)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_multiagent_report.long.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Imprime el objeto ptblank_multiagent_report.long — print.ptblank_multiagent_report.long","text":"x object class ptblank_multiagent_report.long. view value print()s browse argument. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_tbl_scan.html","id":null,"dir":"Reference","previous_headings":"","what":"Imprime el objeto ptblank_tbl_scan — print.ptblank_tbl_scan","title":"Imprime el objeto ptblank_tbl_scan — print.ptblank_tbl_scan","text":"function print ptblank_tbl_scan object, HTML-based report.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_tbl_scan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Imprime el objeto ptblank_tbl_scan — print.ptblank_tbl_scan","text":"","code":"# S3 method for ptblank_tbl_scan print(x, ..., view = interactive())"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_tbl_scan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Imprime el objeto ptblank_tbl_scan — print.ptblank_tbl_scan","text":"x object class ptblank_tbl_scan. ... additional parameters. view value print()s browse argument.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.read_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Imprime el objeto read_fn — print.read_fn","title":"Imprime el objeto read_fn — print.read_fn","text":"function allow read_fn nicely printed.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.read_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Imprime el objeto read_fn — print.read_fn","text":"","code":"# S3 method for read_fn print(x, ...)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.read_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Imprime el objeto read_fn — print.read_fn","text":"x object class read_fn. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.tbl_store.html","id":null,"dir":"Reference","previous_headings":"","what":"Imprime el objeto tbl_store — print.tbl_store","title":"Imprime el objeto tbl_store — print.tbl_store","text":"function allow tbl_store nicely printed.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.tbl_store.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Imprime el objeto tbl_store — print.tbl_store","text":"","code":"# S3 method for tbl_store print(x, ...)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.tbl_store.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Imprime el objeto tbl_store — print.tbl_store","text":"x object class tbl_store. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.x_list_i.html","id":null,"dir":"Reference","previous_headings":"","what":"Imprima una x-list de un solo paso en la consola — print.x_list_i","title":"Imprima una x-list de un solo paso en la consola — print.x_list_i","text":"function print x-list object, single step, console.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.x_list_i.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Imprima una x-list de un solo paso en la consola — print.x_list_i","text":"","code":"# S3 method for x_list_i print(x, ...)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.x_list_i.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Imprima una x-list de un solo paso en la consola — print.x_list_i","text":"x x-list object class x_list_i. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.x_list_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Imprima una x-list que incluya todos los pasos de validación en la consola — print.x_list_n","title":"Imprima una x-list que incluya todos los pasos de validación en la consola — print.x_list_n","text":"function print x-list object, validation steps included, console.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.x_list_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Imprima una x-list que incluya todos los pasos de validación en la consola — print.x_list_n","text":"","code":"# S3 method for x_list_n print(x, ...)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.x_list_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Imprima una x-list que incluya todos los pasos de validación en la consola — print.x_list_n","text":"x x-list object class x_list_n. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/read_disk_multiagent.html","id":null,"dir":"Reference","previous_headings":"","what":"Leer objetos pointblank agent almacenados en el disco como multiagent — read_disk_multiagent","title":"Leer objetos pointblank agent almacenados en el disco como multiagent — read_disk_multiagent","text":"agent informant can written disk x_write_disk() function. useful later retrieving stored agent x_read_disk() also possible read series -disk agents read_disk_multiagent() function, creates ptblank_multiagent object. multiagent object can also generated via create_multiagent() function less convenient use one just using agents previous written disk.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/read_disk_multiagent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Leer objetos pointblank agent almacenados en el disco como multiagent — read_disk_multiagent","text":"","code":"read_disk_multiagent(filenames = NULL, pattern = NULL, path = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/read_disk_multiagent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Leer objetos pointblank agent almacenados en el disco como multiagent — read_disk_multiagent","text":"filenames names files (holding agent objects) previously written x_write_disk(). pattern regex pattern accessing saved--disk agent files located directory (specified path argument). path path collection files. either optional case files specified filenames (path combined filenames), , required providing pattern file names.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/read_disk_multiagent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Leer objetos pointblank agent almacenados en el disco como multiagent — read_disk_multiagent","text":"Un objeto ptblank_multiagent.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/read_disk_multiagent.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Leer objetos pointblank agent almacenados en el disco como multiagent — read_disk_multiagent","text":"10-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. blastula creds, creds_anonymous, creds_file, creds_key dplyr , case_when, vars rlang expr tidyselect contains, ends_with, everything, matches, starts_with","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_read_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Eliminar una fórmula de preparación de tablas asociada con un agent o\ninformant — remove_read_fn","title":"Eliminar una fórmula de preparación de tablas asociada con un agent o\ninformant — remove_read_fn","text":"Removing agent informant's association table-pre formula can done remove_read_fn(). may good idea interactive session needing rely direct association 'fixed' data table (settable create_agent() create_informant()'s tbl argument set_tbl()) instead using table-prep formula might produce different different table expected. table-prep formula can always set set_read_fn().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_read_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Eliminar una fórmula de preparación de tablas asociada con un agent o\ninformant — remove_read_fn","text":"","code":"remove_read_fn(x)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_read_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Eliminar una fórmula de preparación de tablas asociada con un agent o\ninformant — remove_read_fn","text":"x agent object class ptblank_agent, , informant class ptblank_informant.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_read_fn.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Eliminar una fórmula de preparación de tablas asociada con un agent o\ninformant — remove_read_fn","text":"9-7","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_read_fn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Eliminar una fórmula de preparación de tablas asociada con un agent o\ninformant — remove_read_fn","text":"","code":"# Set proportional failure thresholds # to the `warn`, `stop`, and `notify` # states using `action_levels()` al <-    action_levels(       warn_at = 0.10,       stop_at = 0.25,     notify_at = 0.35   )  # Create an agent that directly ingests # the `small_table` object and also has # a table-prep formula (when both are # present the latter always obtains the # table); apply the actions, add some # validation steps and then interrogate # the data that was read in agent_1 <-    create_agent(     tbl = small_table,     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\",     actions = al   ) %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b), \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   interrogate()    # In a situation where `small_table` # changes frequently and it's desirable # to have a snapshot of the table, we # can remove the table-prep formula so # that the ingested `small_table` will # be used agent_2 <-   agent_1 %>%   remove_read_fn() %>%   interrogate()"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_steps.html","id":null,"dir":"Reference","previous_headings":"","what":"Eliminar uno o más de los pasos de validación de un objeto agent — remove_steps","title":"Eliminar uno o más de los pasos de validación de un objeto agent — remove_steps","text":"Validation steps can removed agent object use remove_steps() function. useful, instance, getting agent disk (via x_read_disk() function) omitting one steps agent's validation plan. Please note removing validation steps stored data extracts removed agent.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_steps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Eliminar uno o más de los pasos de validación de un objeto agent — remove_steps","text":"","code":"remove_steps(agent, i = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_steps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Eliminar uno o más de los pasos de validación de un objeto agent — remove_steps","text":"agent Un objeto de agente de clase ptblank_agent. validation step number, assigned validation step order definition. NULL (default) step removal occur index.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_steps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Eliminar uno o más de los pasos de validación de un objeto agent — remove_steps","text":"Un objeto ptblank_agent. Un objeto ptblank_agent.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_steps.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Eliminar uno o más de los pasos de validación de un objeto agent — remove_steps","text":"9-8","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_steps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Eliminar uno o más de los pasos de validación de un objeto agent — remove_steps","text":"","code":"# Create an agent that has the # `small_table` object as the # target table, add a few # validation steps, and then use # `interrogate()` agent_1 <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\"   ) %>%   col_exists(vars(date)) %>%   col_vals_regex(     vars(b), regex = \"[0-9]-[a-z]{3}-[0-9]\"   ) %>%   interrogate()    # The second validation step has # been determined to be unneeded and # is to be removed; this can be done # by used `remove_steps()` with the # agent object agent_2 <-   agent_1 %>%   remove_steps(i = 2) %>%   interrogate()"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_tbl.html","id":null,"dir":"Reference","previous_headings":"","what":"Eliminar una tabla de datos asociada con un agent o informant — remove_tbl","title":"Eliminar una tabla de datos asociada con un agent o informant — remove_tbl","text":"Removing agent informant's association data table can done remove_tbl() function. can useful ensure table data unintentionally written disk. usually best avoid directly associating table agent informant tbl argument, instead opting setting table-prep formula (via create_agent() create_informant()'s read_fn argument, , set_read_fn()). necessary, association table can set set_tbl().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_tbl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Eliminar una tabla de datos asociada con un agent o informant — remove_tbl","text":"","code":"remove_tbl(x)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_tbl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Eliminar una tabla de datos asociada con un agent o informant — remove_tbl","text":"x agent object class ptblank_agent, , informant class ptblank_informant.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_tbl.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Eliminar una tabla de datos asociada con un agent o informant — remove_tbl","text":"9-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_tbl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Eliminar una tabla de datos asociada con un agent o informant — remove_tbl","text":"","code":"# Set proportional failure thresholds # to the `warn`, `stop`, and `notify` # states using `action_levels()` al <-    action_levels(       warn_at = 0.10,       stop_at = 0.25,     notify_at = 0.35   )  # Create an agent that has # `small_table` set as the target # table via `tbl`; apply the actions, # add some validation steps and then # interrogate the data agent_1 <-    create_agent(     tbl = small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\",     actions = al   ) %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b), \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   interrogate()    # In this case where `small_table` # changes (and the aim is to have # validations run periodically) it is # better to obtain the table from the # source with a table-prep formula; # while doing this, the direct # association to `small_table` can be # removed with `remove_tbl()` so it's # no longer part of the agent object agent_2 <-   agent_1 %>%   remove_tbl() %>%   set_read_fn(read_fn = ~ small_table) %>%   interrogate()"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/row_count_match.html","id":null,"dir":"Reference","previous_headings":"","what":"Does the row count match that of a different table? — row_count_match","title":"Does the row count match that of a different table? — row_count_match","text":"row_count_match() validation function, expect_row_count_match() expectation function, test_row_count_match() test function check whether row count target table matches comparison table. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation, single test unit hinges whether row counts two tables (preconditions applied).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/row_count_match.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Does the row count match that of a different table? — row_count_match","text":"","code":"row_count_match(   x,   tbl_compare,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_row_count_match(   object,   tbl_compare,   preconditions = NULL,   threshold = 1 )  test_row_count_match(object, tbl_compare, preconditions = NULL, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/row_count_match.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Does the row count match that of a different table? — row_count_match","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). tbl_compare table compare target table terms row count values. can either table object, table-prep formula.can table object data frame, tibble, tbl_dbi object, tbl_spark object. Alternatively, table-prep formula (~ <table reading code>) function (function() <table reading code>) can used lazily read table interrogation time. preconditions Una expresión opcional para mutar la tabla de entrada antes de continuar con la validación. Esto se puede proporcionar como una fórmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una función (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la sección Preconditions para obtener más información. segments Una expresión opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la sección Segments para obtener más detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/row_count_match.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Does the row count match that of a different table? — row_count_match","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/row_count_match.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Does the row count match that of a different table? — row_count_match","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires operation target table row count comparison takes place. Using preconditions can useful times since since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed. Alternatively, function instead supplied.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/row_count_match.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Does the row count match that of a different table? — row_count_match","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/row_count_match.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Does the row count match that of a different table? — row_count_match","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. Using action_levels(warn_at = 1) action_levels(stop_at = 1) good choices depending situation (first produces warning, stop()s).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/row_count_match.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Does the row count match that of a different table? — row_count_match","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/row_count_match.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Does the row count match that of a different table? — row_count_match","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). row_count_match() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call row_count_match() validation step expressed R code corresponding YAML representation. practice, often shorter. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    row_count_match(     tbl_compare = ~ file_tbl(       file = from_github(         file = \"all_revenue_large.rds\",         repo = \"rich-iannone/intendo\",         subdir = \"data-large\"         )       ),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `row_count_match()` step.\",     active = FALSE   )  # YAML representation steps: - row_count_match:     tbl_compare: ~ file_tbl(       file = from_github(         file = \"all_revenue_large.rds\",         repo = \"rich-iannone/intendo\",         subdir = \"data-large\"         )       )     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `row_count_match()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/row_count_match.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Does the row count match that of a different table? — row_count_match","text":"2-31","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/row_count_match.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Does the row count match that of a different table? — row_count_match","text":"","code":"# Create a simple table with three # columns and four rows of values tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5),     b = c(7, 1, 0, 0),     c = c(1, 1, 1, 3)   )  # Create a second table which is # quite different but has the # same number of rows as `tbl` tbl_2 <-   dplyr::tibble(     e = c(\"a\", NA, \"a\", \"c\"),     f = c(2.6, 1.2, 0, NA)   )  # Validate that the count of rows # in the target table (`tbl`) matches # that of the comparison table # (`tbl_2`) agent <-   create_agent(tbl = tbl) %>%   row_count_match(tbl_compare = tbl_2) %>%   interrogate()  # Determine if this validation passed # by using `all_passed()` all_passed(agent) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_complete.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Están completos los datos de las filas? — rows_complete","title":"¿Están completos los datos de las filas? — rows_complete","text":"La función de validación rows_complete(), la función de expectativa expect_rows_complete() y la función de prueba test_rows_complete() comprueban si las filas contienen algún valor NA/NULL (opcionalmente restringido una selección de columns). La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre el número de unidades de prueba que es igual al número de filas en la tabla (después de que se hayan aplicado las preconditions). Podemos especificar los nombres de las columnas restrictivas entre comillas, en var(), y con las siguientes funciones auxiliares tidyselect: starts_with(), ends_with(), contains(), matches() y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_complete.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Están completos los datos de las filas? — rows_complete","text":"","code":"rows_complete(   x,   columns = NULL,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_rows_complete(   object,   columns = NULL,   preconditions = NULL,   threshold = 1 )  test_rows_complete(object, columns = NULL, preconditions = NULL, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_complete.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Están completos los datos de las filas? — rows_complete","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. preconditions Una expresión opcional para mutar la tabla de entrada antes de continuar con la validación. Esto se puede proporcionar como una fórmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una función (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la sección Preconditions para obtener más información. segments Una expresión opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la sección Segments para obtener más detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_complete.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Están completos los datos de las filas? — rows_complete","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_complete.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¿Están completos los datos de las filas? — rows_complete","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesará la tabla de destino durante la interrogación como paso preparatorio. Puede suceder que una validación en particular requiera una columna calculada, algún filtrado de filas o la adición de columnas través de una combinación, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validación con una sola tabla de destino y realice ajustes menores en ella, según sea necesario, lo largo del camino. La mutación de la tabla está totalmente aislada en el alcance de los pasos de validación en los que se utilizan las preconditions. Aquí se sugiere usar el código dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El código se proporciona más fácilmente como una fórmula R unilateral (utilizando un ~ inicial). En la representación de la fórmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podría proporcionar una función (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_complete.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¿Están completos los datos de las filas? — rows_complete","text":"Al usar el argumento segments, es posible definir una validación particular con segmentos (o porciones de fila) de la tabla de destino. Una expresión opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresión que se puede utilizar, vars(a_column) segmentará la tabla de destino en la forma en que estén presentes muchos valores únicos en la columna llamada a_column. Esto es excelente si cada valor único en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validación repetida. Con una fórmula, podemos ser más selectivos con los valores de columna que se deben usar para la segmentación. El uso de a_column ~ c(\"group_1\", \"group_2\") intentará obtener dos segmentos donde uno es una porción de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la fórmula dará como resultado un paso de validación independiente. La segmentación siempre ocurrirá después de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinación, es posible generar etiquetas para la segmentación usando una expresión para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versión separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_complete.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Están completos los datos de las filas? — rows_complete","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situación (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_complete.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Están completos los datos de las filas? — rows_complete","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_complete.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Están completos los datos de las filas? — rows_complete","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando rows_complete() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de rows_complete() como paso de validación se expresa en código R y en la representación YAML correspondiente. En la práctica, ambos serán menudo más cortos. Un valor para columns sólo es sólo es necesario si se buscan valores únicos en un subconjunto de columnas. Los argumentos con valores por defecto se escribirán en YAML cuando se utilice yaml_write() (aunque es aceptable incluirlos con su valor por defecto al generar el YAML por otros medios). También es posible previsualizar la transformación de un agente YAML sin necesidad de escribirlo en el disco, utilizando la función yaml_agent_string().","code":"# Código R agent %>%    rows_complete(     columns = vars(a, b),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `rows_complete()`.\",     active = FALSE   )  # Representación YAML steps: - rows_complete:     columns: vars(a, b)     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `rows_complete()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_complete.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Están completos los datos de las filas? — rows_complete","text":"2-21","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_complete.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Están completos los datos de las filas? — rows_complete","text":"","code":"# Cree una tabla sencilla con tres # columnas de valores numéricos tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5, 8, 7),     b = c(7, 1, 0, 0, 8, 3),     c = c(1, 1, 1, 3, 3, 3)   )  # Validar que al considerar sólo # los datos de las columnas `a` y # `b`, sólo hay filas completas (es # decir, todas las filas no tienen # valores `NA`) agent <-   create_agent(tbl = tbl) %>%   rows_complete(vars(a, b)) %>%   interrogate()  # Determine si esta validación # pasó usando `all_passed()` all_passed(agent) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_distinct.html","id":null,"dir":"Reference","previous_headings":"","what":"¿Son distintos los datos de las filas? — rows_distinct","title":"¿Son distintos los datos de las filas? — rows_distinct","text":"La función de validación rows_distinct(), la función de expectativa expect_rows_distinct() y la función de prueba test_rows_distinct() comprueban si los valores de las filas (opcionalmente restringidos una selección de columns especificadas) son, cuando se toman como una unidad completa, distintos de todas las demás unidades de la tabla. La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validación o expectativa operará sobre el número de unidades de prueba que es igual al número de filas en la tabla (después de que se hayan aplicado las preconditions). Podemos especificar los nombres de las columnas restrictivas entre comillas, en var(), y con las siguientes funciones auxiliares tidyselect: starts_with(), ends_with(), contains(), matches() y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_distinct.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿Son distintos los datos de las filas? — rows_distinct","text":"","code":"rows_distinct(   x,   columns = NULL,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_rows_distinct(   object,   columns = NULL,   preconditions = NULL,   threshold = 1 )  test_rows_distinct(object, columns = NULL, preconditions = NULL, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_distinct.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿Son distintos los datos de las filas? — rows_distinct","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validación. preconditions Una expresión opcional para mutar la tabla de entrada antes de continuar con la validación. Esto se puede proporcionar como una fórmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una función (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la sección Preconditions para obtener más información. segments Una expresión opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la sección Segments para obtener más detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_distinct.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿Son distintos los datos de las filas? — rows_distinct","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_distinct.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¿Son distintos los datos de las filas? — rows_distinct","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesará la tabla de destino durante la interrogación como paso preparatorio. Puede suceder que una validación en particular requiera una columna calculada, algún filtrado de filas o la adición de columnas través de una combinación, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validación con una sola tabla de destino y realice ajustes menores en ella, según sea necesario, lo largo del camino. La mutación de la tabla está totalmente aislada en el alcance de los pasos de validación en los que se utilizan las preconditions. Aquí se sugiere usar el código dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El código se proporciona más fácilmente como una fórmula R unilateral (utilizando un ~ inicial). En la representación de la fórmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podría proporcionar una función (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_distinct.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¿Son distintos los datos de las filas? — rows_distinct","text":"Al usar el argumento segments, es posible definir una validación particular con segmentos (o porciones de fila) de la tabla de destino. Una expresión opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresión que se puede utilizar, vars(a_column) segmentará la tabla de destino en la forma en que estén presentes muchos valores únicos en la columna llamada a_column. Esto es excelente si cada valor único en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validación repetida. Con una fórmula, podemos ser más selectivos con los valores de columna que se deben usar para la segmentación. El uso de a_column ~ c(\"group_1\", \"group_2\") intentará obtener dos segmentos donde uno es una porción de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la fórmula dará como resultado un paso de validación independiente. La segmentación siempre ocurrirá después de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinación, es posible generar etiquetas para la segmentación usando una expresión para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versión separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_distinct.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿Son distintos los datos de las filas? — rows_distinct","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situación (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_distinct.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿Son distintos los datos de las filas? — rows_distinct","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_distinct.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿Son distintos los datos de las filas? — rows_distinct","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando rows_distinct() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de rows_distinct() como paso de validación se expresa en código R y en la representación YAML correspondiente. En la práctica, ambos serán menudo más cortos. Un valor para columns sólo es sólo es necesario si se buscan valores únicos en un subconjunto de columnas. Los argumentos con valores por defecto se escribirán en YAML cuando se utilice yaml_write() (aunque es aceptable incluirlos con su valor por defecto al generar el YAML por otros medios). También es posible previsualizar la transformación de un agente YAML sin necesidad de escribirlo en el disco, utilizando la función yaml_agent_string().","code":"# Código R agent %>%    rows_distinct(     columns = vars(a, b),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `rows_distinct()`.\",     active = FALSE   )  # Representación YAML steps: - rows_distinct:     columns: vars(a, b)     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `rows_distinct()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_distinct.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿Son distintos los datos de las filas? — rows_distinct","text":"2-20","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_distinct.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿Son distintos los datos de las filas? — rows_distinct","text":"","code":"# Create a simple table with three # columns of numerical values tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5, 8, 7),     b = c(7, 1, 0, 0, 8, 3),     c = c(1, 1, 1, 3, 3, 3)   )  # Validate that when considering only # data in columns `a` and `b`, there # are no duplicate rows (i.e., all # rows are distinct) agent <-   create_agent(tbl = tbl) %>%   rows_distinct(vars(a, b)) %>%   interrogate()  # Determine si esta validación # pasó usando `all_passed()` all_passed(agent) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/scan_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Escanee minuciosamente una tabla para comprenderla mejor — scan_data","title":"Escanee minuciosamente una tabla para comprenderla mejor — scan_data","text":"Generar un informe HTML que recorra los datos de la tabla de entrada. Antes de llamar un agente para validar los datos, es una buena idea entender los datos con cierto nivel de precisión. Haga que este sea el paso inicial de un flujo de trabajo bien equilibrado de  *flujo de trabajo de información sobre la calidad de los datos. La salida del informe contiene varias secciones para hacer todo más digerible, y estas son: Overview Dimensiones de la tabla, recuento de filas duplicadas, tipos de columnas y información de reproducibilidad Variables Un resumen para cada variable de la tabla y más estadísticas y resúmenes en función del tipo de variable Interactions Un gráfico matricial que muestra las interacciones entre las variables Correlations Un conjunto de gráficos de matrices de correlación para variables numéricas variables numéricas Missing Values Una figura de resumen que muestra el grado de ausencia en todas las variables Sample Una tabla que proporciona las filas de cabeza y cola del conjunto de datos El informe HTML de salida aparecerá en el visor de RStudio y también puede integrarse en la salida HTML de R Markdown. Si necesita el HTML de salida como una cadena, es posible obtenerlo utilizando .character() (por ejemplo, scan_data(tbl = mtcars) %>% .character()). La cadena HTML resultante es un documento HTML completo donde Bootstrap y jQuery están incrustados en su interior.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/scan_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Escanee minuciosamente una tabla para comprenderla mejor — scan_data","text":"","code":"scan_data(   tbl,   sections = \"OVICMS\",   navbar = TRUE,   width = NULL,   lang = NULL,   locale = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/scan_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Escanee minuciosamente una tabla para comprenderla mejor — scan_data","text":"tbl La tabla de entrada. Puede ser un marco de datos, un tibble, un objeto tbl_dbi o un objeto tbl_spark. sections Las secciones incluir en el informe finalizado de Escaneo de Tablas. Aquí se requiere una cadena con caracteres clave que representen los nombres de las secciones. La cadena por defecto es \"OVICMS\" donde cada letra representa las siguientes secciones en su orden por defecto: \"O\": \"overview\"; \"V\": \"variables\"; \"\": \"interactions\"; \"C\": \"correlations\"; \"M\": \"missing\"; y \"S\": \"sample\". Esta cadena puede estar compuesta por menos caracteres y el orden puede cambiarse para adaptarse al diseño deseado del informe. En el caso de los objetos tbl_dbi y tbl_spark suministrados tbl, las secciones de \"interactions\" y \"correlations\" están excluidas. navbar ¿Debe haber una barra de navegación anclada en la parte superior de la página del informe? Por defecto es TRUE. width Una anchura fija opcional (en píxeles) para el informe HTML. Por defecto se aplica ninguna anchura fija. lang El idioma que se utilizará para el texto de la etiqueta en el informe. De forma predeterminada, NULL creará texto en inglés (\"en\"). Otras opciones incluyen francés (\"fr\"), alemán (\"de\"), italiano (\"\"), español (\"es\"), portugués (\"pt\"), turco (\"tr\"), chino (\"zh\"), ruso (\"ru\"), polaco (\"pl\"), danés (\"da\"), sueco (\"sv\" ) y holandés (\"nl\"). locale Un identificador opcional de la configuración regional que se utilizará para formatear los valores en el informe de acuerdo con las reglas de la configuración regional. Los ejemplos incluyen \"en_US\" para el inglés (Estados Unidos) y \"fr_FR\" para el francés (Francia); más sencillamente, puede ser un identificador de idioma sin designación de país, como \"es\" para español (España, igual que \"es_ES\").","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/scan_data.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Escanee minuciosamente una tabla para comprenderla mejor — scan_data","text":"1-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/scan_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Escanee minuciosamente una tabla para comprenderla mejor — scan_data","text":"","code":"if (interactive()) {  # Obtener un documento HTML que describa # los datos de la tabla `dplyr::storms` tbl_scan <- scan_data(tbl = dplyr::storms)  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/serially.html","id":null,"dir":"Reference","previous_headings":"","what":"Ejecutar varias pruebas y una validación final en serie — serially","title":"Ejecutar varias pruebas y una validación final en serie — serially","text":"La función de validación serially() permite ejecutar una serie de pruebas en secuencia antes de culminar con un paso de validación final o simplemente salir de la serie. Esta construcción permite realizar pruebas previas que pueden tener sentido antes de un paso de validación. Por ejemplo, puede haber situaciones en las que es vital comprobar el tipo de columna antes de realizar una validación en la misma columna (ya que tener un tipo incorrecto puede dar lugar un error de evaluación para la validación posterior). Otro flujo de trabajo en serie podría implicar tener un conjunto de comprobaciones en un orden prescrito y, si todas pasan, entonces el objetivo de estas pruebas se ha alcanzado (por ejemplo, comprobar si una tabla coincide con otra través de una serie de pruebas cada vez más específicas). Una serie como se especifica dentro de serially() se compone con un listado de llamadas, y nos basaríamos en las funciones de prueba (T) para describir las pruebas y opcionalmente proporcionar una llamada final con una función de validación (V). Se aplican las siguientes restricciones: debe haber al menos una función de prueba en la serie (T -> V es buena, V es ) sólo puede haber una llamada la función de validación, V; es opcional pero, si se incluye, debe colocarse al final (T -> T -> V es buena, estas secuencias son malas: (1) T -> V -> T, (2) T -> T -> V -> V) una llamada la función de validación (V), si se incluye, debe producir por sí misma múltiples pasos de validación (esto puede ocurrir cuando se proporcionan múltiples columns o cualquier segments) Este es un ejemplo de cómo organizar las expresiones: Esta serie se concentra en la columna llamada count y primero comprueba si la columna existe, luego comprueba si esa columna es numérica, y luego finalmente valida si todos los valores de la columna son mayores que 2. Tenga en cuenta que en la lista de llamadas anterior, el . representa la tabla de destino y siempre es necesario aquí. También es importante que todas las funciones test_*() tienen un argumento threshold que se establece en 1 por defecto. Si necesita aumentar el valor del umbral, puede cambiarlo un valor entero diferente (como umbral absoluto de unidades de prueba que fallan) o un valor decimal entre 0 y 1 (que sirve como umbral fraccionario de unidades de prueba que fallan). unidades de prueba que fallan).","code":"~ test_col_exists(., columns = vars(count)), ~ test_col_is_numeric(., columns = vars(count)), ~ col_vals_gt(., columns = vars(count), value = 2)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/serially.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ejecutar varias pruebas y una validación final en serie — serially","text":"","code":"serially(   x,   ...,   .list = list2(...),   preconditions = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_serially(   object,   ...,   .list = list2(...),   preconditions = NULL,   threshold = 1 )  test_serially(   object,   ...,   .list = list2(...),   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/serially.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ejecutar varias pruebas y una validación final en serie — serially","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). ... Una colección de fórmulas unilaterales que consisten en llamadas funciones test_*() (por ejemplo, test_col_vals_between(), etc.) dispuestas en la secuencia del orden de interrogación previsto. Típicamente, las validaciones hasta la final tendrían algún valor de threshold establecido (por defecto es 1) para el cortocircuito dentro de la serie. Una llamada la función de validación final (por ejemplo, col_vals_increasing(), etc.) puede insertarse opcionalmente al final de la serie, sirviendo como un paso de validación que sólo se somete interrogación si las pruebas anteriores pasan adecuadamente. Un ejemplo de esto es ~ test_column_exists(., vars()), ~ col_vals_not_null(., vars())). .list Permite el uso de una lista como alternativa de entrada .... preconditions Una expresión opcional para mutar la tabla de entrada antes de continuar con la validación. Esto se puede proporcionar como una fórmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una función (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la sección Preconditions para obtener más información. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/serially.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ejecutar varias pruebas y una validación final en serie — serially","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/serially.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"Ejecutar varias pruebas y una validación final en serie — serially","text":"Si se proporcionan varios nombres de columna en cualquiera de los pasos de validación suministrados, el resultado será una expansión de los pasos de subvalidación ese número de nombres de columna. Aparte de los nombres de columnas entre comillas y en vars(), las funciones de ayuda tidyselect están disponibles para especificar columnas. Son: starts_with(), ends_with(), contains(), matches() y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/serially.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Ejecutar varias pruebas y una validación final en serie — serially","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesará la tabla de destino durante la interrogación como paso preparatorio. Puede suceder que una validación en particular requiera una columna calculada, algún filtrado de filas o la adición de columnas través de una combinación, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validación con una sola tabla de destino y realice ajustes menores en ella, según sea necesario, lo largo del camino. La mutación de la tabla está totalmente aislada en el alcance de los pasos de validación en los que se utilizan las preconditions. Aquí se sugiere usar el código dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El código se proporciona más fácilmente como una fórmula R unilateral (utilizando un ~ inicial). En la representación de la fórmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podría proporcionar una función (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/serially.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Ejecutar varias pruebas y una validación final en serie — serially","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situación (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop()s en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/serially.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Ejecutar varias pruebas y una validación final en serie — serially","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/serially.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Ejecutar varias pruebas y una validación final en serie — serially","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando serially() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de serially() como paso de validación se expresa en código R y en la representación YAML correspondiente. En la práctica, ambos serán menudo más cortos, ya que solo son necesarias las expresiones para los pasos de validación. Los argumentos con valores predeterminados se escribirán en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). También es posible obtener una vista previa de la transformación de un agente YAML sin escribir en el disco usando la función yaml_agent_string().","code":"# Código R agent %>%    serially(     ~ col_vals_lt(., vars(a), 8),     ~ col_vals_gt(., vars(c), vars(a)),     ~ col_vals_not_null(., vars(b)),     preconditions = ~ . %>% dplyr::filter(a < 10),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),      label = \"El paso `serially()`.\",     active = FALSE   )  # Representación YAML steps: - serially:     fns:     - ~col_vals_lt(., vars(a), 8)     - ~col_vals_gt(., vars(c), vars(a))     - ~col_vals_not_null(., vars(b))     preconditions: ~. %>% dplyr::filter(a < 10)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `serially()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/serially.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Ejecutar varias pruebas y una validación final en serie — serially","text":"2-32","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/serially.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ejecutar varias pruebas y una validación final en serie — serially","text":"","code":"# Para todos los ejemplos aquí, # usaremos una tabla simple con tres # columnas numéricas (`a`, `b` y `c`); # esta es una tabla muy básica pero # será más útil a la hora de explicar # las cosas más adelante tbl <-   dplyr::tibble(     a = c(5, 2, 6),     b = c(6, 4, 9),     c = c(1, 2, 3)   )    tbl #> # A tibble: 3 × 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     6     1 #> 2     2     4     2 #> 3     6     9     3    # A: Usando un `agent` con funciones de #    validación y luego `interrogate()`  # La función `serially()` puede # configurarse para realizar una serie # de pruebas y luego realizar una # validación (sólo si se superan todas # las pruebas); en este caso, vamos a # (1) comprobar si las columnas `a` y `b` # son numéricas, (2) comprobar que ambas # no tienen ningún valor `NA`, y # (3) realizar una validación final que # compruebe si los valores de `b` son # mayores que los valores de `a`. agent_1 <-   create_agent(tbl = tbl) %>%   serially(     ~ test_col_is_numeric(., vars(a, b)),     ~ test_col_vals_not_null(., vars(a, b)),     ~ col_vals_gt(., vars(b), vars(a))     ) %>%   interrogate()    # Determine si esta validación no tuvo # unidades de prueba fallidas (hay 4 # pruebas y una validación final) all_passed(agent_1) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent_1)`  # ¿Qué ocurre? Las cuatro pruebas han # sido aprobadas y, por tanto, se ha # producido la validación final; # ¡tampoco ha habido unidades de prueba # que hayan fallado!  # La validación final es opcional; # aquí hay un agente diferente en el # que sólo se realizan las pruebas en # serie se realizan agent_2 <-   create_agent(tbl = tbl) %>%   serially(     ~ test_col_is_numeric(., vars(a, b)),     ~ test_col_vals_not_null(., vars(a, b))   ) %>%   interrogate()    # Todo es bueno aquí también: all_passed(agent_2) #> [1] TRUE  # B: Usando la función de validación #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validación actúa como un filtro de # datos: los datos se pasan a través, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opción `actions` tbl %>%   serially(     ~ test_col_is_numeric(., vars(a, b)),     ~ test_col_vals_not_null(., vars(a, b)),     ~ col_vals_gt(., vars(b), vars(a))   ) #> # A tibble: 3 × 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     6     1 #> 2     2     4     2 #> 3     6     9     3  # C: Usando la función de expectativa  # Con el formulario `expect_*()`, # necesitamos ser más exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_serially(   tbl,   ~ test_col_is_numeric(., vars(a, b)),   ~ test_col_vals_not_null(., vars(a, b)),   ~ col_vals_gt(., vars(b), vars(a)) )  # D: Usando la función de prueba  # Con la forma `test_*()`, deberíamos # obtener un único valor lógico devuelto tbl %>%   test_serially(     ~ test_col_is_numeric(., vars(a, b)),     ~ test_col_vals_not_null(., vars(a, b)),     ~ col_vals_gt(., vars(b), vars(a))   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/set_read_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Establezca una fórmula de preparación de mesa para un agent o informant — set_read_fn","title":"Establezca una fórmula de preparación de mesa para un agent o informant — set_read_fn","text":"Una fórmula de preparación de tablas puede asociarse un agent o informant con set_read_fn(). En caso de que tanto un tbl *como un read_fn estén asociados al objeto agent o informant, el read_fn tendrá prioridad. Podemos especificar un valor valor para read_fn con una expresión de fórmula RHS (por ejemplo, ~ { <código de lectura de tabla> }). La fórmula de lectura de la tabla puede eliminarse con remove_read_fn() o reemplazada con set_read_fn().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/set_read_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Establezca una fórmula de preparación de mesa para un agent o informant — set_read_fn","text":"","code":"set_read_fn(x, read_fn)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/set_read_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Establezca una fórmula de preparación de mesa para un agent o informant — set_read_fn","text":"x Un objeto agent de la clase ptblank_agent, o, un objeto informant de clase ptblank_informant. read_fn Una expresión de fórmula R (por ejemplo, ~ { <código de lectura de la tabla> }) que se utiliza para preparar una tabla.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/set_read_fn.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Establezca una fórmula de preparación de mesa para un agent o informant — set_read_fn","text":"9-6","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/set_read_fn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Establezca una fórmula de preparación de mesa para un agent o informant — set_read_fn","text":"","code":"# Establecer umbrales de fallo # proporcionales a los estados # `warn`, `stop` y `notify` # utilizando `action_levels()` al <-    action_levels(       warn_at = 0.10,       stop_at = 0.25,     notify_at = 0.35   )  # Crear un objeto agente que # lea en `small_table` con una # fórmula de preparación de tabla; # aplicar las acciones, añadir # algunos pasos de validación y # luego interrogar los datos agent_1 <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\",     actions = al   ) %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b), \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   interrogate()    # Cambie la fórmula de preparación # de la tabla para utilizar una # versión mutada de `small_table` # (que elimine las filas duplicadas); # a continuación, interrogue la # tabla de destino de nuevo agent_2 <-   agent_1 %>%   set_read_fn(     read_fn = ~ small_table %>% dplyr::distinct()   ) %>%   interrogate()"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/set_tbl.html","id":null,"dir":"Reference","previous_headings":"","what":"Establecer una tabla de datos para un agent o informant — set_tbl","title":"Establecer una tabla de datos para un agent o informant — set_tbl","text":"Setting data table agent informant set_tbl() replaces associated table (data frame, tibble, objects class tbl_dbi tbl_spark). data table associated agent informant tbl argument object table-prep formula (settable create_agent() create_informant()'s read_fn argument set_read_fn()), table-prep formula take precedence. undesirable, removed remove_read_fn() function. association table can removed remove_tbl().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/set_tbl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Establecer una tabla de datos para un agent o informant — set_tbl","text":"","code":"set_tbl(x, tbl)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/set_tbl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Establecer una tabla de datos para un agent o informant — set_tbl","text":"x Un objeto agent de la clase ptblank_agent, o, un objeto informant de clase ptblank_informant. tbl input table agent. can data frame, tibble, tbl_dbi object, tbl_spark object. table already associated agent informant overwritten.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/set_tbl.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Establecer una tabla de datos para un agent o informant — set_tbl","text":"9-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/set_tbl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Establecer una tabla de datos para un agent o informant — set_tbl","text":"","code":"# Establecer umbrales de fallo # proporcionales a los estados # `warn`, `stop` y `notify` # utilizando `action_levels()` al <-    action_levels(       warn_at = 0.10,       stop_at = 0.25,     notify_at = 0.35   )  # Crear un objeto agente que # lea en `small_table` con una # fórmula de preparación de tabla; # aplicar las acciones, añadir # algunos pasos de validación y # luego interrogar los datos agent_1 <-    create_agent(     tbl = small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\",     actions = al   ) %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b), \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   interrogate()    # Replace the agent's association to # `small_table` with a mutated version # of it (one that removes duplicate rows); # then, interrogate the new target table agent_2 <-   agent_1 %>%   set_tbl(     tbl = small_table %>% dplyr::distinct()   ) %>%   interrogate()"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/small_table.html","id":null,"dir":"Reference","previous_headings":"","what":"Una pequeña tabla que es útil para realizar pruebas — small_table","title":"Una pequeña tabla que es útil para realizar pruebas — small_table","text":"Esta es una pequeña tabla con algunos tipos diferentes de columnas. Probablemente sea útil cuando se prueban las funciones desde pointblank. Las filas 9 y 10 son duplicados exactos. La columna c contiene dos valores NA.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/small_table.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Una pequeña tabla que es útil para realizar pruebas — small_table","text":"","code":"small_table"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/small_table.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Una pequeña tabla que es útil para realizar pruebas — small_table","text":"Un tibble con 13 filas y 8 variables: date_time Una columna de fecha y hora (de la clase POSIXct) con fechas que corresponden exactamente las de la columna date. Los valores de tiempo son algo aleatorios, pero todos los valores de 'segundos' son 00. date Una columna Date con fechas desde 2016-01-04 2016-01-30. Una columna integer con valores comprendidos entre 1 y 8. b Una columna de character con valores que se adhieren un patrón común. c Una columna integer con valores comprendidos entre 2 y 9. Contiene dos valores NA. d Una columna numérica con valores que van desde 108 10000. e Una columna logical. f Una columna character con valores \"low\", \"mid\" y \"high\"","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/small_table.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Una pequeña tabla que es útil para realizar pruebas — small_table","text":"14-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/small_table.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Una pequeña tabla que es útil para realizar pruebas — small_table","text":"","code":"# Aquí hay un vistazo a los datos # disponibles en `small_table` dplyr::glimpse(small_table) #> Rows: 13 #> Columns: 8 #> $ date_time <dttm> 2016-01-04 11:00:00, 2016-01-04 00:32:00, 2016-01-05 13:32:… #> $ date      <date> 2016-01-04, 2016-01-04, 2016-01-05, 2016-01-06, 2016-01-09,… #> $ a         <int> 2, 3, 6, 2, 8, 4, 7, 4, 3, 3, 4, 2, 1 #> $ b         <chr> \"1-bcd-345\", \"5-egh-163\", \"8-kdg-938\", \"5-jdo-903\", \"3-ldm-0… #> $ c         <dbl> 3, 8, 3, NA, 7, 4, 3, 2, 9, 9, 7, 8, NA #> $ d         <dbl> 3423.29, 9999.99, 2343.23, 3892.40, 283.94, 3291.03, 843.34,… #> $ e         <lgl> TRUE, TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, FALSE, FALSE, FAL… #> $ f         <chr> \"high\", \"low\", \"high\", \"mid\", \"low\", \"mid\", \"high\", \"low\", \"…"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/small_table_sqlite.html","id":null,"dir":"Reference","previous_headings":"","what":"Una versión SQLite del conjunto de datos small_table — small_table_sqlite","title":"Una versión SQLite del conjunto de datos small_table — small_table_sqlite","text":"La función small_table_sqlite() crea una versión SQLite, tbl_dbi de la tabla small_table. Un requisito es la disponibilidad de los paquetes DBI y RSQLite. Estos paquetes se pueden instalar con install.packages(\"DBI\") y install.packages(\"RSQLite\").","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/small_table_sqlite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Una versión SQLite del conjunto de datos small_table — small_table_sqlite","text":"","code":"small_table_sqlite()"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/small_table_sqlite.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Una versión SQLite del conjunto de datos small_table — small_table_sqlite","text":"14-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/small_table_sqlite.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Una versión SQLite del conjunto de datos small_table — small_table_sqlite","text":"","code":"# Utilice `small_table_sqlite()` # para crear una versión SQLite # de la tabla de la tabla # `small_table` # small_table_sqlite <- small_table_sqlite()"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_highest.html","id":null,"dir":"Reference","previous_headings":"","what":"Un fn para info_snippet(): obtiene el valor más alto de una columna — snip_highest","title":"Un fn para info_snippet(): obtiene el valor más alto de una columna — snip_highest","text":"La función snip_highest() puede utilizarse como una función info_snippet() (es decir, proporcionada fn) para obtener el mayor valor numérico, temporal o valor alfabético de una columna de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_highest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Un fn para info_snippet(): obtiene el valor más alto de una columna — snip_highest","text":"","code":"snip_highest(column)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_highest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Un fn para info_snippet(): obtiene el valor más alto de una columna — snip_highest","text":"column El nombre de la columna que contiene los valores de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_highest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Un fn para info_snippet(): obtiene el valor más alto de una columna — snip_highest","text":"Una fórmula necesaria para el argumento fn de info_snippet().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_highest.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Un fn para info_snippet(): obtiene el valor más alto de una columna — snip_highest","text":"3-9","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_highest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Un fn para info_snippet(): obtiene el valor más alto de una columna — snip_highest","text":"","code":"# Generate an informant object, add # a snippet with `info_snippet()` # and `snip_highest()` (giving us a # method to get the highest value in # column `a`); define a location for # the snippet result in `{ }` and # then `incorporate()` the snippet # into the info text informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\"   ) %>%    info_columns(     columns = \"a\",     `Highest Value` = \"Highest value is {highest_a}.\"   ) %>%   info_snippet(     snippet_name = \"highest_a\",     fn = snip_highest(column = \"a\")   ) %>%   incorporate() #>  #> ── Incorporation Started - there is a single snippet to process ──────────────── #> ✔ Information gathered. #> ✔ Snippets processed. #> ✔ Information built. #>  #> ── Incorporation Completed ─────────────────────────────────────────────────────  # We can print the `informant` object # to see the information report"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Un fn para info_snippet(): obtener una lista de categorías de columnas — snip_list","title":"Un fn para info_snippet(): obtener una lista de categorías de columnas — snip_list","text":"snip_list() function can used info_snippet() function (.e., provided fn) get catalog list table column. can limit items list limit value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Un fn para info_snippet(): obtener una lista de categorías de columnas — snip_list","text":"","code":"snip_list(   column,   limit = 5,   sorting = c(\"inorder\", \"infreq\", \"inseq\"),   reverse = FALSE,   sep = \",\",   and_or = NULL,   oxford = TRUE,   as_code = TRUE,   quot_str = NULL,   lang = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Un fn para info_snippet(): obtener una lista de categorías de columnas — snip_list","text":"column El nombre de la columna que contiene los valores de destino. limit limit items put generated list. returned text state remaining number items beyond limit. default, limit 5. sorting keyword used designate type sorting use list. three options \"inorder\" (default), \"infreq\", \"inseq\". \"inorder\", distinct items listed order firsts appear. Using \"infreq\" orders items decreasing frequency item. \"inseq\" option applies alphanumeric sorting distinct list items. reverse option reverse ordering list items. default, FALSE using TRUE reverse items applying limit. sep separator use list items. default, comma. and_or type conjunction use final penultimate list items (item length limit value). NULL (default) used, '' conjunction used. Alternatively, following keywords can used: \"\", \"\", empty string (conjunction ). oxford Whether use Oxford comma certain conditions. default, TRUE. as_code list item appear 'code font' (.e., monospaced text)? default TRUE. Using FALSE keeps list items font rest information report. quot_str option whether list items set double quotes. NULL (default), quotation marks mainly associated list items derived character factor values; numbers, dates, logical values quotation marks. can explicitly use quotations () either TRUE FALSE . lang language use joining words (and_or option) additional words generated list string. default, NULL use whichever lang setting available parent informant object (settable create_informant() lang argument). specified override, language options English (\"en\"), French (\"fr\"), German (\"de\"), Italian (\"\"), Spanish (\"es\"), Portuguese (\"pt\"), Turkish (\"tr\"), Chinese (\"zh\"), Russian (\"ru\"), Polish (\"pl\"), Danish (\"da\"), Swedish (\"sv\"), Dutch (\"nl\").","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Un fn para info_snippet(): obtener una lista de categorías de columnas — snip_list","text":"Una fórmula necesaria para el argumento fn de info_snippet().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_list.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Un fn para info_snippet(): obtener una lista de categorías de columnas — snip_list","text":"3-6","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Un fn para info_snippet(): obtener una lista de categorías de columnas — snip_list","text":"","code":"# Generate an informant object, add # a snippet with `info_snippet()` # and `snip_list()` (giving us a # method to get a distinct list of # column values for column `f`); # define a location for the snippet # result in `{ }` and then # `incorporate()` the snippet into # the info text informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\"   ) %>%    info_columns(     columns = \"f\",     `Items` = \"This column contains {values_f}.\"   ) %>%   info_snippet(     snippet_name = \"values_f\",     fn = snip_list(column = \"f\")   ) %>%   incorporate() #>  #> ── Incorporation Started - there is a single snippet to process ──────────────── #> ✔ Information gathered. #> ✔ Snippets processed. #> ✔ Information built. #>  #> ── Incorporation Completed ─────────────────────────────────────────────────────  # We can print the `informant` object # to see the information report"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_lowest.html","id":null,"dir":"Reference","previous_headings":"","what":"Un fn para info_snippet(): obtener el valor más bajo de una columna — snip_lowest","title":"Un fn para info_snippet(): obtener el valor más bajo de una columna — snip_lowest","text":"snip_lowest() function can used info_snippet() function (.e., provided fn) get lowest numerical, time value, alphabetical value column target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_lowest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Un fn para info_snippet(): obtener el valor más bajo de una columna — snip_lowest","text":"","code":"snip_lowest(column)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_lowest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Un fn para info_snippet(): obtener el valor más bajo de una columna — snip_lowest","text":"column El nombre de la columna que contiene los valores de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_lowest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Un fn para info_snippet(): obtener el valor más bajo de una columna — snip_lowest","text":"Una fórmula necesaria para el argumento fn de info_snippet().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_lowest.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Un fn para info_snippet(): obtener el valor más bajo de una columna — snip_lowest","text":"3-8","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_lowest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Un fn para info_snippet(): obtener el valor más bajo de una columna — snip_lowest","text":"","code":"# Generate an informant object, add # a snippet with `info_snippet()` # and `snip_lowest()` (giving us a # method to get the lowest value in # column `a`); define a location for # the snippet result in `{ }` and # then `incorporate()` the snippet # into the info text informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\"   ) %>%    info_columns(     columns = \"a\",     `Lowest Value` = \"Lowest value is {lowest_a}.\"   ) %>%   info_snippet(     snippet_name = \"lowest_a\",     fn = snip_lowest(column = \"a\")   ) %>%   incorporate() #>  #> ── Incorporation Started - there is a single snippet to process ──────────────── #> ✔ Information gathered. #> ✔ Snippets processed. #> ✔ Information built. #>  #> ── Incorporation Completed ─────────────────────────────────────────────────────  # We can print the `informant` object # to see the information report"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_stats.html","id":null,"dir":"Reference","previous_headings":"","what":"Un fn para info_snippet(): obtener un resumen estadístico en línea — snip_stats","title":"Un fn para info_snippet(): obtener un resumen estadístico en línea — snip_stats","text":"snip_stats() function can used info_snippet() function (.e., provided fn) produce five- seven-number statistical summary. inline summary works well within paragraph text can help describing distribution numerical values column. given column, three different types inline statistical summaries can provided: five-number summary (\"5num\"): minimum, Q1, median, Q3, maximum seven-number summary (\"7num\"): P2, P9, Q1, median, Q3, P91, P98 Bowley's seven-figure summary (\"bowley\"): minimum, P10, Q1, median, Q3, P90, maximum","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_stats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Un fn para info_snippet(): obtener un resumen estadístico en línea — snip_stats","text":"","code":"snip_stats(column, type = c(\"5num\", \"7num\", \"bowley\"))"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_stats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Un fn para info_snippet(): obtener un resumen estadístico en línea — snip_stats","text":"column El nombre de la columna que contiene los valores de destino. type type summary. default, \"5num\" keyword used generate five-number summary. Two options provide seven-number summaries: \"7num\" \"bowley\".","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_stats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Un fn para info_snippet(): obtener un resumen estadístico en línea — snip_stats","text":"Una fórmula necesaria para el argumento fn de info_snippet().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_stats.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Un fn para info_snippet(): obtener un resumen estadístico en línea — snip_stats","text":"3-7","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_stats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Un fn para info_snippet(): obtener un resumen estadístico en línea — snip_stats","text":"","code":"# Generate an informant object, add # a snippet with `info_snippet()` # and `snip_stats()` (giving us a # method to get some summary stats for # column `a`); define a location for # the snippet result in `{ }` and # then `incorporate()` the snippet # into the info text informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\"   ) %>%    info_columns(     columns = \"a\",     `Stats` = \"Stats (fivenum): {stats_a}.\"   ) %>%   info_snippet(     snippet_name = \"stats_a\",     fn = snip_stats(column = \"a\")   ) %>%   incorporate() #>  #> ── Incorporation Started - there is a single snippet to process ──────────────── #> ✔ Information gathered. #> ✔ Snippets processed. #> ✔ Information built. #>  #> ── Incorporation Completed ─────────────────────────────────────────────────────  # We can print the `informant` object # to see the information report"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specially.html","id":null,"dir":"Reference","previous_headings":"","what":"Realizar una validación especializada con una función definida por el usuario — specially","title":"Realizar una validación especializada con una función definida por el usuario — specially","text":"La función de validación specially() permite una validación personalizada con una función que usted proporciona. La principal condición para la función proporcionada es que debe devolver un vector lógico o una tabla donde la columna final sea lógica. La función operará sobre el objeto tabla o, como puede hacer lo que quiera, también podría operar sobre otros tipos de objetos. Para ello, puede transformar la tabla de entrada en preconditions o inyectar allí un objeto totalmente diferente. Durante la interrogación, habrá ninguna comprobación para asegurar que los datos son un objeto de tabla.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specially.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Realizar una validación especializada con una función definida por el usuario — specially","text":"","code":"specially(   x,   fn,   preconditions = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_specially(object, fn, preconditions = NULL, threshold = 1)  test_specially(object, fn, preconditions = NULL, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specially.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Realizar una validación especializada con una función definida por el usuario — specially","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). fn Una función que realiza la validación especializada de los datos. Debe devolver un vector lógico o una tabla donde la última columna es una columna lógica. preconditions Una expresión opcional para mutar la tabla de entrada antes de continuar con la validación. Esto se puede proporcionar como una fórmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una función (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la sección Preconditions para obtener más información. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specially.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Realizar una validación especializada con una función definida por el usuario — specially","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specially.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Realizar una validación especializada con una función definida por el usuario — specially","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesará la tabla de destino durante la interrogación como paso preparatorio. Puede suceder que una validación en particular requiera una columna calculada, algún filtrado de filas o la adición de columnas través de una combinación, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validación con una sola tabla de destino y realice ajustes menores en ella, según sea necesario, lo largo del camino. Dentro de specially(), debido que esta función es especial, habrá comprobación interna de si la salida basada en preconditions es una tabla. La mutación de la tabla está totalmente aislada en el alcance de los pasos de validación en los que se utilizan las preconditions. Aquí se sugiere usar el código dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El código se proporciona más fácilmente como una fórmula R unilateral (utilizando un ~ inicial). En la representación de la fórmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podría proporcionar una función (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specially.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Realizar una validación especializada con una función definida por el usuario — specially","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que es mejor producido por la función action_levels(). Lea la documentación de esa función para obtener información sobre cómo crear reacciones niveles de falla por encima del umbral en la validación. La esencia básica es que querrá al menos un nivel de umbral único (especificado como la fracción de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situación (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop()s en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specially.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Realizar una validación especializada con una función definida por el usuario — specially","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specially.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Realizar una validación especializada con una función definida por el usuario — specially","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando specially() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de specially() como paso de validación se expresa en código R y en la representación YAML correspondiente. En la práctica, ambos serán menudo más cortos, ya que solo son necesarias las expresiones para los pasos de validación. Los argumentos con valores predeterminados se escribirán en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). También es posible obtener una vista previa de la transformación de un agente YAML sin escribir en el disco usando la función yaml_agent_string().","code":"# Código R agent %>%    specially(     fn = function(x) { ... },     preconditions = ~ . %>% dplyr::filter(a < 10),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),      label = \"El paso `specially()`.\",     active = FALSE   )  # Representación YAML steps: - specially:     fn: function(x) { ... }     preconditions: ~. %>% dplyr::filter(a < 10)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `specially()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specially.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Realizar una validación especializada con una función definida por el usuario — specially","text":"2-33","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specifications.html","id":null,"dir":"Reference","previous_headings":"","what":"Una tabla que contiene datos pertenecientes a varias especificaciones — specifications","title":"Una tabla que contiene datos pertenecientes a varias especificaciones — specifications","text":"La tabla specifications es útil para probar las funciones col_vals_within_spec(), test_col_vals_within_spec() y expect_col_vals_within_spec(). Para cada columna, que contiene valores de caracteres para diferentes especificaciones, las filas 1-5 contienen valores válidos, la 6ª fila es un valor NA, y los dos últimos valores (filas 7 y 8) son inválidos. Las diferentes palabras clave de especificación (spec) se aplican cada una de las columnas cuando al validar con cualquiera de las funciones mencionadas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specifications.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Una tabla que contiene datos pertenecientes a varias especificaciones — specifications","text":"","code":"specifications"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specifications.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Una tabla que contiene datos pertenecientes a varias especificaciones — specifications","text":"tibble 8 rows 12 variables: isbn_numbers ISBN-13 numbers; can validated \"isbn\" specification. vin_numbers VIN numbers (identifiers motor vehicles); can validated \"vin\" specification. zip_codes Postal codes U.S.; can validated \"postal[USA]\" specification \"zip\" alias. credit_card_numbers Credit card numbers; can validated \"credit_card\" specification \"cc\" alias. iban_austria IBAN numbers Austrian accounts; can validated \"iban[AUT]\" specification. swift_numbers Swift-BIC numbers; can validated \"swift\" specification. phone_numbers Phone numbers; can validated \"phone\" specification. email_addresses Email addresses; can validated \"email\" specification. urls URLs; can validated  \"url\" specification. ipv4_addresses IPv4 addresses; can validated \"ipv4\" specification ipv6_addresses IPv6 addresses; can validated \"ipv6\" specification mac_addresses MAC addresses; can validated \"mac\" specification","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specifications.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Una tabla que contiene datos pertenecientes a varias especificaciones — specifications","text":"14-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specifications.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Una tabla que contiene datos pertenecientes a varias especificaciones — specifications","text":"","code":"# He aquí un vistazo a los datos # disponibles en `specifications` dplyr::glimpse(specifications) #> Rows: 8 #> Columns: 12 #> $ isbn_numbers        <chr> \"978 1 85715 201 2\", \"978-1-84159-362-3\", \"978 1 8… #> $ vin_numbers         <chr> \"4UZAANDH85CV12329\", \"JM1BL1S59A1134659\", \"1GCEK14… #> $ zip_codes           <chr> \"99553\", \"36264\", \"71660\", \"85225\", \"90309\", NA, \"… #> $ credit_card_numbers <chr> \"340000000000009\", \"378734493671000\", \"67034444444… #> $ iban_austria        <chr> \"AT582774098454337653\", \"AT220332087576467472\", \"A… #> $ swift_numbers       <chr> \"RBOSGGSX\", \"RZTIAT22263\", \"BCEELULL\", \"MARKDEFF\",… #> $ phone_numbers       <chr> \"+5-555-555-5555\", \"+5 555 555 5555\", \"+5.555.555.… #> $ email_addresses     <chr> \"test@test.com\", \"mail+mail@example.com\", \"mail.em… #> $ urls                <chr> \"http://foo.com/blah_blah\", \"http://foo.com/blah_b… #> $ ipv4_addresses      <chr> \"93.184.220.20\", \"161.148.172.130\", \"161.148.172.1… #> $ ipv6_addresses      <chr> \"2001:0db8:0000:85a3:0000:0000:ac1f:8001\", \"2001:d… #> $ mac_addresses       <chr> \"01-2d-4c-ef-89-ab\", \"01-2D-4C-EF-89-AB\", \"01:2d:4…"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stock_msg_body.html","id":null,"dir":"Reference","previous_headings":"","what":"Proporcione componentes simples del cuerpo del mensaje de correo electrónico:\n","title":"Proporcione componentes simples del cuerpo del mensaje de correo electrónico:\n","text":"La función stock_msg_body() simplemente proporciona un texto de stock para un mensaje de correo electrónico enviado través de email_blast() u obtenido como un objeto independiente través de email_create().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stock_msg_body.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Proporcione componentes simples del cuerpo del mensaje de correo electrónico:\n","text":"","code":"stock_msg_body()"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stock_msg_body.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Proporcione componentes simples del cuerpo del mensaje de correo electrónico:\n","text":"Texto adecuado para el argumento msg_body de email_blast() y email_create().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stock_msg_body.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Proporcione componentes simples del cuerpo del mensaje de correo electrónico:\n","text":"4-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stock_msg_footer.html","id":null,"dir":"Reference","previous_headings":"","what":"Proporcione componentes simples del cuerpo del mensaje de correo electrónico:\n","title":"Proporcione componentes simples del cuerpo del mensaje de correo electrónico:\n","text":"La función stock_msg_footer() simplemente proporciona un texto de stock para un mensaje de correo electrónico enviado través de email_blast() u obtenido como un objeto independiente través de email_create().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stock_msg_footer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Proporcione componentes simples del cuerpo del mensaje de correo electrónico:\n","text":"","code":"stock_msg_footer()"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stock_msg_footer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Proporcione componentes simples del cuerpo del mensaje de correo electrónico:\n","text":"Texto adecuado para el argumento msg_footer de email_blast() y email_create().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stock_msg_footer.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Proporcione componentes simples del cuerpo del mensaje de correo electrónico:\n","text":"4-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stop_if_not.html","id":null,"dir":"Reference","previous_headings":"","what":"La próxima generación de funciones de tipo stopifnot(): stop_if_not() — stop_if_not","title":"La próxima generación de funciones de tipo stopifnot(): stop_if_not() — stop_if_not","text":"stopifnot() twist: works well standalone, replacement stopifnot() also customized use validation checks R Markdown documents pointblank loaded. Using stop_if_not() code chunk validate = TRUE option set yield correct reporting successes failures whereas stopifnot() .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stop_if_not.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"La próxima generación de funciones de tipo stopifnot(): stop_if_not() — stop_if_not","text":"","code":"stop_if_not(...)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stop_if_not.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"La próxima generación de funciones de tipo stopifnot(): stop_if_not() — stop_if_not","text":"... R expressions evaluate (logical vector ) TRUE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stop_if_not.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"La próxima generación de funciones de tipo stopifnot(): stop_if_not() — stop_if_not","text":"NULL statements ... TRUE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stop_if_not.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"La próxima generación de funciones de tipo stopifnot(): stop_if_not() — stop_if_not","text":"13-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stop_if_not.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"La próxima generación de funciones de tipo stopifnot(): stop_if_not() — stop_if_not","text":"","code":"# This checks whether the number of # rows in `small_table` is greater # than `10` stop_if_not(nrow(small_table) > 10) #> NULL  # This will stop for sure: there # isn't a `time` column in `small_table` # (but there are the `date_time` and # `date` columns) # stop_if_not(\"time\" %in% colnames(small_table))  # You're not bound to using tabular # data here, any statements that # evaluate to logical vectors will work stop_if_not(1 < 20:25 - 18) #> NULL"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_get.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtenga una mesa materializada a través de una tienda de mesa — tbl_get","title":"Obtenga una mesa materializada a través de una tienda de mesa — tbl_get","text":"tbl_get() function gives us means materialize table entry table store (.e., table-prep formula unique name). table store used can form tbl_store object (created tbl_store() function) -disk YAML representation table store (created using yaml_write() tbl_store object). want table-prep formula table store use value read_fn (create_agent(), create_informant(), set_read_fn()), look tbl_source() function.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_get.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtenga una mesa materializada a través de una tienda de mesa — tbl_get","text":"","code":"tbl_get(tbl, store = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_get.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtenga una mesa materializada a través de una tienda de mesa — tbl_get","text":"tbl table retrieve table store. table identified name (e.g., tbl = \"large_table\") supplying reference using subset ($) tbl_store object (e.g., tbl = store$large_table). using latter method nothing needs supplied store. store Either table store object created tbl_store() function path table store YAML file created yaml_write().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_get.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtenga una mesa materializada a través de una tienda de mesa — tbl_get","text":"table object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_get.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Obtenga una mesa materializada a través de una tienda de mesa — tbl_get","text":"1-10","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_get.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtenga una mesa materializada a través de una tienda de mesa — tbl_get","text":"","code":"if (interactive()) {  # Define a `tbl_store` object by adding # table-prep formulas in `tbl_store()` tbls <-    tbl_store(     small_table_duck ~ db_tbl(       table = small_table,       dbname = \":memory:\",       dbtype = \"duckdb\"     ),     ~ db_tbl(       table = \"rna\",       dbname = \"pfmegrnargs\",       dbtype = \"postgres\",       host = \"hh-pgsql-public.ebi.ac.uk\",       port = 5432,       user = I(\"reader\"),       password = I(\"NWDMCE5xdipIjRrp\")     ),     all_revenue ~ db_tbl(       table = file_tbl(         file = from_github(           file = \"all_revenue_large.rds\",           repo = \"rich-iannone/intendo\",           subdir = \"data-large\"         )       ),       dbname = \":memory:\",       dbtype = \"duckdb\"     ),     sml_table ~ pointblank::small_table   )  # Once this object is available, you can # check that the table of interest is # produced to your specification tbl_get(   tbl = \"small_table_duck\",   store = tbls )  # An alternative method for getting the # same table materialized is by using `$` # to get the formula of choice from `tbls` tbls$small_table_duck %>% tbl_get()  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_match.html","id":null,"dir":"Reference","previous_headings":"","what":"¿La tabla de destino coincide con una tabla de comparación? — tbl_match","title":"¿La tabla de destino coincide con una tabla de comparación? — tbl_match","text":"La función de validación tbl_match(), la función de expectativa expect_tbl_match() y la función de prueba test_tbl_match() comprueban si la composición de la tabla de destino coincide con la de una tabla de comparación. La función de validación se puede usar directamente en una tabla de datos o con un objeto agent (técnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Como paso de validación o como expectativa, hay una sola unidad de prueba que depende de si las dos tablas son las son iguales (después de haber aplicado cualquier preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_match.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¿La tabla de destino coincide con una tabla de comparación? — tbl_match","text":"","code":"tbl_match(   x,   tbl_compare,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_tbl_match(object, tbl_compare, preconditions = NULL, threshold = 1)  test_tbl_match(object, tbl_compare, preconditions = NULL, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_match.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¿La tabla de destino coincide con una tabla de comparación? — tbl_match","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). tbl_compare Una tabla para comparar con la tabla de destino. Esto puede ser un objeto de tabla, una fórmula de preparación de tabla. Puede ser un objeto de tabla como un marco de datos, un tibble, un objeto tbl_dbi o un objeto tbl_spark. Como alternativa, se puede utilizar una fórmula de preparación de tabla (~ <código de lectura de tabla>) o una función (function() <código de lectura de tabla>) para leer perezosamente la tabla en el momento de la interrogación. preconditions Una expresión opcional para mutar la tabla de entrada antes de continuar con la validación. Esto se puede proporcionar como una fórmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una función (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la sección Preconditions para obtener más información. segments Una expresión opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la sección Segments para obtener más detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validación pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se creará con la función auxiliar action_levels(). step_id Uno o más identificadores opcionales para los pasos de validación únicos o múltiples generados al llamar una función de validación. El uso de ID de pasos sirve para distinguir los pasos de validación entre sí y brinda la oportunidad de proporcionar una etiqueta más significativa en comparación con el índice de pasos. De forma predeterminada, es NULL, y pointblank generará automáticamente el valor de ID de paso (basado en el índice de paso) en este caso. Se pueden proporcionar uno o más valores, y el número exacto de valores de ID debe (1) coincidir con el número de pasos de validación que producirá la llamada la función de validación (influenciado por el número de columns proporcionadas), (2) ser un ID cadena utilizada en ningún paso de validación anterior, y (3) ser un vector con valores únicos. label Una etiqueta opcional para el paso de validación. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripción opcional basada en texto para el paso de validación. Si se proporciona nada aquí, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o inglés). El autobrief incorpora detalles del paso de validación, por lo que menudo es la opción preferida en la mayoría de los casos (donde un label podría ser más adecuada para describir sucintamente la validación). active Un valor lógico que indica si el paso de validación debe estar activo. Si la función de validación está trabajando con un objeto agent, FALSE hará que el paso de validación esté inactivo (aún informando su presencia y manteniendo los índices de los pasos sin cambios). Si la función de validación operará directamente en los datos (sin participación de agent), entonces cualquier paso con active = FALSE simplemente pasará los datos sin validación alguna. Aparte de un vector lógico, una fórmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor lógico. Con este enfoque, la función pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validación sobre la base de una o más columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la función de expectativa o la función de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de función expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validación de datos da como resultado una falla general de la prueba. Los números enteros más allá de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como resultado una thatthat prueba o evalúe como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) actúan como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_match.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¿La tabla de destino coincide con una tabla de comparación? — tbl_match","text":"Para la función de validación, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pasó un objeto agent o una tabla x). La función de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la función se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de señalización). La función de prueba devuelve un valor lógico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_match.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¿La tabla de destino coincide con una tabla de comparación? — tbl_match","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesará la tabla de destino durante la interrogación como paso preparatorio. Puede suceder que esta validación en particular requiera alguna operación en la tabla de destino antes de que se lleve cabo la comparación. El uso de preconditions puede ser útil en ocasiones, ya que podemos desarrollar un gran plan de validación con una sola tabla de destino y realizarle pequeños ajustes, según sea necesario, lo largo del camino. La mutación de la tabla está totalmente aislada en el alcance de los pasos de validación en los que se utilizan las preconditions. Aquí se sugiere usar el código dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El código se proporciona más fácilmente como una fórmula R unilateral (utilizando un ~ inicial). En la representación de la fórmula, el . sirve como la tabla de datos de entrada que se va transformar. Como alternativa, se puede suministrar una función.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_match.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¿La tabla de destino coincide con una tabla de comparación? — tbl_match","text":"Al usar el argumento segments, es posible definir una validación particular con segmentos (o porciones de fila) de la tabla de destino. Una expresión opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresión se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresión que se puede utilizar, vars(a_column) segmentará la tabla de destino en la forma en que estén presentes muchos valores únicos en la columna llamada a_column. Esto es excelente si cada valor único en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validación repetida. Con una fórmula, podemos ser más selectivos con los valores de columna que se deben usar para la segmentación. El uso de a_column ~ c(\"group_1\", \"group_2\") intentará obtener dos segmentos donde uno es una porción de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la fórmula dará como resultado un paso de validación independiente. La segmentación siempre ocurrirá después de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinación, es posible generar etiquetas para la segmentación usando una expresión para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versión separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_match.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¿La tabla de destino coincide con una tabla de comparación? — tbl_match","text":"menudo, querremos especificar actions para la validación. Este argumento, presente en cada función de validación, toma un objeto de lista especialmente diseñado que se produce mejor con la función action_levels(). Lee esa función documentación para la verdad sobre cómo crear reacciones por encima del umbral niveles de falla en la validación. La esencia básica es que querrás al menos un nivel de umbral único (especificado como la fracción de unidades de prueba falló, o un valor absoluto), menudo usando el argumento warn_at. Utilizando action_levels(warn_at = 1) o action_levels(stop_at = 1) son buenas opciones dependiendo de la situación (el primero produce una advertencia, el otro stop()).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_match.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¿La tabla de destino coincide con una tabla de comparación? — tbl_match","text":"¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta que esto sólo es útil si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situación. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generará automáticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_match.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¿La tabla de destino coincide con una tabla de comparación? — tbl_match","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (través de yaml_agent_interrogate()). Cuando tbl_match() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la función de validación. continuación se muestra un ejemplo de cómo una llamada compleja de tbl_match() como paso de validación se expresa en código R y en la representación YAML correspondiente. En la práctica, ambos serán menudo más cortos. Los argumentos con valores por defecto se escribirán en YAML cuando se utilice yaml_write() (aunque es aceptable incluirlos con su valor por defecto al generar el YAML por otros medios). También es posible previsualizar la transformación de un agente YAML sin necesidad de escribirlo en el disco, utilizando la función yaml_agent_string().","code":"# Código R agent %>%    tbl_match(     tbl_compare = ~ file_tbl(       file = from_github(         file = \"all_revenue_large.rds\",         repo = \"rich-iannone/intendo\",         subdir = \"data-large\"         )       ),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `tbl_match()`.\",     active = FALSE   )  # Representación YAML steps: - tbl_match:     tbl_compare: ~ file_tbl(       file = from_github(         file = \"all_revenue_large.rds\",         repo = \"rich-iannone/intendo\",         subdir = \"data-large\"         )       )     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `tbl_match()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_match.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¿La tabla de destino coincide con una tabla de comparación? — tbl_match","text":"2-32","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_match.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¿La tabla de destino coincide con una tabla de comparación? — tbl_match","text":"","code":"# Cree una tabla simple con tres # columnas y cuatro filas de valores tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5),     b = c(7, 1, 0, 0),     c = c(1, 1, 1, 3)   )  # Crear una segunda tabla que sea # igual a `tbl`. tbl_2 <-   dplyr::tibble(     a = c(5, 7, 6, 5),     b = c(7, 1, 0, 0),     c = c(1, 1, 1, 3)   )  # Validar que la tabla de destino # (`tbl`) y la tabla de comparación # (`tbl_2`) son equivalentes en # términos de contenido agent <-   create_agent(tbl = tbl) %>%   tbl_match(tbl_compare = tbl_2) %>%   interrogate()  # Determine si esta validación # pasó usando `all_passed()` all_passed(agent) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_source.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtenga una fórmula de preparación de mesa en una tienda de mesa — tbl_source","title":"Obtenga una fórmula de preparación de mesa en una tienda de mesa — tbl_source","text":"La función tbl_source() proporciona un medio conveniente para acceder una fórmula de preparación de tablas desde un objeto tbl_store o un archivo YAML de almacenamiento de tablas (que puede ser creado con la función yaml_write()). Una llamada tbl_source() es más útil como entrada al argumento read_fn de create_agent(), create_informant(), o set_read_fn(). Si necesita obtener la tabla propiamente dicha (que se genera través de la fórmula fórmula de preparación de la tabla), se debe utilizar la función tbl_get() para ello.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_source.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtenga una fórmula de preparación de mesa en una tienda de mesa — tbl_source","text":"","code":"tbl_source(tbl, store = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_source.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtenga una fórmula de preparación de mesa en una tienda de mesa — tbl_source","text":"tbl El nombre de la tabla asociado una fórmula de preparación de la tabla. Forma parte de la tabla store. Esta tabla puede identificarse por su nombre (por ejemplo, tbl = \"large_table\") o proporcionando una referencia utilizando un subconjunto (con $) del objeto tbl_store (por ejemplo, tbl = store$large_table). Si se utiliza este último método, es necesario suministrar nada store. store O bien un objeto de almacén de tablas creado por la función tbl_store() o una ruta un archivo YAML del almacén de tablas creado por yaml_write().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_source.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtenga una fórmula de preparación de mesa en una tienda de mesa — tbl_source","text":"Una fórmula de preparación de la tabla.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_source.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Obtenga una fórmula de preparación de mesa en una tienda de mesa — tbl_source","text":"1-9","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_source.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtenga una fórmula de preparación de mesa en una tienda de mesa — tbl_source","text":"","code":"if (interactive()) {  # Vamos a crear un objeto `tbl_store` # dándole dos fórmulas de preparación # de la tabla a `tbl_store()` tbls <-    tbl_store(     small_table_duck ~ db_tbl(       table = small_table,       dbname = \":memory:\",       dbtype = \"duckdb\"     ),     sml_table ~ pointblank::small_table   )  # Podemos pasar una fórmula de # preparación de la tabla a # `create_agent()` e interrogar la # tabla poco después agent <-    create_agent(     read_fn = ~ tbl_source(\"sml_table\", tbls),     label = \"An example that uses a table store.\",     actions = action_levels(warn_at = 0.10)   ) %>%    col_exists(vars(date, date_time)) %>%   interrogate()  # Tanto el objeto `tbl_store` como el # objeto `agent` pueden ser transformados # a YAML con la función `yaml_write()`.  # Esto escribe el archivo `tbl_store.yml` # por defecto (pero un nombre diferente # podría usarse) yaml_write(tbls)  # Modifiquemos el `read_fn` del agente # para que apunte a la representación # YAML del `tbl_store`. agent <-   agent %>%    set_read_fn(     ~ tbl_source(         tbl = \"sml_table\",         store = \"tbl_store.yml\"       )   )  # Entonces podemos escribir el agente # en un archivo YAML (escribe en # `agent-sml_table.yml` por defecto) yaml_write(agent)  # Ahora que ambos están en este # formato en el disco se puede hacer # una interrogación accediendo a el # agente YAML agent <-   yaml_agent_interrogate(     filename = \"agent-sml_table.yml\"   )  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_store.html","id":null,"dir":"Reference","previous_headings":"","what":"Definir un almacén de tablas con fórmulas de preparación de tablas: un ","title":"Definir un almacén de tablas con fórmulas de preparación de tablas: un ","text":"Puede ser útil configurar todas las fuentes de datos que necesites y sólo extraerlas cuando sea necesario. Esta configuración por adelantado con tbl_store() nos permite definir los métodos para obtener datos tabulares de fuentes mixtas (por ejemplo, tablas de bases de datos, tablas generadas partir de archivos planos, etc.) y proporcionar nombres para estos procedimientos de preparación de datos. Entonces tenemos una forma conveniente de acceder las tablas materializadas con tbl_get(), o, las fórmulas de preparación de tablas con tbl_source(). Las fórmulas table-prep pueden ser tan simples como obtener una tabla de una ubicación, o, puede involucrar tanta mutación como sea necesaria (imagine obtener varias variaciones mutadas de la misma tabla fuente, generar una tabla desde múltiples fuentes, o pre-filtrar una tabla de la base de datos de acuerdo al tiempo del sistema). Otro aspecto agradable de organizar las fórmulas de preparación de tablas en un solo objeto es suministrarlo al argumento read_fn de create_agent() o create_informant() mediante la notación $ (por ejemplo, create_agent(read_fn = <tbl_store>$<nombre>)) o con tbl_source() (por ejemplo, create_agent(read_fn = ~ tbl_source(\"<nombre>\", <tbl_store>))).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_store.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Definir un almacén de tablas con fórmulas de preparación de tablas: un ","text":"","code":"tbl_store(..., .list = list2(...))"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_store.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Definir un almacén de tablas con fórmulas de preparación de tablas: un ","text":"... Expresiones que contienen fórmulas de preparación de tablas y nombres de tablas para la recuperación de datos. Deben utilizarse fórmulas de dos lados (por ejemplo, <LHS> ~ <RHS>), donde el lado izquierdo es un nombre dado y el derecho es la parte que se utiliza para obtener la tabla. .list Permite el uso de una lista como alternativa de entrada ....","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_store.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Definir un almacén de tablas con fórmulas de preparación de tablas: un ","text":"Un objeto tbl_store que contiene fórmulas de preparación de tablas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_store.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Definir un almacén de tablas con fórmulas de preparación de tablas: un ","text":"Un pointblank tbl_store se puede escribir en YAML con yaml_write() y el YAML resultante se puede utilizar de varias maneras. El escenario ideal es tener agentes e informantes pointblank también en forma YAML. De esta manera el agente y el informante pueden referirse la tabla de almacenamiento YAML (través de tbl_source()), y, el procesamiento de ambos agentes e informantes puede realizarse con yaml_agent_interrogate() y yaml_informant_incorporate(). Con el siguiente código de R, se genera un almacén de tablas con dos fórmulas de preparación de tablas y se escribe en YAML (si se da un nombre de archivo, el YAML se escribe en \"tbl_store.yml\"). Esto es útil cuando se quiere obtener tiradas frescas de datos preparados de una fuente materializada en una sesión de R (con la función tbl_get(). Por ejemplo, la tabla sml_table_high puede obtenerse utilizando tbl_get(\"sml_table_high\", \"tbl_store.yml\"). Para conseguir que un agente compruebe estos datos preparados periódicamente, será útil el siguiente ejemplo con tbl_source(): Ahora, siempre que la tabla sml_table_high necesite ser validada, se puede hacer con yaml_agent_interrogate() (por ejemplo, yaml_agent_interrogate(\"agent-sml_table_high.yml\")).","code":"# Código R para generar el archivo \"tbl_store.yml\" tbl_store(   tbl_duckdb ~ db_tbl(small_table, dbname = \":memory:\", dbtype = \"duckdb\"),   sml_table_high ~ small_table %>% dplyr::filter(f == \"high\") ) %>%   yaml_write()  # Representación YAML (\"tbl_store.yml\") tbls:   tbl_duckdb: ~ db_tbl(small_table, dbname = \":memory:\", dbtype = \"duckdb\")   sml_table_high: ~ small_table %>% dplyr::filter(f == \"high\") # Generar un objeto agente que compruebe # `sml_table_high`, escribirlo en YAML create_agent(   read_fn = ~ tbl_source(\"sml_table_high\", \"tbl_store.yml\"),   label = \"An example that uses a table store.\",   actions = action_levels(warn_at = 0.10) ) %>%    col_exists(vars(date, date_time)) %>%   write_yaml()    # Representación YAML (\"agent-sml_table_high.yml\") read_fn: ~ tbl_source(\"sml_table_high\", \"tbl_store.yml\") tbl_name: sml_table_high label: An example that uses a table store. actions:   warn_fraction: 0.1 locale: en steps:   - col_exists:     columns: vars(date, date_time)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_store.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Definir un almacén de tablas con fórmulas de preparación de tablas: un ","text":"1-8","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_store.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Definir un almacén de tablas con fórmulas de preparación de tablas: un ","text":"","code":"if (interactive()) {  # Definir un objeto `tbl_store` añadiendo # fórmulas de preparación de tablas # dentro de la `tbl_store()` llamada tbls <-    tbl_store(     small_table_duck ~ db_tbl(       table = small_table,       dbname = \":memory:\",       dbtype = \"duckdb\"     ),     ~ db_tbl(       table = \"rna\",       dbname = \"pfmegrnargs\",       dbtype = \"postgres\",       host = \"hh-pgsql-public.ebi.ac.uk\",       port = 5432,       user = I(\"reader\"),       password = I(\"NWDMCE5xdipIjRrp\")     ),     all_revenue ~ db_tbl(       table = file_tbl(         file = from_github(           file = \"all_revenue_large.rds\",           repo = \"rich-iannone/intendo\",           subdir = \"data-large\"         )       ),       dbname = \":memory:\",       dbtype = \"duckdb\"     ),     sml_table ~ pointblank::small_table   )  # Una vez que este objeto está disponible, # se puede comprobar que la tabla de # interés se produce a su especificación # con la función `tbl_get()`. tbl_get(   tbl = \"small_table_duck\",   store = tbls )  # Otra forma más sencilla de obtener la # misma tabla materializada es utilizando # `$` para obtener la entrada de # elección para `tbl_get()`. tbls$small_table_duck %>% tbl_get()  # La creación de un agente es fácil # cuando todas las fórmulas de # preparación de tablas están # encapsuladas en un objeto `tbl_store`; # utilice la notación `$` para pasar el # procedimiento apropiado para leer una # tabla al argumento `read_fn` agent_1 <-   create_agent(     read_fn = tbls$small_table_duck   )    # Existen otras formas de utilizar el # almacén de tablas para asignar una # tabla de destino a un agente, como # el uso de la función `tbl_source()` agent_2 <-   create_agent(     read_fn = ~ tbl_source(       tbl = \"small_table_duck\",       store = tbls       )   )  # El almacén de tablas puede ser # trasladado a YAML con `yaml_write` # y la llamada `tbl_source()` podría # entonces referirse a ese almacén # de tablas en disco; hagamos esa # conversión a YAML yaml_write(tbls)  # Lo anterior escribe el archivo # `tbl_store.yml` (al no # proporcionar un `filename` se # elige este nombre de archivo por # defecto); a continuación, modifica # el `tbl_source()` para que `store` # haga referencia al archivo YAML  agent_3 <-   create_agent(     read_fn = ~ tbl_source(       tbl = \"small_table_duck\",       store = \"tbl_store.yml\"     )   )  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_string_info.html","id":null,"dir":"Reference","previous_headings":"","what":"Table Transformer: obtenga una tabla de resumen para columnas de cadena — tt_string_info","title":"Table Transformer: obtenga una tabla de resumen para columnas de cadena — tt_string_info","text":"table object, can produce summary table scoped string-based columns. output summary table leading column called \".param.\" labels three rows, corresponding following pieces information pertaining string length: Mean String Length (\"length_mean\") Minimum String Length (\"length_min\") Maximum String Length (\"length_max\") string data input table generate columns output table. Column names input used output, preserving order well.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_string_info.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Table Transformer: obtenga una tabla de resumen para columnas de cadena — tt_string_info","text":"","code":"tt_string_info(tbl)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_string_info.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Table Transformer: obtenga una tabla de resumen para columnas de cadena — tt_string_info","text":"tbl table object used input transformation. can data frame, tibble, tbl_dbi object, tbl_spark object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_string_info.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Table Transformer: obtenga una tabla de resumen para columnas de cadena — tt_string_info","text":"Un objeto tibble.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_string_info.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Table Transformer: obtenga una tabla de resumen para columnas de cadena — tt_string_info","text":"12-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_string_info.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Table Transformer: obtenga una tabla de resumen para columnas de cadena — tt_string_info","text":"","code":"# Get string information for the # string-based columns in the # `game_revenue` dataset tt_string_info(game_revenue) #> # A tibble: 3 × 7 #>   .param.     player_id session_id item_type item_name acquisition country #>   <chr>           <dbl>      <dbl>     <dbl>     <dbl>       <dbl>   <dbl> #> 1 length_mean        15         24      2.22      7.35        7.97    8.53 #> 2 length_min         15         24      2         5           5       5    #> 3 length_max         15         24      3        11          14      14     # Ensure that `player_id` and # `session_id` values always have # the same number of characters # throughout the table tt_string_info(game_revenue) %>%   col_vals_equal(     columns = vars(player_id),     value = 15   ) %>%   col_vals_equal(     columns = vars(session_id),     value = 24   ) #> # A tibble: 3 × 7 #>   .param.     player_id session_id item_type item_name acquisition country #>   <chr>           <dbl>      <dbl>     <dbl>     <dbl>       <dbl>   <dbl> #> 1 length_mean        15         24      2.22      7.35        7.97    8.53 #> 2 length_min         15         24      2         5           5       5    #> 3 length_max         15         24      3        11          14      14     # Check that the maximum string # length in column `f` of the # `small_table` dataset is no # greater than `4` tt_string_info(small_table) %>%   test_col_vals_lte(     columns = vars(f),     value = 4   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_summary_stats.html","id":null,"dir":"Reference","previous_headings":"","what":"Table Transformer: obtener una tabla de estadísticas de resumen para columnas\nnuméricas — tt_summary_stats","title":"Table Transformer: obtener una tabla de estadísticas de resumen para columnas\nnuméricas — tt_summary_stats","text":"table object, can produce summary table scoped numeric column values. output summary table leading column called \".param.\" labels nine rows, corresponding following summary statistics: Minimum (\"min\") 5th Percentile (\"p05\") 1st Quartile (\"q_1\") Median (\"med\") 3rd Quartile (\"q_3\") 95th Percentile (\"p95\") Maximum (\"max\") Interquartile Range (\"iqr\") Range (\"range\") numerical data input table generate columns output table. Column names input used output, preserving order well.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_summary_stats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Table Transformer: obtener una tabla de estadísticas de resumen para columnas\nnuméricas — tt_summary_stats","text":"","code":"tt_summary_stats(tbl)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_summary_stats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Table Transformer: obtener una tabla de estadísticas de resumen para columnas\nnuméricas — tt_summary_stats","text":"tbl table object used input transformation. can data frame, tibble, tbl_dbi object, tbl_spark object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_summary_stats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Table Transformer: obtener una tabla de estadísticas de resumen para columnas\nnuméricas — tt_summary_stats","text":"Un objeto tibble.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_summary_stats.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Table Transformer: obtener una tabla de estadísticas de resumen para columnas\nnuméricas — tt_summary_stats","text":"12-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_summary_stats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Table Transformer: obtener una tabla de estadísticas de resumen para columnas\nnuméricas — tt_summary_stats","text":"","code":"# Get summary statistics for the # `game_revenue` dataset that is # included in the package tt_summary_stats(game_revenue) #> # A tibble: 9 × 3 #>   .param. item_revenue session_duration #>   <chr>          <dbl>            <dbl> #> 1 min             0                 3.2 #> 2 p05             0.02              8.2 #> 3 q_1             0.09             18.5 #> 4 med             0.38             26.5 #> 5 q_3             1.25             33.8 #> 6 p95            22.0              39.5 #> 7 max           143.               41   #> 8 iqr             1.16             15.3 #> 9 range         143.               37.8  # Ensure that the maximum revenue # for individual purchases in the # `game_revenue` table is less than # $150 tt_summary_stats(game_revenue) %>%   col_vals_lt(     columns = vars(item_revenue),     value = 150,     segments = .param. ~ \"max\"   ) #> # A tibble: 9 × 3 #>   .param. item_revenue session_duration #>   <chr>          <dbl>            <dbl> #> 1 min             0                 3.2 #> 2 p05             0.02              8.2 #> 3 q_1             0.09             18.5 #> 4 med             0.38             26.5 #> 5 q_3             1.25             33.8 #> 6 p95            22.0              39.5 #> 7 max           143.               41   #> 8 iqr             1.16             15.3 #> 9 range         143.               37.8  # For in-app purchases in the # `game_revenue` table, check that # median revenue is somewhere # between $8 and $12 game_revenue %>%    dplyr::filter(item_type == \"iap\") %>%   tt_summary_stats() %>%   col_vals_between(     columns = vars(item_revenue),     left = 8, right = 12,     segments = .param. ~ \"med\"   ) #> # A tibble: 9 × 3 #>   .param. item_revenue session_duration #>   <chr>          <dbl>            <dbl> #> 1 min             0.4              3.2  #> 2 p05             1.39             5.99 #> 3 q_1             4.49            14.0  #> 4 med            10.5             22.6  #> 5 q_3            20.3             30.6  #> 6 p95            66.0             38.8  #> 7 max           143.              41    #> 8 iqr            15.8             16.7  #> 9 range         143.              37.8   # While performing validations of the # `game_revenue` table with an agent # we can include the same revenue # check by using `tt_summary_stats()` # in the `preconditions` argument (this # will transform the target table for # the validation step); we also need # to get just a segment of that table # (the row with the median values) agent <-    create_agent(     read_fn = ~ game_revenue,     tbl_name = \"game_revenue\",     label = \"Un ejemplo.\",     actions = action_levels(       warn_at = 0.10,       stop_at = 0.25,       notify_at = 0.35     )   ) %>%   rows_complete() %>%   rows_distinct() %>%   col_vals_between(     columns = vars(item_revenue),     left = 8, right = 12,     preconditions = ~ . %>%       dplyr::filter(item_type == \"iap\") %>%       tt_summary_stats(),     segments = .param. ~ \"med\"   ) %>%   interrogate()  # This should all pass but let's check: all_passed(agent) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_tbl_colnames.html","id":null,"dir":"Reference","previous_headings":"","what":"Table Transformer: obtener los nombres de las columnas de una tabla — tt_tbl_colnames","title":"Table Transformer: obtener los nombres de las columnas de una tabla — tt_tbl_colnames","text":"table object, can produce summary table contains table's column names. output summary table two columns many rows columns input table. first column \".param.\" column, integer-based column containing indices columns input table. second column, \"value\", contains column names input table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_tbl_colnames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Table Transformer: obtener los nombres de las columnas de una tabla — tt_tbl_colnames","text":"","code":"tt_tbl_colnames(tbl)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_tbl_colnames.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Table Transformer: obtener los nombres de las columnas de una tabla — tt_tbl_colnames","text":"tbl table object used input transformation. can data frame, tibble, tbl_dbi object, tbl_spark object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_tbl_colnames.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Table Transformer: obtener los nombres de las columnas de una tabla — tt_tbl_colnames","text":"Un objeto tibble.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_tbl_colnames.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Table Transformer: obtener los nombres de las columnas de una tabla — tt_tbl_colnames","text":"12-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_tbl_colnames.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Table Transformer: obtener los nombres de las columnas de una tabla — tt_tbl_colnames","text":"","code":"# Get the column names of the # `game_revenue` dataset that's # included in the package tt_tbl_colnames(game_revenue) #> # A tibble: 11 × 2 #>    .param. value            #>      <int> <chr>            #>  1       1 player_id        #>  2       2 session_id       #>  3       3 session_start    #>  4       4 time             #>  5       5 item_type        #>  6       6 item_name        #>  7       7 item_revenue     #>  8       8 session_duration #>  9       9 start_day        #> 10      10 acquisition      #> 11      11 country           # This output table is useful when # you want to validate the # column names of the table; here, # we check that `game_revenue` has # certain column names present tt_tbl_colnames(game_revenue) %>%   test_col_vals_make_subset(     columns = vars(value),     set = c(\"acquisition\", \"country\")   ) #> [1] TRUE  # We can check to see whether the # column names in the `specifications` # table are all less than 15 # characters in length specifications %>%   tt_tbl_colnames() %>%   tt_string_info() %>%   test_col_vals_lt(     columns = vars(value),     value = 15   ) #> [1] FALSE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_tbl_dims.html","id":null,"dir":"Reference","previous_headings":"","what":"Table Transformer: obtener las dimensiones de una mesa — tt_tbl_dims","title":"Table Transformer: obtener las dimensiones de una mesa — tt_tbl_dims","text":"table object, can produce summary table contains nothing table's dimensions: number rows number columns. output summary table two columns two rows. first \".param.\" column labels \"rows\" \"columns\"; second column, \"value\", contains row column counts.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_tbl_dims.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Table Transformer: obtener las dimensiones de una mesa — tt_tbl_dims","text":"","code":"tt_tbl_dims(tbl)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_tbl_dims.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Table Transformer: obtener las dimensiones de una mesa — tt_tbl_dims","text":"tbl table object used input transformation. can data frame, tibble, tbl_dbi object, tbl_spark object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_tbl_dims.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Table Transformer: obtener las dimensiones de una mesa — tt_tbl_dims","text":"Un objeto tibble.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_tbl_dims.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Table Transformer: obtener las dimensiones de una mesa — tt_tbl_dims","text":"12-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_tbl_dims.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Table Transformer: obtener las dimensiones de una mesa — tt_tbl_dims","text":"","code":"# Get the dimensions of the # `game_revenue` dataset that's # included in the package tt_tbl_dims(game_revenue) #> # A tibble: 2 × 2 #>   .param. value #>   <chr>   <int> #> 1 rows     2000 #> 2 columns    11  # This output table is useful when # you want to validate the # dimensions of the table; here, # we check that `game_revenue` has # at least 1500 rows tt_tbl_dims(game_revenue) %>%   dplyr::filter(.param. == \"rows\") %>%   test_col_vals_gt(     columns = vars(value),     value = 1500   ) #> [1] TRUE  # We can check `small_table` for # an exact number of columns (`8`) tt_tbl_dims(small_table) %>%   dplyr::filter(.param. == \"columns\") %>%   test_col_vals_equal(     columns = vars(value),     value = 8   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_shift.html","id":null,"dir":"Reference","previous_headings":"","what":"Table Transformer: cambiar los tiempos de una mesa — tt_time_shift","title":"Table Transformer: cambiar los tiempos de una mesa — tt_time_shift","text":"table object containing date date-time columns, values can precisely shifted tt_time_shift() specification time shift. can either provide string time shift components shift direction (like \"-4y 10d\") difftime object (can created via lubridate expressions using base::difftime() function).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_shift.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Table Transformer: cambiar los tiempos de una mesa — tt_time_shift","text":"","code":"tt_time_shift(tbl, time_shift = \"0y 0m 0d 0H 0M 0S\")"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_shift.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Table Transformer: cambiar los tiempos de una mesa — tt_time_shift","text":"tbl table object used input transformation. can data frame, tibble, tbl_dbi object, tbl_spark object. time_shift Either character-based representation specifies time difference time values time-based columns shifted, , difftime object. character string constructed format \"0y 0m 0d 0H 0M 0S\" individual time components can omitted (.e., \"1y 5d\" valid specification shifting time values ahead one year five days). Adding \"-\" beginning string (e.g., \"-2y\") shift time values back.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_shift.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Table Transformer: cambiar los tiempos de una mesa — tt_time_shift","text":"data frame, tibble, tbl_dbi object, tbl_spark object depending provided tbl.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_shift.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Table Transformer: cambiar los tiempos de una mesa — tt_time_shift","text":"time_shift specification higher time granularity least granular time column input table. Put simpler terms, date-based based columns (just single date-based column) time shifting can terms years, months, days. Using time_shift specification \"20d 6H\" presence dates result truncation \"20d\". Similarly, difftime object altered circumstances, however, object resolved exact number days rounding.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_shift.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Table Transformer: cambiar los tiempos de una mesa — tt_time_shift","text":"12-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_shift.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Table Transformer: cambiar los tiempos de una mesa — tt_time_shift","text":"","code":"# With the `game_revenue` dataset, # which has entries in the first # 21 days of 2015, move all of the # date and date-time values to the # beginning of 2021 tt_time_shift(   tbl = game_revenue,   time_shift = \"6y\" ) #> # A tibble: 2,000 × 11 #>    player_id       session_id  session_start       time                item_type #>    <chr>           <chr>       <dttm>              <dttm>              <chr>     #>  1 ECPANOIXLZHF896 ECPANOIXLZ… 2021-01-01 01:31:03 2021-01-01 01:31:27 iap       #>  2 ECPANOIXLZHF896 ECPANOIXLZ… 2021-01-01 01:31:03 2021-01-01 01:36:57 iap       #>  3 ECPANOIXLZHF896 ECPANOIXLZ… 2021-01-01 01:31:03 2021-01-01 01:37:45 iap       #>  4 ECPANOIXLZHF896 ECPANOIXLZ… 2021-01-01 01:31:03 2021-01-01 01:42:33 ad        #>  5 ECPANOIXLZHF896 ECPANOIXLZ… 2021-01-01 11:50:02 2021-01-01 11:55:20 ad        #>  6 ECPANOIXLZHF896 ECPANOIXLZ… 2021-01-01 11:50:02 2021-01-01 12:08:56 ad        #>  7 ECPANOIXLZHF896 ECPANOIXLZ… 2021-01-01 11:50:02 2021-01-01 12:14:08 ad        #>  8 ECPANOIXLZHF896 ECPANOIXLZ… 2021-01-01 11:50:02 2021-01-01 12:21:44 ad        #>  9 ECPANOIXLZHF896 ECPANOIXLZ… 2021-01-01 11:50:02 2021-01-01 12:24:20 ad        #> 10 FXWUORGYNJAE271 FXWUORGYNJ… 2021-01-01 15:17:18 2021-01-01 15:19:36 ad        #> # … with 1,990 more rows, and 6 more variables: item_name <chr>, #> #   item_revenue <dbl>, session_duration <dbl>, start_day <date>, #> #   acquisition <chr>, country <chr>  # Keeping only the `date_time` and # `a`-`f` columns of `small_table`, # shift the times back 2 days and # 12 hours small_table %>%   dplyr::select(-date) %>%   tt_time_shift(\"-2d 12H\") #> # A tibble: 13 × 7 #>    date_time               a b             c      d e     f     #>    <dttm>              <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-01 23:00:00     2 1-bcd-345     3  3423. TRUE  high  #>  2 2016-01-01 12:32:00     3 5-egh-163     8 10000. TRUE  low   #>  3 2016-01-03 01:32:00     6 8-kdg-938     3  2343. TRUE  high  #>  4 2016-01-04 05:23:00     2 5-jdo-903    NA  3892. FALSE mid   #>  5 2016-01-07 00:36:00     8 3-ldm-038     7   284. TRUE  low   #>  6 2016-01-08 18:15:00     4 2-dhe-923     4  3291. TRUE  mid   #>  7 2016-01-13 06:46:00     7 1-knw-093     3   843. TRUE  high  #>  8 2016-01-14 23:27:00     4 5-boe-639     2  1036. FALSE low   #>  9 2016-01-17 16:30:00     3 5-bce-642     9   838. FALSE high  #> 10 2016-01-17 16:30:00     3 5-bce-642     9   838. FALSE high  #> 11 2016-01-24 08:07:00     4 2-dmx-010     7   834. TRUE  low   #> 12 2016-01-25 14:51:00     2 7-dmx-010     8   108. FALSE low   #> 13 2016-01-27 23:23:00     1 3-dka-303    NA  2230. TRUE  high"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_slice.html","id":null,"dir":"Reference","previous_headings":"","what":"Table Transformer: cortar una tabla con un punto de corte en una columna de\ntiempo — tt_time_slice","title":"Table Transformer: cortar una tabla con un punto de corte en una columna de\ntiempo — tt_time_slice","text":"table object containing date, date-time columns, mixture thereof, one columns can used effectively slice data table two slice_point: get choose slices want keep. slice point can defined several ways. One method involves using decimal value 0 1, defines slice point time instant somewhere earliest time value (0) latest time value (1). Another way defining slice point supplying time value, following input types accepted: (1) ISO 8601 formatted time string (date date-time), (2) POSIXct time, (3) Date object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_slice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Table Transformer: cortar una tabla con un punto de corte en una columna de\ntiempo — tt_time_slice","text":"","code":"tt_time_slice(   tbl,   time_column = NULL,   slice_point = 0,   keep = c(\"left\", \"right\"),   arrange = FALSE )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_slice.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Table Transformer: cortar una tabla con un punto de corte en una columna de\ntiempo — tt_time_slice","text":"tbl table object used input transformation. can data frame, tibble, tbl_dbi object, tbl_spark object. time_column time-based column used basis slicing. time column provided first one found used. slice_point location time_column slicing occur. can either decimal value 0 1, ISO 8601 formatted time string (date date-time), POSIXct time, Date object. keep slice kept? \"left\" side (default) contains data rows earlier slice_point \"right\" side rows later. arrange slice arranged time_column? may useful input tbl ordered time_column. default, FALSE original ordering retained.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_slice.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Table Transformer: cortar una tabla con un punto de corte en una columna de\ntiempo — tt_time_slice","text":"data frame, tibble, tbl_dbi object, tbl_spark object depending provided tbl.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_slice.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Table Transformer: cortar una tabla con un punto de corte en una columna de\ntiempo — tt_time_slice","text":"option arrange table date date-time values time_column. ordering always done ascending manner. NA/NULL values time_column result corresponding rows can removed (matter slice retained).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_slice.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Table Transformer: cortar una tabla con un punto de corte en una columna de\ntiempo — tt_time_slice","text":"12-6","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_slice.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Table Transformer: cortar una tabla con un punto de corte en una columna de\ntiempo — tt_time_slice","text":"","code":"# With the `game_revenue` dataset, # which has entries in the first # 21 days of 2015, elect to get all # of the records where the `time` # values are strictly for the first # 15 days of 2015 tt_time_slice(   tbl = game_revenue,   time_column = \"time\",   slice_point = \"2015-01-16\" ) #> # A tibble: 1,208 × 11 #>    player_id       session_id  session_start       time                item_type #>    <chr>           <chr>       <dttm>              <dttm>              <chr>     #>  1 ECPANOIXLZHF896 ECPANOIXLZ… 2015-01-01 01:31:03 2015-01-01 01:31:27 iap       #>  2 ECPANOIXLZHF896 ECPANOIXLZ… 2015-01-01 01:31:03 2015-01-01 01:36:57 iap       #>  3 ECPANOIXLZHF896 ECPANOIXLZ… 2015-01-01 01:31:03 2015-01-01 01:37:45 iap       #>  4 ECPANOIXLZHF896 ECPANOIXLZ… 2015-01-01 01:31:03 2015-01-01 01:42:33 ad        #>  5 ECPANOIXLZHF896 ECPANOIXLZ… 2015-01-01 11:50:02 2015-01-01 11:55:20 ad        #>  6 ECPANOIXLZHF896 ECPANOIXLZ… 2015-01-01 11:50:02 2015-01-01 12:08:56 ad        #>  7 ECPANOIXLZHF896 ECPANOIXLZ… 2015-01-01 11:50:02 2015-01-01 12:14:08 ad        #>  8 ECPANOIXLZHF896 ECPANOIXLZ… 2015-01-01 11:50:02 2015-01-01 12:21:44 ad        #>  9 ECPANOIXLZHF896 ECPANOIXLZ… 2015-01-01 11:50:02 2015-01-01 12:24:20 ad        #> 10 FXWUORGYNJAE271 FXWUORGYNJ… 2015-01-01 15:17:18 2015-01-01 15:19:36 ad        #> # … with 1,198 more rows, and 6 more variables: item_name <chr>, #> #   item_revenue <dbl>, session_duration <dbl>, start_day <date>, #> #   acquisition <chr>, country <chr>  # Omit the first 25% of records # from `small_table` on the basis # of a timeline that begins at  # `2016-01-04 11:00:00` and # ends at `2016-01-30 11:23:00` small_table %>%   tt_time_slice(     slice_point = 0.25,     keep = \"right\"   ) #> # A tibble: 8 × 8 #>   date_time           date           a b             c     d e     f     #>   <dttm>              <date>     <int> <chr>     <dbl> <dbl> <lgl> <chr> #> 1 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4 3291. TRUE  mid   #> 2 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3  843. TRUE  high  #> 3 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2 1036. FALSE low   #> 4 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high  #> 5 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high  #> 6 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7  834. TRUE  low   #> 7 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8  108. FALSE low   #> 8 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA 2230. TRUE  high"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/validate_rmd.html","id":null,"dir":"Reference","previous_headings":"","what":"Modificar las opciones de prueba de validación pointblank dentro de los\ndocumentos de R Markdown — validate_rmd","title":"Modificar las opciones de prueba de validación pointblank dentro de los\ndocumentos de R Markdown — validate_rmd","text":"Using pointblank R Markdown workflow enabled default pointblank library loaded. framework allows validation testing within specialized validation code chunks validate = TRUE option set. Using pointblank validation functions data marked code chunks flag overall failure stop threshold exceeded anywhere. errors reported validation code chunk rendering document HTML, green red status buttons indicate whether validations succeeded failures occurred. Clicking button reveals otherwise hidden validation statements error messages (). framework testing set default, validate_rmd() function offers opportunity set UI logging options.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/validate_rmd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modificar las opciones de prueba de validación pointblank dentro de los\ndocumentos de R Markdown — validate_rmd","text":"","code":"validate_rmd(summary = TRUE, log_to_file = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/validate_rmd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modificar las opciones de prueba de validación pointblank dentro de los\ndocumentos de R Markdown — validate_rmd","text":"summary TRUE (default), leading summary validations rendered R Markdown document. FALSE, element shown. log_to_file option log errors text file. default, logging done TRUE write log entries \"validation_errors.log\" working directory. enable logging specify file name, include path log file desired name.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/validate_rmd.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Modificar las opciones de prueba de validación pointblank dentro de los\ndocumentos de R Markdown — validate_rmd","text":"1-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/write_testthat_file.html","id":null,"dir":"Reference","previous_headings":"","what":"Transforma un agente pointblank en un testthat archivo de prueba — write_testthat_file","title":"Transforma un agente pointblank en un testthat archivo de prueba — write_testthat_file","text":"Con un objeto pointblank agent, podemos escribir un archivo de prueba testthat y optar por colocarlo en testthat/tests si está disponible en la ruta del proyecto (también podemos especificar una ruta alternativa). Esto funciona transformando los pasos de validación en una serie de llamadas expect_*() dentro de declaraciones individuales testthat::test_that(). Un requisito indispensable para utilizar write_testthat_file() en un agente es la presencia de una read_fn, que es una función que se invoca para obtener la tabla de destino. La sentencia read_fn se colocará en la parte superior del archivo de prueba testthat para que la tabla de destino esté disponible para cada una de las sentencias testthat::test_that() que le siguen. Si un objeto agent tiene una read_fn puede añadirse través de set_read_fn(). Los umbrales se obtendrán partir de los aplicados para el estado stop. Esto puede configurarse para un objeto agente* en blanco pasando un objeto action_levels al argumento actions de create_agent() o el mismo argumento de cualquier función de validación incluida. Si los umbrales stop están disponibles, se utilizará un valor de umbral de 1 para cada sentencia expect_*() generada en el archivo de prueba testthat resultante. es necesario que el objeto agent se someta primero una interrogación con interrogate(). Sin embargo, puede ser útil como prueba de funcionamiento realizar interactivamente una interrogación en los datos de destino antes de generar el archivo de prueba testthat.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/write_testthat_file.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transforma un agente pointblank en un testthat archivo de prueba — write_testthat_file","text":"","code":"write_testthat_file(   agent,   name = NULL,   path = NULL,   overwrite = FALSE,   skips = NULL,   quiet = FALSE )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/write_testthat_file.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transforma un agente pointblank en un testthat archivo de prueba — write_testthat_file","text":"agent Un objeto de agente de clase ptblank_agent. name Un nombre opcional para el archivo de prueba testhat. Debe ser un nombre sin extensión y sin el texto inicial \"test-\". Si se suministra nada, el nombre se derivará del tbl_name en el objeto agente. Si está presente, se utilizará un nombre genérico. path Aquí se puede especificar una ruta si se debe intentar colocar el archivo en testthat/tests. overwrite ¿Debe sobrescribirse un archivo testthat del mismo nombre? Por defecto, esto es FALSE. skips Se trata de un vector opcional de palabras clave de omisión de pruebas modelado partir de las funciones testthat skip_on_*(). Las siguientes palabras clave pueden utilizarse para incluir declaraciones skip_on_*(): \"cran\" (testthat::skip_on_cran()), \"travis\" (testthat::skip_on_travis()), \"appveyor\" (testthat::skip_on_appveyor()), \"ci\" (testthat::skip_on_ci()), \"covr\" (testthat::skip_on_covr()), \"bioc\" (testthat::skip_on_bioc()). Existen palabras clave para omitir pruebas en determinados sistemas operativos y todas ellas insertarán una llamada específica testthat::skip_on_os(). Estas son \"windows\" (skip_on_os(\"windows\")), \"mac\" (skip_on_os(\"mac\")), \"linux\" (skip_on_os(\"linux\")) y \"solaris\" (skip_on_os(\"solaris\")). Estas declaraciones se colocarán en la parte superior del archivo de prueba testthat generado. quiet ¿La función debe informar cuando se escribe el archivo? En por defecto es FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/write_testthat_file.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transforma un agente pointblank en un testthat archivo de prueba — write_testthat_file","text":"Devuelve invisiblemente TRUE si el archivo testthat ha sido escrito.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/write_testthat_file.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transforma un agente pointblank en un testthat archivo de prueba — write_testthat_file","text":"Las pruebas de los pasos de validación inactivos se omitirán con un mensaje claro que indique que el motivo de la omisión se debe que la prueba está activa. Cualquier paso de validación inactivo puede ser forzado un estado activo utilizando la función activate_steps() en un objeto agent (lo contrario es posible con la función deactivate_steps()). El paquete testthat viene con una serie de funciones skip_on_*() que convenientemente hacen que el archivo de prueba se salte por completo si se cumplen ciertas condiciones. Podemos establecer rápidamente cualquier número de ellas en la parte superior del archivo de prueba testthat suministrando palabras clave como un vector la opción skips de write_testthat_file(). Por ejemplo, si establecemos skips = c(\"cran\", \"windows) añadiremos el código skip_on_cran() y skip_on_os(\"windows\"), lo que significa que el archivo de prueba generado se ejecutará en un sistema CRAN o si el sistema operativo es Windows. Este es un ejemplo de la salida del archivo de prueba testthat: test-small_table.R Esto fue generado por el siguiente conjunto de declaraciones:","code":"# Generated by pointblank  tbl <- small_table  test_that(\"column `date_time` exists\", {      expect_col_exists(     tbl,     columns = vars(date_time),     threshold = 1   )  })  test_that(\"values in `c` should be <= `5`\", {      expect_col_vals_lte(     tbl,     columns = vars(c),     value = 5,     threshold = 0.25   )  }) library(pointblank)  agent <-    create_agent(     read_fn = ~ small_table,     actions = action_levels(stop_at = 0.25)   ) %>%   col_exists(vars(date_time)) %>%   col_vals_lte(vars(c), value = 5)    write_testthat_file(   agent = agent,   name = \"small_table\",   path = \".\" )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/write_testthat_file.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Transforma un agente pointblank en un testthat archivo de prueba — write_testthat_file","text":"8-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/write_testthat_file.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transforma un agente pointblank en un testthat archivo de prueba — write_testthat_file","text":"","code":"if (interactive()) {  # Creating an `action_levels` object is a # common workflow step when creating a # pointblank agent; we designate failure # thresholds to the `warn`, `stop`, and # `notify` states using `action_levels()` al <-    action_levels(     warn_at = 0.10,     stop_at = 0.25,     notify_at = 0.35   )  # A pointblank `agent` object is now # created and the `al` object is provided # to the agent; the static thresholds # provided by `al` make reports a bit # more useful after interrogation agent <-    create_agent(     read_fn = ~ small_table,     label = \"Un ejemplo.\",     actions = al   ) %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b),     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5) %>%   interrogate()  # This agent and all of the checks can # be transformed into a testthat file # with `write_testthat_file()`; the `stop` # thresholds will be ported over write_testthat_file(   agent = agent,   name = \"small_table\",   path = \".\" )  # The above code will generate a file with # the name `test-small_table.R`; the path # was specified with `\".\"` but, by default, # the function will place the file in the # `tests/testthat` folder if it's available  # An agent on disk as a YAML file can be # made into a testthat file; the # 'agent-small_table.yml' file is # available in the package through # `system.file()` yml_file <-    system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   )  # Writing the testthat file into the # working directory is much the same # as before but we're reading the # agent from disk this time write_testthat_file(   agent = yaml_read_agent(yml_file),   name = \"from_agent_yaml\",   path = \".\" )  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_read_disk.html","id":null,"dir":"Reference","previous_headings":"","what":"Leer un agent, informant, multiagent o escaneo de tabla desde el disco — x_read_disk","title":"Leer un agent, informant, multiagent o escaneo de tabla desde el disco — x_read_disk","text":"agent, informant, multiagent, table scan written disk (x_write_disk()) can read back memory x_read_disk() function. agent informant object generated way, may data table associated (depending whether keep_tbl option TRUE FALSE writing disk) still able produce reporting (printing agent informant console using get_agent_report()/get_informant_report()). agent return x-list get_agent_x_list() yield available data extracts get_data_extracts(). Furthermore, agent's validation steps still present (along results last interrogation).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_read_disk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Leer un agent, informant, multiagent o escaneo de tabla desde el disco — x_read_disk","text":"","code":"x_read_disk(filename, path = NULL, quiet = FALSE)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_read_disk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Leer un agent, informant, multiagent o escaneo de tabla desde el disco — x_read_disk","text":"filename name file previously written x_write_disk(). path optional path file (combined filename). quiet function inform file read? default FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_read_disk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Leer un agent, informant, multiagent o escaneo de tabla desde el disco — x_read_disk","text":"Either ptblank_agent, ptblank_informant, ptblank_tbl_scan object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_read_disk.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Leer un agent, informant, multiagent o escaneo de tabla desde el disco — x_read_disk","text":"written--disk agent informant possess table-prep formula (can set time set_read_fn()) specific table (settable set_tbl()) use interrogate() incorporate() function . data quality reporting workflow, useful interrogate() target tables evolve time. validation steps used, can added calling interrogate(). information management workflow informant object, using incorporate() update aspects reporting table dimensions, info snippets/text regenerated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_read_disk.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Leer un agent, informant, multiagent o escaneo de tabla desde el disco — x_read_disk","text":"9-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_read_disk.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Leer un agent, informant, multiagent o escaneo de tabla desde el disco — x_read_disk","text":"","code":"if (interactive()) {  # A: Reading an agent from disk   # The process of developing an agent # and writing it to disk with the # `x_write_disk()` function is explained # in that function's documentation; # but suppose we have such a written file # that's named \"agent-small_table.rds\", # we could read that to a new agent # object with `x_read_disk()` agent <-   x_read_disk(\"agent-small_table.rds\")  # B: Reading an informant from disk  # If there is an informant written # to disk via `x_write_disk()` and it's # named \"informant-small_table.rds\", # we could read that to a new informant # object with `x_read_disk()` informant <-   x_read_disk(\"informant-small_table.rds\")  # C: Reading a multiagent from disk   # The process of creating a multiagent # and writing it to disk with the # `x_write_disk()` function is shown # in that function's documentation; # but should we have such a written file # called \"multiagent-small_table.rds\", # we could read that to a new multiagent # object with `x_read_disk()` agent <-   x_read_disk(\"multiagent-small_table.rds\")  # D: Reading a table scan from disk  # If there is a table scan written # to disk via `x_write_disk()` and it's # named \"tbl_scan-storms.rds\", we could # read it back into R with `x_read_disk()` tbl_scan <-   x_read_disk(\"tbl_scan-storms.rds\")  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_write_disk.html","id":null,"dir":"Reference","previous_headings":"","what":"Escriba un agent, informant, multiagent o escaneo de tabla al disco — x_write_disk","title":"Escriba un agent, informant, multiagent o escaneo de tabla al disco — x_write_disk","text":"Writing agent, informant, multiagent, even table scan disk x_write_disk() can useful keeping data validation intel table information close hand later retrieval (x_read_disk()). default, data table agent informant may held committed disk expunged (applicable table scan since never hold table object). behavior can changed setting keep_tbl TRUE works case table tbl_dbi tbl_spark class.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_write_disk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Escriba un agent, informant, multiagent o escaneo de tabla al disco — x_write_disk","text":"","code":"x_write_disk(   x,   filename,   path = NULL,   keep_tbl = FALSE,   keep_extracts = FALSE,   quiet = FALSE )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_write_disk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Escriba un agent, informant, multiagent o escaneo de tabla al disco — x_write_disk","text":"x agent object class ptblank_agent, informant class ptblank_informant, table scan class ptblank_tbl_scan. filename filename create disk agent, informant, table scan. path optional path file saved (automatically combined filename). keep_tbl option keep data table associated agent informant (case agent, example, created using create_agent(tbl = <data table, ...)). default FALSE data table removed writing disk. database tables class tbl_dbi Spark DataFrames (tbl_spark) table always removed (even keep_tbl set TRUE). keep_extracts option keep collected extract data failing rows. applies agent objects. default, FALSE (.e., extract data removed). quiet function inform file written? default FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_write_disk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Escriba un agent, informant, multiagent o escaneo de tabla al disco — x_write_disk","text":"Invisibly returns TRUE file written.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_write_disk.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Escriba un agent, informant, multiagent o escaneo de tabla al disco — x_write_disk","text":"recommended set table-prep formula agent informant can access refreshed data read disk x_read_disk(). can done initially read_fn argument create_agent()/create_informant() , later, set_read_fn(). Alternatively, can reintroduce agent informant data table set_tbl() function.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_write_disk.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Escriba un agent, informant, multiagent o escaneo de tabla al disco — x_write_disk","text":"9-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_write_disk.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Escriba un agent, informant, multiagent o escaneo de tabla al disco — x_write_disk","text":"","code":"if (interactive()) {  # A: Writing an `agent` to disk   # Let's go through the process of (1) # developing an agent with a validation # plan (to be used for the data quality # analysis of the `small_table` dataset), # (2) interrogating the agent with the # `interrogate()` function, and (3) writing # the agent and all its intel to a file  # Creating an `action_levels` object is a # common workflow step when creating a # pointblank agent; we designate failure # thresholds to the `warn`, `stop`, and # `notify` states using `action_levels()` al <-    action_levels(     warn_at = 0.10,     stop_at = 0.25,     notify_at = 0.35   )  # Now create a pointblank `agent` object # and give it the `al` object (which # serves as a default for all validation # steps which can be overridden); the # data will be referenced in a `read_fn` agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"`x_write_disk()`\",     actions = al   )  # Then, as with any `agent` object, we # can add steps to the validation plan by # using as many validation functions as we # want; then, we `interrogate()` agent <-   agent %>%    col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b), regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5) %>%   interrogate()  # The `agent` can be written to a file with # the `x_write_disk()` function x_write_disk(   agent,   filename = \"agent-small_table.rds\" )  # We can read the file back as an agent # with the `x_read_disk()` function and # we'll get all of the intel along with the # restored agent  # If you're consistently writing agent # reports when periodically checking data, # we could make use of the `affix_date()` # or `affix_datetime()` depending on the # granularity you need; here's an example # that writes the file with the format: # 'agent-small_table-YYYY-mm-dd_HH-MM-SS.rds' x_write_disk(   agent,   filename = affix_datetime(     \"agent-small_table.rds\"   ) )  # B: Writing an `informant` to disk  # Let's go through the process of (1) # creating an informant object that # minimally describes the `small_table` # dataset, (2) ensuring that data is # captured from the target table using # the `incorporate()` function, and (3) # writing the informant to a file  # Create a pointblank `informant` # object with `create_informant()` # and the `small_table` dataset; use # `incorporate()` so that info snippets # are integrated into the text informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"`x_write_disk()`\"   ) %>%   info_snippet(     snippet_name = \"high_a\",     fn = snip_highest(column = \"a\")   ) %>%   info_snippet(     snippet_name = \"low_a\",     fn = snip_lowest(column = \"a\")   ) %>%   info_columns(     columns = vars(a),     info = \"From {low_a} to {high_a}.\"   ) %>%   info_columns(     columns = starts_with(\"date\"),     info = \"Time-based values.\"   ) %>%   info_columns(     columns = \"date\",     info = \"The date part of `date_time`.\"   ) %>%   incorporate()  # The `informant` can be written to a # file with `x_write_disk()`; let's do # this with `affix_date()` so that the # filename has a datestamp x_write_disk(   informant,   filename = affix_date(     \"informant-small_table.rds\"   ) )  # We can read the file back into a # new informant object (in the same # state as when it was saved) by using # `x_read_disk()`  # C: Writing a multiagent to disk  # Let's create one more pointblank # agent object, provide it with some # validation steps, and `interrogate()` agent_b <-   create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"`x_write_disk()`\",     actions = al   ) %>%   col_vals_gt(     vars(b), vars(g), na_pass = TRUE,     label = \"b > g\"   ) %>%   col_is_character(     vars(b, f),     label = \"Verifying character-type columns\"    ) %>%   interrogate()  # Now we can combine the earlier `agent` # object with the newer `agent_b` to  # create a `multiagent` multiagent <-   create_multiagent(agent, agent_b)    # The `multiagent` can be written to # a file with the `x_write_disk()` function x_write_disk(   multiagent,   filename = \"multiagent-small_table.rds\" )  # We can read the file back as a multiagent # with the `x_read_disk()` function and # we'll get all of the constituent agents # and their associated intel back as well  # D: Writing a table scan to disk  # We can get an report that describes all # of the data in the `storms` dataset tbl_scan <- scan_data(tbl = dplyr::storms)  # The table scan object can be written # to a file with `x_write_disk()` x_write_disk(   tbl_scan,   filename = \"tbl_scan-storms.rds\" )  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_interrogate.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtenga un agent de pointblank YAML e interrogate() — yaml_agent_interrogate","title":"Obtenga un agent de pointblank YAML e interrogate() — yaml_agent_interrogate","text":"yaml_agent_interrogate() function operates much like yaml_read_agent() function (reading pointblank YAML file generating agent validation plan place). key difference function takes things step interrogates target table (defined table-prep formula required YAML file). additional auto-invocation interrogate() uses default options function. yaml_read_agent() agent returned except, time, intel interrogation.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_interrogate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtenga un agent de pointblank YAML e interrogate() — yaml_agent_interrogate","text":"","code":"yaml_agent_interrogate(filename, path = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_interrogate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtenga un agent de pointblank YAML e interrogate() — yaml_agent_interrogate","text":"filename name YAML file contains fields related agent. path optional path YAML file (combined filename).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_interrogate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtenga un agent de pointblank YAML e interrogate() — yaml_agent_interrogate","text":"Un objeto ptblank_agent.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_interrogate.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Obtenga un agent de pointblank YAML e interrogate() — yaml_agent_interrogate","text":"11-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_interrogate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtenga un agent de pointblank YAML e interrogate() — yaml_agent_interrogate","text":"","code":"if (interactive()) {  # Let's go through the process of # developing an agent with a validation # plan (to be used for the data quality # analysis of the `small_table` dataset), # and then offloading that validation # plan to a pointblank YAML file; this # will later be read in as a new agent and # the target data will be interrogated # (one step) with `yaml_agent_interrogate()`  # Creating an `action_levels` object is a # common workflow step when creating a # pointblank agent; we designate failure # thresholds to the `warn`, `stop`, and # `notify` states using `action_levels()` al <-    action_levels(     warn_at = 0.10,     stop_at = 0.25,     notify_at = 0.35   )  # Now create a pointblank `agent` object # and give it the `al` object (which # serves as a default for all validation # steps which can be overridden); the # data will be referenced in a `read_fn` # (a requirement for writing to YAML) agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"A simple example with the `small_table`.\",     actions = al   )  # Then, as with any `agent` object, we # can add steps to the validation plan by # using as many validation functions as we # want agent <-   agent %>%    col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b),     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5)  # The agent can be written to a pointblank # YAML file with `yaml_write()` yaml_write(   agent = agent,   filename = \"agent-small_table.yml\" )  # The 'agent-small_table.yml' file is # available in the package through `system.file()` yml_file <-    system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   )  # We can view the YAML file in the console # with the `yaml_agent_string()` function yaml_agent_string(filename = yml_file)  # The YAML can also be printed in the console # by supplying the agent as the input yaml_agent_string(agent = agent)  # We can interrogate the data (which # is accessible through the `read_fn`) # through direct use of the YAML file # with `yaml_agent_interrogate()` agent <-    yaml_agent_interrogate(filename = yml_file)  class(agent)  # If it's desired to only create a new # agent with the validation plan in place # (stopping short of interrogating the data), # then the `yaml_read_agent()` function # will be useful agent <-    yaml_read_agent(filename = yml_file) class(agent)  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_show_exprs.html","id":null,"dir":"Reference","previous_headings":"","what":"Mostrar expresiones de validación usando pointblank YAML — yaml_agent_show_exprs","title":"Mostrar expresiones de validación usando pointblank YAML — yaml_agent_show_exprs","text":"yaml_agent_show_exprs() function follows specifications pointblank YAML file generate show pointblank expressions generating described validation plan. expressions shown console, providing opportunity copy statements extend needed. pointblank YAML file can generated using yaml_write() function pre-existing agent, , can carefully written hand.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_show_exprs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mostrar expresiones de validación usando pointblank YAML — yaml_agent_show_exprs","text":"","code":"yaml_agent_show_exprs(filename, path = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_show_exprs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mostrar expresiones de validación usando pointblank YAML — yaml_agent_show_exprs","text":"filename name YAML file contains fields related agent. path optional path YAML file (combined filename).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_show_exprs.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Mostrar expresiones de validación usando pointblank YAML — yaml_agent_show_exprs","text":"11-6","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_show_exprs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mostrar expresiones de validación usando pointblank YAML — yaml_agent_show_exprs","text":"","code":"if (interactive()) {  # Let's create a validation plan for the # data quality analysis of the `small_table` # dataset; we need an agent and its # table-prep formula enables retrieval # of the target table agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"A simple example with the `small_table`.\",     actions = action_levels(       warn_at = 0.10,       stop_at = 0.25,       notify_at = 0.35     )   ) %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b),     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5)  # The agent can be written to a pointblank # YAML file with `yaml_write()` yaml_write(   agent = agent,   filename = \"agent-small_table.yml\" )  # The 'agent-small_table.yml' file is # available in the package through # `system.file()` yml_file <-    system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   )  # At a later time, the YAML file can # be read into a new agent with the # `yaml_read_agent()` function agent <-    yaml_read_agent(filename = yml_file)  class(agent)  # To get a sense of which expressions are # being used to generate the new agent, we # can use `yaml_agent_show_exprs()` yaml_agent_show_exprs(filename = yml_file)  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_string.html","id":null,"dir":"Reference","previous_headings":"","what":"Mostrar pointblank YAML usando un agente o un archivo YAML — yaml_agent_string","title":"Mostrar pointblank YAML usando un agente o un archivo YAML — yaml_agent_string","text":"pointblank YAML, can serialize agent's validation plan (yaml_write()), read back later new agent (yaml_read_agent()), perform interrogation target data table directly YAML file (yaml_agent_interrogate()). yaml_agent_string() function allows us inspect YAML generated yaml_write() console, giving us look YAML without needing open file directly. Alternatively, can provide agent yaml_agent_string() view YAML representation validation plan without needing write YAML disk beforehand.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_string.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mostrar pointblank YAML usando un agente o un archivo YAML — yaml_agent_string","text":"","code":"yaml_agent_string(agent = NULL, filename = NULL, path = NULL, expanded = FALSE)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_string.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mostrar pointblank YAML usando un agente o un archivo YAML — yaml_agent_string","text":"agent agent object class ptblank_agent. object provided , filename must provided. filename name YAML file contains fields related agent. file name provided , agent object must provided agent. path optional path YAML file (combined filename). expanded written validation expressions agent expanded tidyselect vars() expressions columns evaluated, yielding validation function per column? default, FALSE expressions written retained YAML representation.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_string.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Mostrar pointblank YAML usando un agente o un archivo YAML — yaml_agent_string","text":"11-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_string.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mostrar pointblank YAML usando un agente o un archivo YAML — yaml_agent_string","text":"","code":"if (interactive()) {  # Let's create a validation plan for the # data quality analysis of the `small_table` # dataset; we need an agent and its # table-prep formula enables retrieval # of the target table agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"A simple example with the `small_table`.\",     actions = action_levels(       warn_at = 0.10,       stop_at = 0.25,       notify_at = 0.35     )   ) %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b),     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5)  # We can view the YAML file in the console # with the `yaml_agent_string()` function, # providing the `agent` object as the input yaml_agent_string(agent = agent)  # The agent can be written to a pointblank # YAML file with `yaml_write()` yaml_write(   agent = agent,   filename = \"agent-small_table.yml\" )  # There's a similar file in the package # ('agent-small_table.yml') and it's # accessible with `system.file()` yml_file <-    system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   )  # The `yaml_agent_string()` function can # be used with the YAML file as well, # use the `filename` argument instead yaml_agent_string(filename = yml_file)  # At some later time, the YAML file can # be read as a new agent with the # `yaml_read_agent()` function agent <- yaml_read_agent(filename = yml_file) class(agent)  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_exec.html","id":null,"dir":"Reference","previous_headings":"","what":"Ejecutar todas las tareas YAML de agentes e informantes — yaml_exec","title":"Ejecutar todas las tareas YAML de agentes e informantes — yaml_exec","text":"yaml_exec() function takes relevant pointblank YAML files directory executes . Execution involves interrogation agents YAML agents incorporation informants YAML informants. hood, uses yaml_agent_interrogate() yaml_informant_incorporate() x_write_disk() save processed objects output directory. written artifacts can read later time x_read_disk() function read_disk_multiagent() function. useful data target tables changing periodic testing tables part data quality monitoring plan. output RDS files named according object type processed, target table, date-time processing. convenience modularity, setup ideal table store YAML file (typically named \"tbl_store.yml\" produced via tbl_store() yaml_write() workflow) available directory, table-prep formulas accessed name tbl_source(). typical directory files set execution way might following contents: \"tbl_store.yml\" file holding table-prep formulas (created tbl_store() written YAML yaml_write()) one YAML agent files validate tables (ideally using tbl_source()) one YAML informant files provide refreshed metadata tables (, using tbl_source() reference table preparations ideal) output folder (default \"output\") save serialized versions processed agents informants Minimal example files aforementioned types can found pointblank package following system.file() calls: system.file(\"yaml\", \"agent-small_table.yml\", package = \"pointblank\") system.file(\"yaml\", \"informant-small_table.yml\", package = \"pointblank\") system.file(\"yaml\", \"tbl_store.yml\", package = \"pointblank\") directory can accessed using system.file(\"yaml\", package = \"pointblank\").","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_exec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ejecutar todas las tareas YAML de agentes e informantes — yaml_exec","text":"","code":"yaml_exec(   path = NULL,   files = NULL,   write_to_disk = TRUE,   output_path = file.path(path, \"output\"),   keep_tbl = FALSE,   keep_extracts = FALSE )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_exec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ejecutar todas las tareas YAML de agentes e informantes — yaml_exec","text":"path path contains YAML files agents informants. files vector YAML files use execution workflow. default, yaml_exec() attempt process every valid YAML file path supplying vector limits scope specified files. write_to_disk execution workflow include step writes output files disk? internally calls x_write_disk() write RDS files uses base filename agent/informant YAML file part output filename, appending date-time basename. output_path output path generated output files. default, subdirectory provided path called \"output\". keep_tbl, keep_extracts agents, table may kept data frame object (databases tables never pulled storage) extracts, collections table rows failed validation step, may also stored. default, options set FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_exec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ejecutar todas las tareas YAML de agentes e informantes — yaml_exec","text":"Invisibly returns named vector file paths input files processed; file output paths (wherever writing occurred) given names.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_exec.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Ejecutar todas las tareas YAML de agentes e informantes — yaml_exec","text":"11-8","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_exec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ejecutar todas las tareas YAML de agentes e informantes — yaml_exec","text":"","code":"if (interactive()) {  # The 'yaml' directory that is # accessible in the package through # `system.file()` contains the files # 1. `agent-small_table.yml` # 2. `informant-small_table.yml` # 3. `tbl_store.yml`  # There are references in YAML files # 1 & 2 to the table store YAML file, # so, they all work together cohesively  # Let's process the agent and the # informant YAML files with `yaml_exec()`; # and we'll specify the working directory # as the place where the output RDS files # are written  output_dir <- getwd()  yaml_exec(   path = system.file(     \"yaml\", package = \"pointblank\"   ),   output = output_dir )  # This generates two RDS files in the # working directory: one for the agent # and the other for the informant; each # of them are automatically time-stamped # so that periodic execution can be # safely carried out without risk of # overwriting   }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_informant_incorporate.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtener un informant de pointblank YAML e incorporate() — yaml_informant_incorporate","title":"Obtener un informant de pointblank YAML e incorporate() — yaml_informant_incorporate","text":"yaml_informant_incorporate() function operates much like yaml_read_informant() function (reading pointblank YAML file generating informant information place). key difference function takes things step incorporates aspects target table (defined table-prep formula required YAML file). additional auto-invocation incorporate() uses default options function. yaml_read_informant() informant returned except, time, updated latest information target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_informant_incorporate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtener un informant de pointblank YAML e incorporate() — yaml_informant_incorporate","text":"","code":"yaml_informant_incorporate(filename, path = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_informant_incorporate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtener un informant de pointblank YAML e incorporate() — yaml_informant_incorporate","text":"filename name YAML file contains fields related informant. path optional path YAML file (combined filename).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_informant_incorporate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtener un informant de pointblank YAML e incorporate() — yaml_informant_incorporate","text":"Un objeto ptblank_informant.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_informant_incorporate.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Obtener un informant de pointblank YAML e incorporate() — yaml_informant_incorporate","text":"11-7","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_informant_incorporate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtener un informant de pointblank YAML e incorporate() — yaml_informant_incorporate","text":"","code":"if (interactive()) {  # Let's go through the process of # developing an informant with information # about the `small_table` dataset and then # move all that to a pointblank YAML # file; this will later be read in as a # new informant and the target data will # be incorporated into the info text # (in one step) with # `yaml_informant_incorporate()`  # Now create a pointblank `informant` # object; the data will be referenced # in a `read_fn` (a requirement for # writing to YAML) informant <-    create_informant(     read_fn = ~small_table,     label = \"A simple example with the `small_table`.\"   )  # Then, as with any `informant` object, we # can add information by using as many # `info_*()` functions as we want informant <-   informant %>%   info_columns(    columns = vars(a),    info = \"In the range of 1 to 10. (SIMPLE)\"   ) %>%   info_columns(     columns = starts_with(\"date\"),     info = \"Time-based values (e.g., `Sys.time()`).\"   ) %>%   info_columns(     columns = \"date\",     info = \"The date part of `date_time`. (CALC)\"   ) %>%   info_section(     section_name = \"rows\",     row_count = \"There are {row_count} rows available.\"   ) %>%   info_snippet(     snippet_name = \"row_count\",     fn = ~ . %>% nrow()   ) %>%   incorporate()  # The informant can be written to a pointblank # YAML file with `yaml_write()` yaml_write(   informant = informant,   filename = \"informant-small_table.yml\" )  # The 'informant-small_table.yml' file # is available in the package through # `system.file()` yml_file <-    system.file(     \"yaml\", \"informant-small_table.yml\",     package = \"pointblank\"   )  # We can incorporate the data (which # is accessible through the `read_fn`) # into the info text through direct # use of the YAML file with # `yaml_informant_incorporate()` informant <-    yaml_informant_incorporate(filename = yml_file)  class(informant)  # If it's desired to only create a new # informant with the information in place # (stopping short of processing), then the # `yaml_read_informant()` function will # be useful informant <-    yaml_read_informant(filename = yml_file)  class(informant)  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_read_agent.html","id":null,"dir":"Reference","previous_headings":"","what":"Leer un archivo YAML pointblank para crear un objeto agent — yaml_read_agent","title":"Leer un archivo YAML pointblank para crear un objeto agent — yaml_read_agent","text":"yaml_read_agent() can read pointblank YAML file describes validation plan carried agent (typically generated yaml_write() function. returned new agent validation plan, ready interrogate target table (using table-prep formula set read_fn argument). agent can given validation steps needed using interrogate() taking part agent ops (e.g., writing disk outputs intact via x_write_disk() pointblank YAML yaml_write()). get picture yaml_read_agent() interpreting validation plan specified pointblank YAML, can use yaml_agent_show_exprs() function. function shows us (console) pointblank expressions generating described validation plan.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_read_agent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Leer un archivo YAML pointblank para crear un objeto agent — yaml_read_agent","text":"","code":"yaml_read_agent(filename, path = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_read_agent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Leer un archivo YAML pointblank para crear un objeto agent — yaml_read_agent","text":"filename name YAML file contains fields related agent. path optional path YAML file (combined filename).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_read_agent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Leer un archivo YAML pointblank para crear un objeto agent — yaml_read_agent","text":"Un objeto ptblank_agent.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_read_agent.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Leer un archivo YAML pointblank para crear un objeto agent — yaml_read_agent","text":"11-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_read_agent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Leer un archivo YAML pointblank para crear un objeto agent — yaml_read_agent","text":"","code":"if (interactive()) {  # Let's go through the process of # developing an agent with a validation # plan (to be used for the data quality # analysis of the `small_table` dataset), # and then offloading that validation # plan to a pointblank YAML file; this # will be read in with `yaml_read_agent()`  # Creating an `action_levels` object is a # common workflow step when creating a # pointblank agent; we designate failure # thresholds to the `warn`, `stop`, and # `notify` states using `action_levels()` al <-    action_levels(     warn_at = 0.10,     stop_at = 0.25,     notify_at = 0.35   )  # Now create a pointblank `agent` object # and give it the `al` object (which # serves as a default for all validation # steps which can be overridden); the # data will be referenced in a `read_fn` # (a requirement for writing to YAML) agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"A simple example with the `small_table`.\",     actions = al   )  # Then, as with any `agent` object, we # can add steps to the validation plan by # using as many validation functions as we # want agent <-   agent %>%    col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b),     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5)  # The agent can be written to a pointblank # YAML file with `yaml_write()` yaml_write(   agent = agent,   filename = \"agent-small_table.yml\" )  # The 'agent-small_table.yml' file is # available in the package through # `system.file()` yml_file <-    system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   )  # We can view the YAML file in the console # with the `yaml_agent_string()` function yaml_agent_string(filename = yml_file)  # The YAML can also be printed in the console # by supplying the agent as the input yaml_agent_string(agent = agent)  # At some later time, the YAML file can # be read as a new agent with the # `yaml_read_agent()` function agent <- yaml_read_agent(filename = yml_file)  class(agent)  # We can interrogate the data (which # is accessible through the `read_fn`) # with `interrogate()` and get an # agent with intel, or, we can # interrogate directly from the YAML # file with `yaml_agent_interrogate()` agent <-    yaml_agent_interrogate(     filename = yml_file   )  class(agent)  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_read_informant.html","id":null,"dir":"Reference","previous_headings":"","what":"Leer un archivo YAML pointblank para crear un objeto informant — yaml_read_informant","title":"Leer un archivo YAML pointblank para crear un objeto informant — yaml_read_informant","text":"yaml_read_informant() can read pointblank YAML file describes table information (typically generated yaml_write() function. returned new informant object information intact. informant object can given information use info_*() functions.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_read_informant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Leer un archivo YAML pointblank para crear un objeto informant — yaml_read_informant","text":"","code":"yaml_read_informant(filename, path = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_read_informant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Leer un archivo YAML pointblank para crear un objeto informant — yaml_read_informant","text":"filename name YAML file contains fields related informant. path optional path YAML file (combined filename).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_read_informant.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Leer un archivo YAML pointblank para crear un objeto informant — yaml_read_informant","text":"ptblank_informant object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_read_informant.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Leer un archivo YAML pointblank para crear un objeto informant — yaml_read_informant","text":"11-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_read_informant.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Leer un archivo YAML pointblank para crear un objeto informant — yaml_read_informant","text":"","code":"if (interactive()) {  # Create a pointblank `informant` # object with `create_informant()` # and the `small_table` dataset informant <- create_informant(small_table)  # An `informant` object can be written # to a YAML file with the `yaml_write()` # function # yaml_write( #   informant = informant, #   filename = \"informant-small_table.yml\" # )  # The `informant-small_table.yml` file # looks like this when written  #> info_label: '[2020-09-06|13:37:38]' #> table: #>   name: small_table #> _columns: 8 #> _rows: 13 #> _type: tbl_df #> columns: #>   date_time: #>     _type: POSIXct, POSIXt #>   date: #>     _type: Date #>   a: #>     _type: integer #>   b: #>     _type: character #>   c: #>     _type: numeric #>   d: #>     _type: numeric #>   e: #>     _type: logical #>   f: #>     _type: character  # We can add keys and values to # add more pertinent information; with # some direct editing of the file we get:  #> info_label: '[2020-09-06|13:37:38]' #> table: #>   name: small_table #>   _columns: 8 #>   _rows: 13 #>   _type: tbl_df #> columns: #>   date_time: #>     _type: POSIXct, POSIXt #>     info: Date-time values. #>   date: #>     _type: Date #>     info: Date values (the date part of `date_time`). #>   a: #>     _type: integer #>     info: Small integer values (no missing values). #>   b: #>     _type: character #>     info: Strings with a common pattern. #>   c: #>     _type: numeric #>     info: Small numeric values (contains missing values). #>   d: #>     _type: numeric #>     info: Large numeric values (much greater than `c`). #>   e: #>     _type: logical #>     info: TRUE and FALSE values. #>   f: #>     _type: character #>     info: Strings of the set `\"low\"`, `\"mid\"`, and `\"high\"`.  # We could also have done the same # with the `informant` object by use of # the `info_columns()` function  # The 'informant-small_table.yml' file # is available in the package through # `system.file()` yml_file <-    system.file(     \"yaml\", \"informant-small_table.yml\",     package = \"pointblank\"   )  # We can read this YAML file back # as an `informant` object by using # `yaml_read_informant()` informant <-    yaml_read_informant(filename = yml_file)  class(informant)  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_write.html","id":null,"dir":"Reference","previous_headings":"","what":"Escribir objetos pointblank en archivos YAML — yaml_write","title":"Escribir objetos pointblank en archivos YAML — yaml_write","text":"yaml_write() can take different pointblank objects (ptblank_agent, ptblank_informant, tbl_store) write YAML. agent, example, yaml_write() write everything needed specify agent validation plan YAML file. YAML, can modify YAML markup desired, , use create new agent yaml_read_agent() function. agent validation plan ready interrogate() data. can go step perform interrogation directly YAML file yaml_agent_interrogate() function. returns agent intel (already interrogated target data table). informant object can also written YAML yaml_write(). One requirement writing agent informant YAML need table-prep formula (read_fn) specified (R formula used read target table interrogate() incorporate() called). option can set using create_agent()/create_informant() set_read_fn() (useful existing agent informant object).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_write.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Escribir objetos pointblank en archivos YAML — yaml_write","text":"","code":"yaml_write(   ...,   .list = list2(...),   filename = NULL,   path = NULL,   expanded = FALSE,   quiet = FALSE )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_write.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Escribir objetos pointblank en archivos YAML — yaml_write","text":"... mix pointblank objects agent (ptblank_agent), informant (ptblank_informant), table store (tbl_store). agent informant can combined single YAML file (objects value read_fn). table store combined either agent informant must undergo conversion alone. .list Allows use list input alternative .... filename name YAML file create disk. recommended either .yaml .yml extension used file. provided default names used (\"tbl_store.yml\") table store objects get default naming effect \"<object>-<tbl_name>.yml\". path optional path YAML file saved (combined filename). expanded written validation expressions agent expanded tidyselect vars() expressions columns evaluated, yielding validation function per column? default, FALSE expressions written retained YAML representation. quiet function inform file written? default FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_write.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Escribir objetos pointblank en archivos YAML — yaml_write","text":"Invisibly returns TRUE YAML file written.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_write.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Escribir objetos pointblank en archivos YAML — yaml_write","text":"11-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_write.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Escribir objetos pointblank en archivos YAML — yaml_write","text":"","code":"if (interactive()) {  # Let's go through the process of # developing an agent with a validation # plan (to be used for the data quality # analysis of the `small_table` dataset), # and then offloading that validation # plan to a pointblank YAML file  # Creating an `action_levels` object is a # common workflow step when creating a # pointblank agent; we designate failure # thresholds to the `warn`, `stop`, and # `notify` states using `action_levels()` al <-    action_levels(     warn_at = 0.10,     stop_at = 0.25,     notify_at = 0.35   )  # Now create a pointblank `agent` object # and give it the `al` object (which # serves as a default for all validation # steps which can be overridden); the # data will be referenced in a `read_fn` # (a requirement for writing to YAML) agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"A simple example with the `small_table`.\",     actions = al   )  # Then, as with any `agent` object, we # can add steps to the validation plan by # using as many validation functions as we # want agent <-   agent %>%    col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b), regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5)  # The agent can be written to a pointblank # YAML file with `yaml_write()` yaml_write(   agent,   filename = \"agent-small_table.yml\" )  # The 'agent-small_table.yml' file is # available in the package through # `system.file()` yml_file <-    system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   )  # We can view the YAML file in the console # with the `yaml_agent_string()` function yaml_agent_string(filename = yml_file)  # The YAML can also be printed in the console # by supplying the agent as the input yaml_agent_string(agent = agent)  # At some later time, the YAML file can # be read as a new agent with the # `yaml_read_agent()` function agent <-    yaml_read_agent(filename = yml_file)  class(agent)  # We can interrogate the data (which # is accessible through the `read_fn`) # with `interrogate()` and get an # agent with intel, or, we can # interrogate directly from the YAML # file with `yaml_agent_interrogate()` agent <-    yaml_agent_interrogate(filename = yml_file)  class(agent)  }"},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"pointblank-090","dir":"Changelog","previous_headings":"","what":"pointblank 0.9.0","title":"pointblank 0.9.0","text":"CRAN release: 2021-10-28","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"new-features-0-9-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.9.0","text":"new rows_complete() validation function (along expect_rows_complete() test_rows_complete() expectation test variants) check whether rows contain NA/NULL values (optionally constrained selection specified columns). new function serially() (along expect_serially() test_serially()) allows series tests run sequence either culminating final validation step simply exiting series. construction allows pre-testing may make sense validation step. example, may situations ’s vital check column type performing validation column. specially()/expect_specially()/test_specially() functions enable custom validations/tests/expectations user-defined function. still preconditions common args available convenience. great thing require UDF return logical vector passing/failing test units (table rightmost column logical), can incorporate results quite easily standard pointblank reporting. info_columns_from_tbl() function super-convenient wrapper info_columns() function. Say ’re making data dictionary informant already table metadata somewhere table: can use call info_columns() many, many times. Added game_revenue_info dataset contains metadata extant game_revenue dataset. datasets pair nicely together examples create data dictionary create_informant() info_columns_from_tbl(). Added table transformer function tt_tbl_colnames() get table’s column names validation.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"minor-improvements-and-bug-fixes-0-9-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"pointblank 0.9.0","text":"Input data tables label attribute values columns displayed ‘Variables’ section scan_data() report. useful scanning imported SAS tables (often labeled variables). all_passed() function improved failed validation steps (return evaluation error, perhaps missing column) result FALSE; argument added all_passed() optionally get subset validation steps evaluation. expect_*() functions can handle multiple columns, pointblank now correctly stops first failure provides correct reporting . Passing multiple columns really mean processing multiple steps serial, previously handled incorrectly.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"pointblank-080","dir":"Changelog","previous_headings":"","what":"pointblank 0.8.0","title":"pointblank 0.8.0","text":"CRAN release: 2021-07-25","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"new-features-0-8-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.8.0","text":"new draft_validation() function create starter validation .R .Rmd file just table input. Uses new ‘column roles’ feature develop starter set validation steps based kind data columns contain (e.g., latitude/longitude values, URLs, email addresses, etc.). validation function col_vals_within_spec() (variants expect_col_vals_within_spec() test_col_vals_within_spec()) test column values specification like phone numbers (\"phone\"), VIN numbers (\"VIN\"), URLs (\"url\"), email addresses (\"email\"), much (\"isbn\", \"postal_code[<country_code>]\", \"credit_card\", \"iban[<country_code>]\", \"swift\", \"ipv4\", \"ipv6\", \"mac\"). large cross section row-based validation functions can now operate segments target table, can run particular validation slices (segments) target table. segmentation made possible use new segments argument, takes expression serves segment target table column values. can given one two ways: (1) single multiple column names containing keys segment , (2) two-sided formula LHS holds column name RHS contains column values segment (allowing subset keys segmentation). default printing multiagent object now stacked display agent reports. wide report (useful comparisons validations targeting table time) available improved get_multiagent_report() function (display_mode = \"wide\"). Exporting reporting now much easier new export_report() function. export objects agent (validations), informant (table metadata), multiagent (series validations), , also objects containing customized reports (scan_data(), get_agent_report(), get_informant_report(), get_multiagent_report()). ’ll always get self-contained HTML file report use export_report(). new family functions added pointblank: Table Transformers! functions can radically transform data table either provide wholly different table (like summary table table properties table) useful filtering single step. can useful preparing target table validation creating temporary tables (preconditions) validation steps (e.g., validating table properties string lengths). nice bonus transformer functions work equally well data frames, database tables, Spark tables. included functions : tt_summary_stats(), tt_string_info(), tt_tbl_dims(), tt_time_shift(), tt_time_slice(). Two new datasets added: specifications game_revenue. former dataset can used test col_vals_within_spec() validation function. latter dataset (2,000 rows) can used experiment tt_time_shift() tt_time_slice() table transformer functions.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"minor-improvements-and-bug-fixes-0-8-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"pointblank 0.8.0","text":"Added Polish (\"pl\"), Danish (\"da\"), Turkish (\"tr\"), Swedish (\"sv\"), Dutch (\"nl\") translations. scan_data() function now bit performant, testable, better communicating progress generating report. preconditions argument, used modify target table validation step, now improved (1) checking table object returned evaluation, (2) correcting YAML writing preconditions expression ’s provided function. x_write_disk() x_read_disk() extended allow writing reading ptblank_tbl_scan objects (returned scan_data()). Print methods received love release. Now, scan_data() table scan reports look much better R Markdown. Reporting objects get_agent_report(), get_informant_report(), get_multiagent_report() now print methods work beautifully R Markdown result. incorporate() function, called informant object, now emits styled messages console. using yaml_exec() process arbitrary amount YAML-based agents informants, ’ll given information progress console.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"documentation-0-8-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"pointblank 0.8.0","text":"Many help files overhauled (1) things clearer, (2) details provided (things complex), (3) many ready--run examples present. functions improved help release : all_passed(), get_data_extracts(), get_multiagent_report(), get_sundered_data(), has_columns(), write_testthat_file(), x_write_disk(), yaml_exec().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"pointblank-070","dir":"Changelog","previous_headings":"","what":"pointblank 0.7.0","title":"pointblank 0.7.0","text":"CRAN release: 2021-03-09","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"new-features-0-7-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.7.0","text":"New functions set-based interrogations: col_vals_make_set() (+ expect_col_vals_make_set() test_col_vals_make_set()) col_vals_make_subset() (+ expect_col_vals_make_subset() test_col_vals_make_subset()); answer following two questions: (1) set values entirely accounted column values?, (2) set values subset column values? New functions order-based interrogations: col_vals_increasing() (+ expect_col_vals_increasing() test_col_vals_increasing()) col_vals_decreasing() (+ expect_col_vals_decreasing() test_col_vals_decreasing()); check column values either increasing decreasing options allow non-moving values backtracking (threshold). Several functions added facilitate multi-agent workflows: create_multiagent(), read_disk_multiagent(), get_multiagent_report(); workflows help track interrogation results across multiple agents reporting scales well several dozens agents. new function write_testthat_file() generates testthat test file puts tests/testthat certain conditions met; converts agent’s validation plan separate expect_*() statements. New functions tbl_store(), tbl_source(), tbl_get() functions added centrally managing table-prep formulas. Added yaml_exec() function processes relevant pointblank YAML files directory; execution involves interrogation agents (given YAML agents) incorporation informants (given YAML informants), saving processed objects output directory. new functions file_tbl() helper from_github() make easy generate table compatible data file; file form CSV, TSV, RDA, RDS. Several functions added modifying agent’s validation plan: activate_steps(), deactivate_steps(), remove_steps(). Added snip_stats() function generating -line statistical summary information report. Add sorting options snip_list() can choose sort column items frequency sequentially (alphabetically/numerically). improvements made snip_list() : (1) better default appearance, (2) enable customization, (3) include localization options supported spoken languages. Added several options customizing main reporting heading three reporting objects: agent report, information report, multiagent report. active argument every validation function can now take expression evaluates logical; has_columns() added make easy express active whether one columns present target table (e.g., perform validation step target column available). Added support using Arrow tables target tables informant objects.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"documentation-0-7-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"pointblank 0.7.0","text":"Added information YAML representations validation functions several functions make appearance YAML. General improvements function documentation made wide cross section exported functions.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"minor-improvements-and-bug-fixes-0-7-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"pointblank 0.7.0","text":"Included method writing informant object disk (x_write_disk()). Many fixes made tests added ensure agents survive YAML roundtrip (agent %>% yaml_write() yaml_read_agent() creates agent object). Updated several internal dplyr::arrange() statements used scan_data() warnings aren’t issued dbplyr (table scans operating tbl_dbi objects). tidyselect expressions used agents now preserved agent written YAML.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"pointblank-060","dir":"Changelog","previous_headings":"","what":"pointblank 0.6.0","title":"pointblank 0.6.0","text":"CRAN release: 2020-11-20","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"pointblank-information-0-6-0","dir":"Changelog","previous_headings":"","what":"Pointblank Information","title":"pointblank 0.6.0","text":"new information management workflow full features help describe tables keep top changes . make work well, new character enters: informant! Added create_informant() function create ptblank_informant object (function similar create_agent()). meant hold information (much want, really) target table, reporting features geared toward communication. Functions facilitating entry info text added need (info_tabular(), info_columns(), info_section()). focused describing columns, table proper, misc. fields. wasn’t enough, release adds info_snippet() round collection info_*() functions workflow. Oh, hang , ’s also -important incorporate() function. ? explain, idea methodology acquiring important bits data target table (’s info_snippet()’s job) use incorporate() grab morsels data stitch info text (via { }). Added get_informant_report() function printing information report (gt table object!). can also just print informant object show information report thanks print method purpose. informant object can written pointblank YAML using revised yaml_write() (previously agent_yaml_write()) function. can actually write agent informant YAML file useful since objects share target table. Reading done yaml_read_agent() yaml_read_informant() functions. informant can emailed using email_create() function; emailing can done one eight languages stock message text.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"translations-and-locales-0-6-0","dir":"Changelog","previous_headings":"","what":"Translations and Locales","title":"pointblank 0.6.0","text":"text agent report translated now. Improved Spanish (Spain) translation. Added Portuguese (\"pt\", Brazil), Chinese (\"zh\", China mainland), Russian (\"ru\") translations. Added locale option reporting; locale match language (using base locale) unless different locale specified. locale used format numeric values according locale’s rules. also applies reporting offered scan_data() function. stock email message parts (used emailing agent report information report) translated eight supported languages. language setting respective objects used determine language stock message parts.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"breaking-changes-0-6-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"pointblank 0.6.0","text":"yaml_write() function replaces agent_yaml_write() function. new function works write agent, informant object, , YAML. names YAML functions changed, final roster now consists : yaml_write(), yaml_read_agent(), yaml_read_informant(), yaml_agent_interrogate(), yaml_agent_string(), yaml_agent_show_exprs(). x_write_disk() function replaces agent_write() function. new function works write agent informant object disk. x_read_disk() function replaces agent_read() function. new function works read agent informant objects written disk. email_preview() function renamed email_create().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"new-features-0-6-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.6.0","text":"new db_tbl() function makes ridiculously easy access database table selection databases pointblank supports validation; accessible supplied keywords \"postgres\" (PostgreSQL), \"mysql\" (MySQL), \"maria\" (MariaDB), \"duckdb\" (DuckDB), \"sqlite\" (SQLite), , driver function ’d like supply. Added log4r_step() function can used action action_levels() function call (.e., list component fns list). can place call function every condition produce log entry (.e., warn, stop, notify).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"documentation-0-6-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"pointblank 0.6.0","text":"Added several articles explain different validation workflows (six ’em) articles go Information Management workflow. Improved documentation almost functions package; added useful examples. Added table project README keeps everyone apprised project milestones issues closed upcoming release.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"minor-improvements-and-bug-fixes-0-6-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"pointblank 0.6.0","text":"Improved appearance agent report: (1) tooltips, (2) tooltips much improved (animate, larger text, snappier previous ones), (3) SVGs now used symbols validation steps instead blurry PNGs, (4) less confusing glyphs now used TBL column, (5) agent label can expressed Markdown looks nicer report, (6) table type (name, supplied tbl_name) shown header, (7) validation threshold levels also shown table header, (8) interrogation starting/ending timestamps shown (along duration) table footer, (9) table font changed less default-y, (10) adjustments table borders cell shading made better readability. get_agent_report() function now lang locale arguments override values set prior (e.g., create_agent()). allows reporting language changed without need re-run everything scratch. set_tbl(), remove_tbl(), set_read_fn(), remove_read_fn() functions can now also used informant object. get_sundered_data() function clear regard validation steps considered splitting data. Using validation steps preconditions must fulfill rule target table single form across steps. is_exact argument new col_schema_match(), expect_col_schema_match(), test_col_schema_match() functions, allowing types validations less stringent. argument loosens requirement include class names column may multiple. Also, can specify NULL entirely skip checking class/type. can now use combinations validation functions conjointly(). validation functions intrinsically operate single test unit (e.g., col_is_*() functions) now work combination validation functions operate n test units (e.g., col_vals_*() functions). lets us test condition columns certain type individual test units fulfill col_vals_*() requirements. Simplified sections argument scan_data() length-1 character vector containing key characters standing section names. Refactored large portion code produces agent report increase rendering speed. Improved printing errors/warnings (tooltips EVAL column agent report) thanks implementation HTML escaping. small version agent report (perfect emailing) now much improved formatting.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"pointblank-052","dir":"Changelog","previous_headings":"","what":"pointblank 0.5.2","title":"pointblank 0.5.2","text":"CRAN release: 2020-08-28 Fixes performance issue validations larger tables. Improved formatting value ranges agent report.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"pointblank-051","dir":"Changelog","previous_headings":"","what":"pointblank 0.5.1","title":"pointblank 0.5.1","text":"CRAN release: 2020-08-27 Improved compatibility validations performed SQL Server 2019. Integrated label argument validation functions; label available agent x_list , importantly, displayed agent report (STEP column). Added \"combined\" option get_sundered_data() function (type argument). applies categorical (pass/fail) label (settable new pass_fail argument function) new .pb_combined flag column output table. Made several visual improvements agent report.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"pointblank-050","dir":"Changelog","previous_headings":"","what":"pointblank 0.5.0","title":"pointblank 0.5.0","text":"CRAN release: 2020-08-12","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"new-features-0-5-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.5.0","text":"agent can now given table-reading function, used reading data interrogation. tbl provided, function invoked. However, tbl read_fn specified, supplied tbl take priority (useful one-shot interrogations table interactive context). two ways specify read_fn: (1) using function (e.g., function() { <table reading code> }) , (2) R formula expression (e.g., ~ { <table reading code> }). Added set functions setting removing agent’s association data table (set_tbl() remove_tbl()) table-reading function (set_read_fn() remove_read_fn()). validation functions now step_id parameter. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. Supplying step_id optional; pointblank automatically generate step ID value (based step index) ’s provided. Added new functions reading writing YAML (, called pointblank YAML). pointblank YAML file can generated agent using agent_yaml_write() function. ’re always free create pointblank YAML hand, , can edit/extend existing pointblank YAML file. agent can created pointblank YAML agent_yaml_read() function. ’s also possible interrogate target data table right pointblank YAML using agent_yaml_interrogate(). agent_write() agent_read() functions added; allow saving agent disk reading agent back disk. Saved--disk agents still retain validation plans, intel interrogations, reference target table (read_fn value) even entire target table (requested). Reading agent disk agent_read() allows us use post-interrogation functions (e.g., get_agent_x_list(), get_data_extracts(), get_agent_report(), etc.) though interrogation just occurred. pointblank now compatible Spark DataFrames sparklyr package. Simply use tbl_spark object specifying target table create_agent(), set_tbl(), scan_data().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"minor-improvements-and-bug-fixes-0-5-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"pointblank 0.5.0","text":"issue showing agent report table email message body via email_blast() function resolved. Resolved issue using literal character values comparison-based validation functions (e.g., col_vals_between(), col_vals_gt(), etc.). Completely rewrote underlying processes storage retrieval translation text. Much improved translations reporting text Spanish German languages. Thanks @pachamaltese @DavZim valuable contributions! New testthat tests added test pointblank validations mock PostgreSQL MySQL database tables via dittodb package. Thank @pachamaltese implementing tests.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"pointblank-040","dir":"Changelog","previous_headings":"","what":"pointblank 0.4.0","title":"pointblank 0.4.0","text":"CRAN release: 2020-06-22","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"new-r-markdown-features-0-4-0","dir":"Changelog","previous_headings":"","what":"New R Markdown features","title":"pointblank 0.4.0","text":"New R Markdown validation feature allows validation testing within specialized validation code chunks validate = TRUE option set. Using pointblank validation functions data marked code chunks flag overall failure stop threshold exceeded anywhere. errors reported validation code chunk rendering document HTML, green red status buttons indicate whether validations succeeded failures occurred. Clicking button reveals otherwise hidden validation statements error messages (). Using pointblank R Markdown workflow enabled default pointblank library loaded. framework testing set default, new validate_rmd() function offers opportunity set UI logging options. Added R Markdown template new R Markdown validation feature (Pointblank Validation). new stop_if_not() function works well standalone, replacement stopifnot() also customized use validation checks R Markdown documents pointblank loaded. Using stop_if_not() code chunk validate = TRUE option set yield correct reporting successes failures whereas stopifnot() . knit.print() method added facilitate printing agent report table within R Markdown code chunk.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"breaking-changes-0-4-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"pointblank 0.4.0","text":"default behavior using validation step functions (e.g., col_vals_lt()) directly data tables changed. , single test unit failure trigger warning. Now, single test unit failing results error. Going back earlier behavior now requires use actions = warn_on_fail() (new helper function, default warn_at threshold value 1) invocation validation step function. stop_on_fail() helper function also new release, stop_at threshold parameter, also default 1.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"new-features-0-4-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.4.0","text":"Added 24 expectation functions (e.g., expect_col_exists(), expect_rows_distinct(), expect_col_schema_match(), etc.) complements 24 validation functions. can used testthat tests tabular data simplified interface exposes easy--use failure threshold (defaulting 1). Added 24 test functions (e.g., test_col_exists(), test_rows_distinct(), test_col_schema_match(), etc.) complement 24 validation functions. functions return logical value: TRUE threshold (default 1) exceeded, FALSE otherwise. test_*() functions use simplified interface expect_*() functions. Added col_vals_expr(), expect_col_vals_expr(), test_col_vals_expr() validation, expectation, test functions, making easier DIY validations. dplyr expr(), case_when(), () functions re-exported easier accessibility since work exceedingly well new functions. col_schema_match() (expect test analogues) gained new arguments: complete in_order. allow relaxation constraints related completeness ordering columns defined col_schema object (created col_schema()). preconditions argument available validation, expectation, test functions now accepts formula function values (previously, formula values accepted). get_agent_report() function now size argument option get agent report table \"standard\" (width: 875px) size \"small\" size (width: 575px); previously option accessible .... appearance agent report improved ’s gained new features: (1) data extracts failing rows (row-based validation steps) can downloaded CSVs via new buttons appear EXT column, (2) useful tooltips fields table (e.g., hovering items STEP show brief, TBL icons describe whether preconditions applied table prior interrogation, etc.), (3) printing improvements COLUMNS VALUES columns (e.g., table columns distinguished literal values). Improved appearance email message generated email_blast() email_preview(). email message, using stock_msg_body() stock_msg_footer() defaults msg_body msg_footer, embeds \"small\" version agent report provides introductory text nicer formatting .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"documentation-improvements-0-4-0","dir":"Changelog","previous_headings":"","what":"Documentation improvements","title":"pointblank 0.4.0","text":"functions now revised documentation complete, examples, consistent across many validation, expectation, test functions. package README now contains better graphics, reworked examples, new section package’s design goals (listing R packages also focus table validation).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"minor-improvements-and-bug-fixes-0-4-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"pointblank 0.4.0","text":"Rewrote internal stock_stoppage() stock_warning() functions generated error warning messages match whether validation functions used directly data expectation functions used. Console status messages performing interrogation now appear interactive session. longer appear R Markdown rendering execution unattended scripts. col_vals_regex() validation function (plus associated expectation test functions) can now used database tables (DB types support regular expressions). tested MySQL PostgreSQL, differing underlying SQL implementations. col_schema() function now allows either uppercase lowercase SQL column types (using .db_col_types = \"sql\"). Previously, supplying SQL columns types uppercase (e.g., “INT”, “TINYINT”, etc.) always fail validation SQL column types target table captured lowercase values create_agent() call. Many new tests added cover new functions existing functions. ’s important validation package testing comprehensive rigorous, , continue focus forthcoming releases. Fixed duration label bug console status messages appear interrogation (now consistently values reported seconds) Added column validity checks inside internal interrogate_*() functions","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"pointblank-031","dir":"Changelog","previous_headings":"","what":"pointblank 0.3.1","title":"pointblank 0.3.1","text":"Fixed implementation col_vals_between() col_vals_not_between() step functions work tbl_dbi objects. Added scan_data() function, thoroughly scans table data can understand better (giving HTML report). Added get_agent_x_list() function provide easy access agent intel Added get_agent_report() function give fine control agent’s gt-based reportage; also, agent’s default print method now report (default appearance options) Added get_sundered_data() function split table data ‘pass’ ‘fail’ pieces interrogation Added col_schema_match() validation step function; works conjunction col_schema object (generated col_schema() function) help determine whether expected schema matches target table. Added multilingual support reports generated agent validations produced new scan_data() function fully integrates gt (tables reports) blastula (email production delivery) packages Numerous fixes ensure compatibility tibble 3.0.0","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"pointblank-030","dir":"Changelog","previous_headings":"","what":"pointblank 0.3.0","title":"pointblank 0.3.0","text":"CRAN release: 2020-01-10 pointblank package changed significantly previous version favor consistency simplicity, better reporting, increased power. internals extensively refactored API accordingly gone revisions.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"breaking-changes-0-3-0","dir":"Changelog","previous_headings":"","what":"Breaking Changes","title":"pointblank 0.3.0","text":"focus_on() function removed favor directly using data object. means single use create_agent() can now work single table time (create_agent() now tbl argument). Also, input tbl can data.frame, tbl_df, tbl_dbi object. preconditions argument changed can now used temporarily transform table (.e., transforming particular validation step). Previously, option filter input table now ’s possible useful things like joining table, adding columns, filtering rows, etc. preconditions args now accepts list expressions manipulate table data. action_levels() helper function introduced work actions argument (every validation step function). replaces warn_count, stop_count, notify_count, warn_fraction, stop_fraction, notify_fraction arguments. function allows evaluation functions (given fns argument) reaction exceeding thresholds specified warn_at, stop_at, notify_at. using validation step functions directly data (.e., use create_agent()), data now passed straight validation step. purpose now mode create warnings throw errors warn stop thresholds exceeded. Across pointblank validation step functions, argument stands table columns normalized columns. incl_na argument, implemented validation step functions, renamed na_pass better indicate purpose (consider encountered NA values passing test units), , use expanded relevant functions.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"new-features-0-3-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"pointblank 0.3.0","text":"’s now possible use vars() certain tidyselect select helpers (e.g., starts_with()) defining columns pointblank validation step functions. conjointly() function new validation step function allows multiple rowwise validation steps performed joint validity testing.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"pointblank-021","dir":"Changelog","previous_headings":"","what":"pointblank 0.2.1","title":"pointblank 0.2.1","text":"CRAN release: 2019-09-12 Revisions account API changes tidyr 1.0.0. Incorporates corrections related API changes rlang 0.2.0.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"pointblank-01","dir":"Changelog","previous_headings":"","what":"pointblank 0.1","title":"pointblank 0.1","text":"CRAN release: 2017-08-22 First release.","code":""}]
