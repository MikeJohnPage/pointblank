<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="description" content="La función de validación col_vals_make_subset(), la función de expectativa
expect_col_vals_make_subset() y la función de prueba
test_col_vals_make_subset() comprueban si todos los valores de set se ven
al menos una vez en una columna de tabla. La función de validación se puede
usar directamente en una tabla de datos o con un objeto agent
(técnicamente, un objeto ptblank_agent) mientras que las funciones de
expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de
tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles,
tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada
paso de validación o expectativa operará sobre el número de unidades de
prueba que es igual al número de elementos en el set."><title>¿Es un conjunto de valores un subconjunto de una columna de valores? — col_vals_make_subset • pointblank</title><!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png"><link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png"><link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png"><link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png"><link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png"><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.1.0/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.1.0/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- bootstrap-toc --><script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="¿Es un conjunto de valores un subconjunto de una columna de valores? — col_vals_make_subset"><meta property="og:description" content="La función de validación col_vals_make_subset(), la función de expectativa
expect_col_vals_make_subset() y la función de prueba
test_col_vals_make_subset() comprueban si todos los valores de set se ven
al menos una vez en una columna de tabla. La función de validación se puede
usar directamente en una tabla de datos o con un objeto agent
(técnicamente, un objeto ptblank_agent) mientras que las funciones de
expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de
tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles,
tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada
paso de validación o expectativa operará sobre el número de unidades de
prueba que es igual al número de elementos en el set."><meta property="og:image" content="https://rich-iannone.github.io/pointblank/es/logo.svg"><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-default navbar-expand-lg bg-light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">pointblank</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.9.0.9000</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-2">
      <ul class="navbar-nav me-auto"><li class="nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <h6 class="dropdown-header" data-toc-skip>Validation Workflows</h6>
    <a class="dropdown-item" href="../articles/validation_workflows.html">Overview</a>
    <a class="dropdown-item" href="../articles/VALID-I.html">VALID-I: Data Quality Reporting</a>
    <a class="dropdown-item" href="../articles/VALID-II.html">VALID-II: Pipeline Data Validation</a>
    <a class="dropdown-item" href="../articles/VALID-III.html">VALID-III: Expectations in Unit Tests</a>
    <a class="dropdown-item" href="../articles/VALID-IV.html">VALID-IV: Data Tests for Conditionals</a>
    <a class="dropdown-item" href="../articles/VALID-V.html">VALID-V: Table Scan</a>
    <a class="dropdown-item" href="../articles/VALID-VI.html">VALID-VI: R Markdown Document Validation</a>
    <h6 class="dropdown-header" data-toc-skip>Information Management</h6>
    <a class="dropdown-item" href="../articles/INFO-1.html">Intro to Information Management</a>
    <a class="dropdown-item" href="../articles/INFO-2.html">Advanced Information Management</a>
    <a class="external-link dropdown-item" href="https://rich-iannone.github.io/pointblank">In English</a>
  </div>
</li>
<li class="active nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">News</a>
</li>
      </ul><form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off"></form>

      <ul class="navbar-nav"><li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/rich-iannone/pointblank/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div>

    
  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.svg" class="logo" alt=""><h1>¿Es un conjunto de valores un subconjunto de una columna de valores?</h1>
      <small class="dont-index">Source: <a href="https://github.com/rich-iannone/pointblank/blob/HEAD/R/col_vals_make_subset.R" class="external-link"><code>R/col_vals_make_subset.R</code></a></small>
      <div class="d-none name"><code>col_vals_make_subset.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>La función de validación <code>col_vals_make_subset()</code>, la función de expectativa
<code>expect_col_vals_make_subset()</code> y la función de prueba
<code>test_col_vals_make_subset()</code> comprueban si todos los valores de <code>set</code> se ven
al menos una vez en una columna de tabla. La función de validación se puede
usar directamente en una tabla de datos o con un objeto <em>agent</em>
(técnicamente, un objeto <code>ptblank_agent</code>) mientras que las funciones de
expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de
tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles,
tablas de base de datos (<code>tbl_dbi</code>) y Spark DataFrames (<code>tbl_spark</code>). Cada
paso de validación o expectativa operará sobre el número de unidades de
prueba que es igual al número de elementos en el <code>set</code>.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="fu">col_vals_make_subset</span><span class="op">(</span>
  <span class="va">x</span>,
  <span class="va">columns</span>,
  <span class="va">set</span>,
  preconditions <span class="op">=</span> <span class="cn">NULL</span>,
  segments <span class="op">=</span> <span class="cn">NULL</span>,
  actions <span class="op">=</span> <span class="cn">NULL</span>,
  step_id <span class="op">=</span> <span class="cn">NULL</span>,
  label <span class="op">=</span> <span class="cn">NULL</span>,
  brief <span class="op">=</span> <span class="cn">NULL</span>,
  active <span class="op">=</span> <span class="cn">TRUE</span>
<span class="op">)</span>

<span class="fu">expect_col_vals_make_subset</span><span class="op">(</span>
  <span class="va">object</span>,
  <span class="va">columns</span>,
  <span class="va">set</span>,
  preconditions <span class="op">=</span> <span class="cn">NULL</span>,
  threshold <span class="op">=</span> <span class="fl">1</span>
<span class="op">)</span>

<span class="fu">test_col_vals_make_subset</span><span class="op">(</span>
  <span class="va">object</span>,
  <span class="va">columns</span>,
  <span class="va">set</span>,
  preconditions <span class="op">=</span> <span class="cn">NULL</span>,
  threshold <span class="op">=</span> <span class="fl">1</span>
<span class="op">)</span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>
    <dl><dt>x</dt>
<dd><p>Un data.frame, tibble (<code>tbl_df</code> o <code>tbl_dbi</code>), Spark DataFrame
(<code>tbl_spark</code>), o un <em>agent</em> objeto de clase <code>ptblank_agent</code> que se crea
con <code><a href="create_agent.html">create_agent()</a></code>.</p></dd>
<dt>columns</dt>
<dd><p>La columna (o un conjunto de columnas, proporcionado como un
vector de caracteres) a la que se debe aplicar esta validación.</p></dd>
<dt>set</dt>
<dd><p>A vector of elements that is expected to be a subset of the unique
values in the target column.</p></dd>
<dt>preconditions</dt>
<dd><p>Una expresión opcional para mutar la tabla de entrada
antes de continuar con la validación. Esto se puede proporcionar como una
fórmula R unilateral usando un <code>~</code> inicial (por ejemplo,
<code>~ . %&gt;% dplyr::mutate(col = col + 10)</code> o como una función (por ejemplo,
<code>function (x) dplyr::mutate(x, col = col + 10)</code>. Consulte la sección
<em>Preconditions</em> para obtener más información.</p></dd>
<dt>segments</dt>
<dd><p>Una expresión opcional o un conjunto de expresiones
(contenidas en una lista) que sirven para segmentar la tabla de destino por
valores de columna. Cada expresión se puede dar de una de dos maneras: (1)
como nombres de columna, o (2) como una fórmula de dos lados donde el LHS
contiene un nombre de columna y el RHS contiene los valores de columna para
segmentar. Consulte la sección <em>Segments</em> para obtener más detalles sobre
esto.</p></dd>
<dt>actions</dt>
<dd><p>Una lista que contiene los niveles de umbral para que el paso
de validación pueda reaccionar en consecuencia al superar los niveles
establecidos. Esto se creará con la función auxiliar <code><a href="action_levels.html">action_levels()</a></code>.</p></dd>
<dt>step_id</dt>
<dd><p>Uno o más identificadores opcionales para los pasos de
validación únicos o múltiples generados al llamar a una función de
validación. El uso de ID de pasos sirve para distinguir los pasos de
validación entre sí y brinda la oportunidad de proporcionar una etiqueta
más significativa en comparación con el índice de pasos. De forma
predeterminada, es <code>NULL</code>, y <strong>pointblank</strong> generará automáticamente el
valor de ID de paso (basado en el índice de paso) en este caso. Se pueden
proporcionar uno o más valores, y el número exacto de valores de ID debe
(1) coincidir con el número de pasos de validación que producirá la llamada
a la función de validación (influenciado por el número de <code>columns</code>
proporcionadas), (2) ser un ID cadena no utilizada en ningún paso de
validación anterior, y (3) ser un vector con valores únicos.</p></dd>
<dt>label</dt>
<dd><p>Una etiqueta opcional para el paso de validación. Esta etiqueta
aparece en el informe del <em>agent</em> y, para una mejor apariencia, debe ser
breve.</p></dd>
<dt>brief</dt>
<dd><p>Una descripción opcional basada en texto para el paso de
validación. Si no se proporciona nada aquí, el objeto <em>agent</em> genera un
<em>autobrief</em>, utilizando el lenguaje proporcionado en el argumento <code>lang</code> de
<code><a href="create_agent.html">create_agent()</a></code> (que por defecto es <code>"en"</code> o inglés). El <em>autobrief</em>
incorpora detalles del paso de validación, por lo que a menudo es la opción
preferida en la mayoría de los casos (donde un <code>label</code> podría ser más
adecuada para describir sucintamente la validación).</p></dd>
<dt>active</dt>
<dd><p>Un valor lógico que indica si el paso de validación debe estar
activo. Si la función de validación está trabajando con un objeto <em>agent</em>,
<code>FALSE</code> hará que el paso de validación esté inactivo (aún informando su
presencia y manteniendo los índices de los pasos sin cambios). Si la
función de validación operará directamente en los datos (sin participación
de <em>agent</em>), entonces cualquier paso con <code>active = FALSE</code> simplemente
pasará los datos sin validación alguna. Aparte de un vector lógico, una
fórmula R unilateral que usa un <code>~</code> inicial se puede usar con <code>.</code> (que
sirve como la tabla de datos de entrada) para evaluar a un solo valor
lógico. Con este enfoque, la función <strong>pointblank</strong> <code><a href="has_columns.html">has_columns()</a></code> se
puede utilizar para determinar si se debe activar un paso de validación
sobre la base de una o más columnas existentes en la tabla (por ejemplo,
<code>~ . %&gt;% has_columns(vars(d, e))</code>). El valor predeterminado de <code>active</code> es
<code>TRUE</code>.</p></dd>
<dt>object</dt>
<dd><p>Un data.frame, tibble (<code>tbl_df</code> o <code>tbl_dbi</code>) o Spark DataFrame
(<code>tbl_spark</code>) que sirve como tabla de destino para la función de
expectativa o la función de prueba.</p></dd>
<dt>threshold</dt>
<dd><p>Un valor de umbral de falla simple para usar con las
variantes de función expectativa (<code>expect_</code>) y prueba (<code>test_</code>). De
forma predeterminada, se establece en <code>1</code>, lo que significa que cualquier
unidad de falla en la validación de datos da como resultado una falla
general de la prueba. Los números enteros más allá de <code>1</code> indican que
cualquier unidad defectuosa hasta ese valor de umbral absoluto dará como
resultado una <strong>thatthat</strong> prueba o evalúe como <code>TRUE</code>. Asimismo,
los valores fraccionarios (entre <code>0</code> y <code>1</code>) actúan como un umbral de falla
proporcional, donde <code>0.15</code> significa que el <code>15</code> por ciento de las unidades
de prueba que fallan dan como resultado una falla general de la prueba.</p></dd>
</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    <p>Para la función de validación, el valor de retorno es un objeto
<code>ptblank_agent</code> o un objeto de tabla (dependiendo de si se pasó un objeto
<em>agent</em> o una tabla a <code>x</code>). La función de expectativa devuelve
invisiblemente su entrada pero, en el contexto de los datos de prueba, la
función se llama principalmente por sus posibles efectos secundarios (por
ejemplo, falla de señalización). La función de prueba devuelve un valor
lógico.</p>
    </div>
    <div class="section level2">
    <h2 id="nombres-de-columnas">Nombres de columnas<a class="anchor" aria-label="anchor" href="#nombres-de-columnas"></a></h2>
    

<p>Si proporciona varios nombres de columna, el resultado será una expansión de
pasos de validación para ese número de nombres de columna (por ejemplo,
<code>vars(col_a, col_b)</code> dará lugar a la entrada de dos pasos de validación).
Aparte de los nombres de las columnas en comillas y en <code><a href="https://dplyr.tidyverse.org/reference/vars.html" class="external-link">vars()</a></code>,
<strong>tidyselect</strong> funciones auxiliares están disponibles para especificando
columnas. Ellos son: <code><a href="https://tidyselect.r-lib.org/reference/starts_with.html" class="external-link">starts_with()</a></code>, <code><a href="https://tidyselect.r-lib.org/reference/starts_with.html" class="external-link">ends_with()</a></code>, <code><a href="https://tidyselect.r-lib.org/reference/starts_with.html" class="external-link">contains()</a></code>,
<code><a href="https://tidyselect.r-lib.org/reference/starts_with.html" class="external-link">matches()</a></code>, y <code><a href="https://tidyselect.r-lib.org/reference/everything.html" class="external-link">everything()</a></code>.</p>
    </div>
    <div class="section level2">
    <h2 id="preconditions">Preconditions<a class="anchor" aria-label="anchor" href="#preconditions"></a></h2>
    

<p>Proporcionar expresiones como <code>preconditions</code> significa que <strong>pointblank</strong>
preprocesará la tabla de destino durante la interrogación como paso
preparatorio. Puede suceder que una validación en particular requiera una
columna calculada, algún filtrado de filas o la adición de columnas a través
de una combinación, etc. Especialmente para un informe basado en <em>agent</em>,
esto puede ser ventajoso ya que podemos desarrollar un gran plan de
validación con una sola tabla de destino y realice ajustes menores en ella,
según sea necesario, a lo largo del camino.</p>
<p>La mutación de la tabla está totalmente aislada en el alcance de los pasos de
validación en los que se utilizan las <code>preconditions</code>. Aquí se sugiere
usar el código <strong>dplyr</strong> ya que las declaraciones se pueden traducir a SQL
si es necesario (es decir, si la tabla de destino reside en una base de
datos). El código se proporciona más fácilmente como una fórmula <strong>R</strong>
unilateral (utilizando un <code>~</code> inicial). En la representación de la fórmula,
el <code>.</code> sirve como la tabla de datos de entrada que se va a transformar (por
ejemplo, <code>~ . %&gt;% dplyr::mutate(col_b = col_a + 10)</code>). Alternativamente, se
podría proporcionar una función (por ejemplo,
<code>function(x) dplyr::mutate(x, col_b = col_a + 10)</code>).</p>
    </div>
    <div class="section level2">
    <h2 id="segmentos">Segmentos<a class="anchor" aria-label="anchor" href="#segmentos"></a></h2>
    

<p>Al usar el argumento <code>segments</code>, es posible definir una validación particular
con segmentos (o porciones de fila) de la tabla de destino. Una expresión
opcional o un conjunto de expresiones que sirven para segmentar la tabla de
destino por valores de columna. Cada expresión se puede dar de una de dos
maneras: (1) como nombres de columna, o (2) como una fórmula de dos lados
donde el LHS contiene un nombre de columna y el RHS contiene los valores de
columna para segmentar.</p>
<p>Como ejemplo del primer tipo de expresión que se puede utilizar,
<code>vars(a_column)</code> segmentará la tabla de destino en la forma en que estén
presentes muchos valores únicos en la columna llamada <code>a_column</code>. Esto es
excelente si cada valor único en una columna en particular (como diferentes
ubicaciones o diferentes fechas) requiere su propia validación repetida.</p>
<p>Con una fórmula, podemos ser más selectivos con los valores de columna que se
deben usar para la segmentación. El uso de <code>a_column ~ c("group_1", "group_2")</code> intentará obtener dos segmentos donde uno es una porción de datos
donde el valor <code>"group_1"</code> existe en la columna llamada <code>"a_column"</code>, y el
otro es un segmento donde existe <code>"group_2"</code> en la misma columna. Cada grupo
de filas resuelto a partir de la fórmula dará como resultado un paso de
validación independiente.</p>
<p>Si hay varias <code>columns</code> especificadas, el número potencial de pasos de
validación será <code>m</code> columnas multiplicadas por <code>n</code> segmentos resueltos.</p>
<p>La segmentación siempre ocurrirá después de que se apliquen las
<code>preconditions</code> (es decir, declaraciones que mutan la tabla de destino), si
las hay. Con este tipo de combinación, es posible generar etiquetas
para la segmentación usando una expresión para <code>preconditions</code> y hacer
referencia a esas etiquetas en <code>segments</code> sin tener que generar una versión
separada de la tabla de destino.</p>
    </div>
    <div class="section level2">
    <h2 id="actions">Actions<a class="anchor" aria-label="anchor" href="#actions"></a></h2>
    

<p>A menudo, querremos especificar <code>actions</code> para la validación. Este argumento,
presente en cada función de validación, toma un objeto de lista especialmente
diseñado que es mejor producido por la función <code><a href="action_levels.html">action_levels()</a></code>. Lea la
documentación de esa función para obtener información sobre cómo crear
reacciones a niveles de falla por encima del umbral en la validación. La
esencia básica es que querrá al menos un nivel de umbral único (especificado
como la fracción de unidades de prueba fallidas o un valor absoluto), a
menudo utilizando el argumento <code>warn_at</code>. Esto es especialmente cierto cuando
<code>x</code> es un objeto de tabla porque, de lo contrario, no sucede nada. Para las
funciones de tipo <code>col_vals_*()</code>, usar <code>action_levels(warn_at = 0.25)</code> o
<code>action_levels(stop_at = 0.25)</code> son buenas opciones dependiendo de la
situación (la primera produce una advertencia cuando una cuarta parte de la
prueba total las unidades fallan, las otras <code><a href="https://rdrr.io/r/base/stop.html" class="external-link">stop()</a></code> en el mismo nivel de
umbral).</p>
    </div>
    <div class="section level2">
    <h2 id="briefs">Briefs<a class="anchor" aria-label="anchor" href="#briefs"></a></h2>
    

<p>¿Quiere describir este paso de validación con algún detalle? Tenga en cuenta
que esto sólo es útil si <code>x</code> es un objeto <em>agent</em>. Si ese es el caso, use un
texto <code>brief</code> que se ajuste a la situación. No se preocupe si no quiere
hacerlo. Un <em>autobrief</em> se activa cuando <code>brief = NULL</code> y el texto luego se
generará automáticamente.</p>
    </div>
    <div class="section level2">
    <h2 id="yaml">YAML<a class="anchor" aria-label="anchor" href="#yaml"></a></h2>
    

<p>Se puede escribir un agente <strong>pointblank</strong> en YAML con <code><a href="yaml_write.html">yaml_write()</a></code> y el
YAML resultante se puede usar para regenerar un agente (con
<code><a href="yaml_read_agent.html">yaml_read_agent()</a></code>) o interrogar la tabla de destino (a través de
<code><a href="yaml_agent_interrogate.html">yaml_agent_interrogate()</a></code>). Cuando <code>col_vals_make_subset()</code> se representa en
YAML (bajo la clave de nivel superior <code>steps</code> como un miembro de la lista),
la sintaxis sigue de cerca la firma de la función de validación. A
continuación se muestra un ejemplo de cómo una llamada compleja de
<code>col_vals_make_subset()</code> como paso de validación se expresa en código R y en
la representación YAML correspondiente.</p><div class="sourceCode"><pre><code># Código R
agent %&gt;% 
  col_vals_make_subset(
    columns = vars(a),
    set = c(1, 2, 3, 4),
    preconditions = ~ . %&gt;% dplyr::filter(a &lt; 10),
    segments = b ~ c("group_1", "group_2"),
    actions = action_levels(warn_at = 0.1, stop_at = 0.2),
    label = "El paso `col_vals_make_subset()`.",
    active = FALSE
  )

# Representación YAML
steps:
- col_vals_make_subset:
    columns: vars(a)
   set:
   - 1.0
   - 2.0
   - 3.0
   - 4.0
   preconditions: ~. %&gt;% dplyr::filter(a &lt; 10)
   segments: b ~ c("group_1", "group_2")
   actions:
     warn_fraction: 0.1
     stop_fraction: 0.2
   label: El paso `col_vals_make_subset()`.
   active: false
</code></pre></div>

<p>In practice, both of these will often be shorter as only the <code>columns</code>, and
<code>set</code> arguments require values. Arguments with default values won't be
written to YAML when using <code><a href="yaml_write.html">yaml_write()</a></code> (though it is acceptable to include
them with their default when generating the YAML by other means). It is also
possible to preview the transformation of an agent to YAML without any
writing to disk by using the <code><a href="yaml_agent_string.html">yaml_agent_string()</a></code> function.</p>
    </div>
    <div class="section level2">
    <h2 id="function-id">Function ID<a class="anchor" aria-label="anchor" href="#function-id"></a></h2>
    

<p>2-12</p>
    </div>
    <div class="section level2">
    <h2 id="see-also">See also<a class="anchor" aria-label="anchor" href="#see-also"></a></h2>
    <div class="dont-index"><p>Other validation functions: 
<code><a href="col_exists.html">col_exists</a>()</code>,
<code><a href="col_is_character.html">col_is_character</a>()</code>,
<code><a href="col_is_date.html">col_is_date</a>()</code>,
<code><a href="col_is_factor.html">col_is_factor</a>()</code>,
<code><a href="col_is_integer.html">col_is_integer</a>()</code>,
<code><a href="col_is_logical.html">col_is_logical</a>()</code>,
<code><a href="col_is_numeric.html">col_is_numeric</a>()</code>,
<code><a href="col_is_posix.html">col_is_posix</a>()</code>,
<code><a href="col_schema_match.html">col_schema_match</a>()</code>,
<code><a href="col_vals_between.html">col_vals_between</a>()</code>,
<code><a href="col_vals_decreasing.html">col_vals_decreasing</a>()</code>,
<code><a href="col_vals_equal.html">col_vals_equal</a>()</code>,
<code><a href="col_vals_expr.html">col_vals_expr</a>()</code>,
<code><a href="col_vals_gte.html">col_vals_gte</a>()</code>,
<code><a href="col_vals_gt.html">col_vals_gt</a>()</code>,
<code><a href="col_vals_in_set.html">col_vals_in_set</a>()</code>,
<code><a href="col_vals_increasing.html">col_vals_increasing</a>()</code>,
<code><a href="col_vals_lte.html">col_vals_lte</a>()</code>,
<code><a href="col_vals_lt.html">col_vals_lt</a>()</code>,
<code><a href="col_vals_make_set.html">col_vals_make_set</a>()</code>,
<code><a href="col_vals_not_between.html">col_vals_not_between</a>()</code>,
<code><a href="col_vals_not_equal.html">col_vals_not_equal</a>()</code>,
<code><a href="col_vals_not_in_set.html">col_vals_not_in_set</a>()</code>,
<code><a href="col_vals_not_null.html">col_vals_not_null</a>()</code>,
<code><a href="col_vals_null.html">col_vals_null</a>()</code>,
<code><a href="col_vals_regex.html">col_vals_regex</a>()</code>,
<code><a href="col_vals_within_spec.html">col_vals_within_spec</a>()</code>,
<code><a href="conjointly.html">conjointly</a>()</code>,
<code><a href="row_count_match.html">row_count_match</a>()</code>,
<code><a href="rows_complete.html">rows_complete</a>()</code>,
<code><a href="rows_distinct.html">rows_distinct</a>()</code>,
<code><a href="serially.html">serially</a>()</code>,
<code><a href="specially.html">specially</a>()</code>,
<code><a href="tbl_match.html">tbl_match</a>()</code></p></div>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span class="co"># The `small_table` dataset in the</span></span>
<span class="r-in"><span class="co"># package will be used to validate that</span></span>
<span class="r-in"><span class="co"># column values are part of a given set</span></span>
<span class="r-in"></span>
<span class="r-in"><span class="co"># A: Usando un `agent` con funciones de</span></span>
<span class="r-in"><span class="co">#    validación y luego `interrogate()`</span></span>
<span class="r-in"></span>
<span class="r-in"><span class="co"># Validate that the distinct set of values</span></span>
<span class="r-in"><span class="co"># in column `f` contains at least the</span></span>
<span class="r-in"><span class="co"># subset defined as `low` and `high` (the</span></span>
<span class="r-in"><span class="co"># column actually has both of those and</span></span>
<span class="r-in"><span class="co"># some `mid` values)</span></span>
<span class="r-in"><span class="va">agent</span> <span class="op">&lt;-</span></span>
<span class="r-in">  <span class="fu"><a href="create_agent.html">create_agent</a></span><span class="op">(</span><span class="va">small_table</span><span class="op">)</span> <span class="op"><a href="pipe.html">%&gt;%</a></span></span>
<span class="r-in">  <span class="fu">col_vals_make_subset</span><span class="op">(</span></span>
<span class="r-in">    <span class="fu"><a href="https://dplyr.tidyverse.org/reference/vars.html" class="external-link">vars</a></span><span class="op">(</span><span class="va">f</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"low"</span>, <span class="st">"high"</span><span class="op">)</span></span>
<span class="r-in">  <span class="op">)</span> <span class="op"><a href="pipe.html">%&gt;%</a></span></span>
<span class="r-in">  <span class="fu"><a href="interrogate.html">interrogate</a></span><span class="op">(</span><span class="op">)</span></span>
<span class="r-in">  </span>
<span class="r-in"><span class="co"># Determine if this validation</span></span>
<span class="r-in"><span class="co"># had no failing test units (there</span></span>
<span class="r-in"><span class="co"># are 2 test units, one per element</span></span>
<span class="r-in"><span class="co"># in the `set`)</span></span>
<span class="r-in"><span class="fu"><a href="all_passed.html">all_passed</a></span><span class="op">(</span><span class="va">agent</span><span class="op">)</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] TRUE</span>
<span class="r-in"></span>
<span class="r-in"><span class="co"># Llamar a `agent` en la consola imprime</span></span>
<span class="r-in"><span class="co"># el informe del agente; pero podemos</span></span>
<span class="r-in"><span class="co"># obtener un objeto `gt_tbl` directamente</span></span>
<span class="r-in"><span class="co"># con `get_agent_report(agent)`</span></span>
<span class="r-in"></span>
<span class="r-in"><span class="co"># B: Usando la función de validación</span></span>
<span class="r-in"><span class="co">#    directamente en los datos</span></span>
<span class="r-in"><span class="co">#    (sin `agent`)</span></span>
<span class="r-in"></span>
<span class="r-in"><span class="co"># Esta forma de utilizar las funciones</span></span>
<span class="r-in"><span class="co"># de validación actúa como un filtro de</span></span>
<span class="r-in"><span class="co"># datos: los datos se pasan a través,</span></span>
<span class="r-in"><span class="co"># pero deben `stop()` si hay una sola</span></span>
<span class="r-in"><span class="co"># unidad de prueba que falla; el</span></span>
<span class="r-in"><span class="co"># comportamiento de los efectos</span></span>
<span class="r-in"><span class="co"># secundarios se puede personalizar con</span></span>
<span class="r-in"><span class="co"># la opción `actions`</span></span>
<span class="r-in"><span class="va">small_table</span> <span class="op"><a href="pipe.html">%&gt;%</a></span></span>
<span class="r-in">  <span class="fu">col_vals_make_subset</span><span class="op">(</span></span>
<span class="r-in">    <span class="fu"><a href="https://dplyr.tidyverse.org/reference/vars.html" class="external-link">vars</a></span><span class="op">(</span><span class="va">f</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"low"</span>, <span class="st">"high"</span><span class="op">)</span></span>
<span class="r-in">  <span class="op">)</span> <span class="op"><a href="pipe.html">%&gt;%</a></span></span>
<span class="r-in">  <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/pull.html" class="external-link">pull</a></span><span class="op">(</span><span class="va">f</span><span class="op">)</span> <span class="op"><a href="pipe.html">%&gt;%</a></span></span>
<span class="r-in">  <span class="fu"><a href="https://rdrr.io/r/base/unique.html" class="external-link">unique</a></span><span class="op">(</span><span class="op">)</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "high" "low"  "mid" </span>
<span class="r-in"></span>
<span class="r-in"><span class="co"># C: Usando la función de expectativa</span></span>
<span class="r-in"></span>
<span class="r-in"><span class="co"># Con el formulario `expect_*()`,</span></span>
<span class="r-in"><span class="co"># necesitamos ser más exactos y</span></span>
<span class="r-in"><span class="co"># proporcionar una columna a la vez;</span></span>
<span class="r-in"><span class="co"># esto se usa principalmente en</span></span>
<span class="r-in"><span class="co"># pruebas `testthat`</span></span>
<span class="r-in"><span class="fu">expect_col_vals_make_subset</span><span class="op">(</span></span>
<span class="r-in">  <span class="va">small_table</span>,</span>
<span class="r-in">  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/vars.html" class="external-link">vars</a></span><span class="op">(</span><span class="va">f</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"low"</span>, <span class="st">"high"</span><span class="op">)</span></span>
<span class="r-in"><span class="op">)</span></span>
<span class="r-in"></span>
<span class="r-in"><span class="co"># D: Usando la función de prueba</span></span>
<span class="r-in"></span>
<span class="r-in"><span class="co"># Con la forma `test_*()`, deberíamos</span></span>
<span class="r-in"><span class="co"># obtener un único valor lógico devuelto</span></span>
<span class="r-in"><span class="va">small_table</span> <span class="op"><a href="pipe.html">%&gt;%</a></span></span>
<span class="r-in">  <span class="fu">test_col_vals_make_subset</span><span class="op">(</span></span>
<span class="r-in">    <span class="fu"><a href="https://dplyr.tidyverse.org/reference/vars.html" class="external-link">vars</a></span><span class="op">(</span><span class="va">f</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"low"</span>, <span class="st">"high"</span><span class="op">)</span></span>
<span class="r-in">  <span class="op">)</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] TRUE</span>
<span class="r-in"></span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p></p><p>Developed by Richard Iannone, Mauricio Vargas.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.1.</p>
</div>

    </footer></div>

  

  

  </body></html>

