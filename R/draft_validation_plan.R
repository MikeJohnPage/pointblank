#
#                _         _    _      _                _    
#               (_)       | |  | |    | |              | |   
#  _ __    ___   _  _ __  | |_ | |__  | |  __ _  _ __  | | __
# | '_ \  / _ \ | || '_ \ | __|| '_ \ | | / _` || '_ \ | |/ /
# | |_) || (_) || || | | || |_ | |_) || || (_| || | | ||   < 
# | .__/  \___/ |_||_| |_| \__||_.__/ |_| \__,_||_| |_||_|\_\
# | |                                                        
# |_|                                                        
# 
# This file is part of the 'rich-iannone/pointblank' package.
# 
# (c) Richard Iannone <riannone@me.com>
# 
# For full copyright and license information, please look at
# https://rich-iannone.github.io/pointblank/LICENSE.html
#


#' Draft a starter **pointblank** validation .R script with a data table
#' 
#' @description
#' Generate a draft validation plan in a new .R file using an input data table.
#' Using this workflow, the data table will be scanned to learn about its column
#' data and a set of starter validation steps (constituting a validation plan)
#' will be written. It's best to use a data extract that contains at least 1000
#' rows and is relatively free of spurious data.
#'
#' Once in the .R file, it's possible to tweak the validation steps to better
#' fit the expectations to the particular domain. While column inference is used
#' to generate reasonable validation plans, it is difficult to infer the
#' acceptable values without domain expertise. However, using
#' `draft_validation_plan()` could get you started on floor 10 of tackling data
#' quality issues and is in any case better than starting with an empty code
#' editor view.
#' 
#' @param tbl The input table. This can be a data frame, tibble, a `tbl_dbi`
#'   object, or a `tbl_spark` object.
#' @param name An optional name for the .R file. This should be a name without
#'   an extension. If nothing is supplied, the name will contain the text
#'   `"draft_validation_plan_"` followed by the current date and time.
#' @param path A path can be specified here if there shouldn't be an attempt to
#'   place the .R file in the working directory.
#' @param lang The language to use when creating comments for the automatically-
#'   generated validation steps. By default, `NULL` will create English (`"en"`)
#'   text. Other options include French (`"fr"`), German (`"de"`), Italian
#'   (`"it"`), Spanish (`"es"`), Portuguese, (`"pt"`), Chinese (`"zh"`), Russian
#'   (`"ru"`), and Danish (`"da"`).
#' @param output_type An option for choosing what type of output should be
#'   generated. By default, this is an .R script (`"R"`) but this could
#'   alternatively be an R Markdown document (`"Rmd"`).
#' @param overwrite Should an .R file of the same name be overwritten? By
#'   default, this is `FALSE`.
#' @param quiet Should the function *not* inform when the file is written? By
#'   default this is `FALSE`.
#'   
#' @return Invisibly returns `TRUE` if the file has been written. 
#' 
#' @examples
#' if (interactive()) {
#' 
#' # Draft validation plan for the
#' # `dplyr::storms` dataset
#' draft_validation_plan(tbl = dplyr::storms)
#' 
#' }
#' 
#' @family Planning and Prep
#' @section Function ID:
#' 1-11
#' 
#' @export
draft_validation_plan <- function(tbl,
                                  name = NULL,
                                  path = NULL,
                                  lang = NULL,
                                  output_type = c("R", "Rmd"),
                                  add_comments = TRUE,
                                  overwrite = FALSE,
                                  quiet = FALSE) {
  
  column_roles <- get_column_roles(tbl)
  column_names <- colnames(tbl)
  
  agent <- 
    create_agent(
      tbl = tbl,
      tbl_name = name,
      label = "Validation plan generated by `draft_validation_plan()`.",
      lang = lang
    )
  
  for (i in seq_along(column_roles)) {
    
    agent <- 
      add_col_val_steps_with_role(
        agent = agent,
        column = column_names[i],
        column_role = column_roles[i]
      )
  }
  
  # Try to infer the table name from `tbl`
  if (!is.null(tbl)) {
    read_fn_name <- deparse(match.call()$tbl)
    if (read_fn_name == ".") {
      read_fn_name <- NA_character_
    }
  } 
  
  # Create the filename for the pointblank .R file
  file_name <- resolve_file_filename(agent = agent, name = name)
  
  if (is.null(path)) {
    file_path <- "."
    
  } else {
    
    if (!fs::dir_exists(path)) {
      # Stop function if the path doesn't exist and inform user
      # that this function won't create a path
      stop(
        "The provided `path` does not exist:\n",
        "* Please create the path",
        call. = FALSE
      )
    }
    
    file_path <- path
  }
  
  # Create path that contains the testthat test file name
  path <- as.character(fs::path_norm(fs::path_wd(file_path, file_name)))
  
  # Check if the file to write already exists; if it does, don't
  # write the new file if `overwrite` is FALSE
  if (fs::file_exists(path) && !overwrite) {
    stop(
      "The .R file of the same name already exists:\n",
      "* set `overwrite` to `TRUE`, or\n",
      "* choose a different `name`, or\n",
      "* define another `path` for the file",
      call. = FALSE
    )
  }
  
  # Set a temporary `read_fn`
  agent <- set_read_fn(x = agent, read_fn = "")
  
  # Extract all briefs from the validation steps
  briefs <- agent$validation_set$brief
  
  # Extract all R expressions for the .R file
  agent_exprs <- agent_get_exprs(agent = agent, expanded = TRUE)
  
  agent_exprs <-
    gsub(
      "read_fn = ,\n  tbl_name = \".*?\",",
      paste0(
        "read_fn = ~ ",
        ifelse(is.null(read_fn_name), "CODE_TO_ACCESS_TABLE", read_fn_name),
        ",\n  ",
        "tbl_name = ",
        ifelse(is.null(name), "NULL", paste0("\"", name, "\"")), ","
      ),
      agent_exprs
    )
  
  agent_expr_vec <- unlist(strsplit(agent_exprs, " %>%\n", fixed = TRUE))
  
  if (add_comments) {
    
    agent_expr_vec_2 <- 
      paste(
        paste0("%>%\n  # ", briefs, "\n"),
        paste0(" ", gsub("\n", "\n  ", agent_expr_vec[-1])),
        collapse = "  "
      )
    
  } else {

    agent_expr_vec_2 <- 
      paste(
        paste0("%>%\n"),
        paste0(" ", gsub("\n", "\n  ", agent_expr_vec[-1])),
        collapse = "  "
      )
  }
  
  agent_lines <-
    paste(
      agent_expr_vec[1],
      agent_expr_vec_2,
      collapse = ""
    )
  
  file_content <-
    paste0(
      "library(pointblank)\n\n",
      agent_lines,
      "%>%\n  interrogate()\n",
      collapse = ""
    ) %>%
    gsub("  %>%", " %>%", .)
  
  # Write the testthat file to the resulting `path`
  pb_write_file(
    path = path,
    lines = file_content,
    append = FALSE
  )
  
  # Generate cli message w.r.t. written YAML file
  if (!quiet) {
    cli_bullet_msg(
      msg = "The pointblank .R file has been written to `{path}`",
      bullet = cli::symbol$tick,
      color = "green"
    )
  }
  
  invisible(TRUE)
}

add_col_val_steps_with_role <- function(agent, column, column_role) {

  if (grepl("string", column_role)) {
    
    if (inherits(agent$tbl, "data.frame") && 
        is.factor(agent$tbl[[column]])) {
      
      agent <- col_is_factor(agent, columns = {{ column }})
    } else {
      agent <- col_is_character(agent, columns = {{ column }})
    }
  }
  
  if (column_role == "boolean.logical.categorical") {
    agent <- col_is_logical(agent, columns = {{ column }})
  }
  
  if (column_role == "country:iso3166-1-esn.string.categorical") {
    
    country_names <-
      dplyr::pull(
        get_non_null_col_sample(
          data_column = dplyr::select(agent$tbl, {{ column }}),
          sample_n = 2E8,
          make_distinct = TRUE
        )
      )
    
    agent <- 
      col_vals_in_set(
        agent,
        columns = {{ column }},
        set = country_names
      )
  }
  
  if (column_role == "country:iso3166-1-a-2.string.categorical") {
    
    agent <- 
      col_vals_in_set(
        agent,
        columns = {{ column }},
        set = countries$alpha_2
      )
  }
  
  if (column_role == "country:iso3166-1-a-3.string.categorical") {
    
    agent <- 
      col_vals_in_set(
        agent,
        columns = {{ column }},
        set = countries$alpha_3
      )
  }
  
  if (grepl("country_subd:iso3166-2\\[...\\].string", column_role)) {
    
    country <- gsub("(^.*\\[|\\].*$)", "", column_role)
    
    subd_2 <- subd_list_main[[country]]
    
    agent <- 
      col_vals_in_set(
        agent,
        columns = {{ column }},
        set = subd_2
      )
  }
  
  if (grepl(column_role, "numeric")) {
    
    agent <- 
      col_is_numeric(
        agent,
        columns = {{ column }}
      )
  }
  
  if (column_role %in% c(
    "numeric.continuous", "numeric.discrete", "numeric", "integer.discrete"
  )) {
    
    summary_list <- 
      get_table_column_summary(dplyr::select(agent$tbl, {{ column }}))
    
    agent <- 
      col_vals_between(
        agent, columns = {{ column }},
        left = summary_list$min, right = summary_list$max
      )
  }
  
  if (grepl("geo:latitude.numeric", column_role)) {
    
    agent <- 
      col_vals_between(
        agent, columns = {{ column }},
        left = -90, right = 90
      )
  }
  
  if (grepl("geo:longitude.numeric", column_role)) {
    
    agent <- 
      col_vals_between(
        agent, columns = {{ column }},
        left = -180, right = 180
      )
  }
  
  agent
}


resolve_file_filename <- function(agent,
                                  name) {
  
  if (is.null(name)) {
    
    sys_time <- format(Sys.time(), format = "%Y_%m_%d_%I_%M_%p")
    file_name <- paste0("draft_validation_plan_", sys_time, ".R")
    
  } else {
    
    if (!is.character(name)) {
      stop(
        "The value supplied to `name` must be of class 'character'.",
        call. = FALSE
      )
    }
    
    file_name <- 
      name[1] %>%
      fs::path_sanitize() %>%
      gsub("(\\.| |'|:)", "_", .) %>%
      paste0(., ".R")
  }
  
  file_name
}
